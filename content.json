{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/10/18/hello-world/"},{"title":"抽象代数笔记","text":"6.1 代数结构代数系统（代数）：非空集合 和 上的 个一元或二元运算 组成的系统。记作 。 6.1.1 代数运算设 是非空集合， 是从 到 的一个映射，则称 为集合 到 的一个 元代数运算。（其中 称作该运算的阶）。 等这些符号加上 普通 的前缀，才代表的是其原来的运算。 运算的封闭性设 为集合 到 的一个 元运算。若 ,则称 在集合 上是封闭的。e.g. 普通减运算在 上不封闭。 若称一个运算是某个集合上的运算，则该运算必须满足在这个集合上具有封闭性。 1. 运算性质 - 交换律设 为 上的二元运算，若 都有： x \\ast y = y \\ast x则称运算 在 上可交换。若已知该运算的运算表，则可通过判断该表是否满足沿主对角线对称，来判断是否满足交换律。 2. 运算性质 - 结合律设 为 上的二元运算，若 都有: (x \\ast y) \\ast z = x \\ast (y \\ast z)则称运算 在 上可结合。判断该运算是否满足结合律，不能通过运算表直观的看出来。 3. 运算性质 - 分配律设 为 上的二元运算，若 都有： x \\ast (y \\circ z) = (x \\ast y) \\circ (x \\ast z), \\quad 称 \\ast 对 \\circ 左可分配 \\\\ (y \\circ z) \\ast x = (y \\ast x) \\circ (z \\ast x), \\quad 称 \\circ 对 \\ast 右可分配则称 对 可分配。 4. 运算性质 - 吸收律设 为 上的二元运算，若 都有： x \\ast (x \\circ y) = x, \\quad 称 \\ast 对 \\circ 左可吸收 \\\\ (x \\circ y) \\ast x = x, \\quad 称 \\circ 对 \\ast 右可吸收则称 对 可吸收。若 满足交换律，则只需证明一边满足吸收律即可。e.g. 集合中的 运算对 运算可吸收。因为 （右可吸收同理）。 5. 运算性质 - 等幂律设 为 上的二元运算，若 都有: x \\ast x = x则称运算 在 上满足等幂律。 6. 运算性质 - 消去律设 为 上的二元运算，某个元素 ，若 都有： a \\ast x = a \\ast y \\ \\Rightarrow x = y, \\quad 称a是左可消去的 \\\\ x \\ast a = y \\ast a \\ \\Rightarrow x = y, \\quad 称a是右可消去的则称 关于 运算 是可消去的。若 中所有的元素都满足消去律，则可说明 满足消去律。 叫做永真蕴含式。箭头左边的式子叫做前件，右边的叫做后件。永真蕴含式表明，若前件成立，则后件一定成立。永真蕴含式的逆否形式也成立。 可消去性可以从运算表中观察到。若 满足消去律，则运算表中每一行每一列中都没有相同的元素。 6.1.2 代数常元该代数系统中与运算相关的特殊元素称作代数常元。 1. 幺元设 是定义在 上的二元运算，若存在元素 (或 ) 使得 都有： e_l \\ast x = x \\quad （或 \\ x \\ast e_r = x）则称 (或 ) 是 中关于 运算的左（右）幺元。若 既是左幺元又是右幺元，则称 是 中关于 运算的幺元。且 是 上关于 的唯一的幺元。 2. 零元设 是定义在 上的二元运算，若存在元素 (或 ) 使得 都有： \\theta_l \\ast x = \\theta_l \\quad （或 \\ x \\ast \\theta_r = \\theta_r）则称 (或 ) 是 中关于 运算的左（右）零元。若 既是左零元又是右零元，则称 是 中关于 运算的零元。且 是 上关于 的唯一的零元。 3. 逆元设 是定义在 上的二元运算， 是 中关于 运算的幺元。对于 , 如果存在 （或 ）使得： y_l \\ast x = e \\quad （或 \\ x \\ast y_r = e）则称 (或 ) 是 的左（右）逆元。若 既是左逆元又是右逆元，则称 是 的逆元。 若 运算是可结合的，且对于 存在 ，则 是 的唯一的逆元, 。 6.2 子代数6.2.1 子代数的定义设 是一个代数系统， 分别是载体 上的二元运算和一元运算， 是代数常元。若： A' \\subseteq A \\\\ A' 对 \\ast 和 \\varDelta 均封闭 \\\\ k \\subseteq A'则称 是 的子代数系统。若 ， 被称为 的最大的子代数。若 ， 被称为 的最小的子代数。最大和最小子代数被称为 的平凡子代数。其余的子代数（）被称为 的真子代数。 6.3 同态6.3.1 同态的定义设 两个具有相同构成的代数系统， 是从 到 的一个映射， 且对 满足（先运算再映射 = 先映射再运算）： f(a\\astb) = f(a) \\ast'f(b) \\\\ f(\\varDelta a) = \\varDelta'f(a) \\\\ f(k) = k'则称 为由 到 的一个同态映射， 简称同态， 记作 。 6.3.2 同态象设 是从 到 的同态映射，称 为 在映射 下的同态象。 6.3.3 同态的分类设 是从 到 的一个映射。 满射：若 中每个值都能在 中找到其原象，则称 是一个满射。 单射：若 ，都有 。则称 是一个单射。 双射：既是满射又是双射的映射。 设 是从 到 的一个同态映射。 若 是满射的，则称 是一个满同态。 若 是单射的，则称 是一个单一同态。 若 是双射的，则称 是一个同构映射，简称同构，记作 。 若 ，则称 为 上的自同态。 若 且 是双射的，则称 为 上的自同构。 6.3.4 同态的性质设 是从 到 的一个同态映射。那么 的同态象 。 是 的子代数。 若 在 中可交换（可结合），则 在 中也可交换（可结合）。 若在 中 对 可分配，则在 中 对 也可分配。 若 是 中关于运算 的幺元，则 也是 中关于运算 的幺元。 若 是 中关于运算 的零元，则 也是 中关于运算 的零元。 , 对运算 存在逆元 ；则在 中， 也有关于运算 的逆元 。 6.4 同余6.4.1 同余的定义设代数系统 ， 是载体 上的等价关系。 ： 当 时，若 ，则说明等价关系在一元运算 下是可保持的，称 是关于运算 的同余关系。 当 时，若 ，则说明等价关系在二元运算 下是可保持的，称 是关于运算 的同余关系。 若 在 上的所有运算下都是可保持的，则称 是代数系统 上的同余关系。 等价关系具有对称性、自反性、传递性。 6.4.2 与同态有关的定理设 是从 到 的一个同态映射。若在 上定义等价关系 ： \\langle a, b \\rangle \\in R, \\quad iff: g(a) = g(b)则 是 上的一个同余关系。 6.5 商代数6.5.1 商代数的定义与性质设代数系统 ， 是 上的同余关系。则称 关于 的商代数 。其中 。 是集合的集合，即等价类的集合。该集合是 的一个划分，即该集合中任意两元素（集合）的交集是空集（因为等价具有传递性）。 是集合间的运算， 是代数常元的集合。 小结：由等价关系 可以得到代数系统 的载体的一个划分，以这个划分为新的载体，按照原运算的规则建立等价类之间新的运算，这样得到的代数系统是原代数系统的商代数。 6.6 半群与独异点6.6.1 半群与子半群半群：对于一个代数系统 ， 是 上的二元运算，若运算 是可结合的，则称 为半群。子半群：设 是一个半群， 且 在 上是封闭的，那么 是 的子代数。 也是一个半群，称为 的子半群（因为结合律在子代数上可继承）。 6.6.2 独异点与子独异点独异点：含有幺元的半群（含幺半群）。子独异点：满足是原代数系统的子代数，本身是独异点，且在相同运算下与原代数系统有相同幺元，那么称为是原独异点的子独异点。 6.6.3 半群与独异点的等幂元性质设 是一个半群，若 是一个有限集，则必存在 ，使得 。证明：结合鸽巢原理。 6.6.4 交换半群与循环独异点交换半群（独异点）：在半群（独异点）中，若运算是可交换的，则称此半群（独异点）为交换半群（独异点）。 循环独异点：设 是一个独异点，若 ，则 使得 （ 是 个 做运算的意思），则称此独异点为循环独异点。 （存在一个数能把其他所有数都表示出来） 称为该循环独异点的生成元，一个循环独异点的生成元个数可以不唯一。 6.7 群6.7.1 群的定义群：设 是一个代数系统。若 运算是可结合的（是半群），并且存在幺元（是独异点），并且 ，都存在其唯一的逆元 ，则称 是一个群。 群的阶数：群的元素个数，记作 。根据 可以将群分为有限群和无限群。 6.7.2 群的性质 群中无零元。 （因为零元不可逆，故群中一定不含零元。） 群中每个元素的逆元唯一。 设 是一个群，对于 ，必存在唯一的 ，使得 。 （即群中任何两个元素都能通过运算相互表示。） 设 是一个群， ，若有 或者 ，则必有 （消去律）。 （因为没有零元，所以可以直接消去。） 设 是一个群，除幺元 外，不可能有任何别的等幂元。 群 的运算表的每一行/每一列都是 中所有元素的一个置换。 （ 中每一个元素都会在运算表中的每一行/每一列出现，并且只出现一次。）","link":"/2023/10/18/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/"},{"title":"JavaScript学习笔记","text":"Brief Syntax Introduction JS 是解释型语言。 解释型语言 与 编译型语言： 解释型：一行一行看，容易出错但方便，可以及时方便地找到出错位置以及出错原因，容易跨平台（可以嵌入到其他软件）。编译型：把高级语言预先翻译成机器语言，并把结果保存下来，速度快（编译器优化），不易出错，但不能跨平台（e.g. .exe can’t be run in MacOS)。 行末分号非必需： JS 中的每一行都可以选择使用分号终止，即编译器会自动补全没有用分号的地方。 JS 中的变量是弱类型的，即变量的类型只有在被赋值的时候才得到确认。 数据类型与变量 const 用来申明常量（一旦声明后续值不可更改），let 用来申明变量（一个变量只能申明一次，值以及值的类型可以被多次更改）。 JS 中允许一个变量未被提前申明就使用。此时该变量会被自动被申明为全局变量。若在程序的最开始加上 use strict 语句，则可以避免这支双刃剑带来的弊端。（在 strict 模式下，变量必须要先经过申明，才能被使用，否则会报错） JS 中的基本类型有数字、字符串、布尔值、符号、null 和 undefined。数字中不区分整数和浮点数。 JS 中遇到计算除法时除数为 0 的情况时，不会报错，会根据被除数的值来返回对应的结果。若被除数是正数，则返回 Infinity ；若被除数是负数，则返回 -Infinity；若被除数是 0 ，则返回 NaN (Not a Number)。除以 0 的余数（1 % 0）为 NaN 。 与 python 类似， JS 中一个 * 代表相乘， ** 则代表幂运算。 JS 中 === 表示检查是否相等，!== 表示检查是否不等。 字符串 JS 中的字符串用 '' 或 &quot;&quot; 括起来表示。若想表达的字符串中本身含有 ' 或 &quot;，则需要用到转义字符。e.g. I'm &quot;OK&quot;! 的表示是： 1'I\\'m \\&quot;OK\\&quot;!'; 在 JS 中输出多行字符串的方式是用反引号。e.g. 1234`No \\nanymore`; 与 python 类似，要把多个字符串连接起来，可以用 + 号连接。也可以通过模版字符串的方式来方便输出过程。（反引号与 ${} 的结合） 12345let name = '小明';let age = 20;let message1 = '你好, ' + name + ', 你今年' + age + '岁了!';let message2 = `你好, ${name}, 你今年${age}岁了!`//message1 = message2 JS 中的字符串是不可变的，即不能通过 s[id] = 'A' 的方式来将 s 中 id 位置的字母改成 A 。 JS 中有很多类似 python 和 C++ STL 中的字符串函数，如 toUpperCase，indexOf（搜索元素在数据结构中出现的位置，未找到则返回 -1），substring 等。 数组 JS 中的数组可以包含任意数据类型，并通过索引来访问/修改每个元素。 123a = [1, 'hello, world', ['a', b, 100]];a[0] = 'qaq';a; // a = ['qaq', 'hello, world', ['a', b, 100]] 在 JS 中允许给数组的 length 赋一个新值。除此之外，假如进行了数组的越界访问，也不会报错。 12345678var arr = [1, 2, 3];arr.length = 6;arr; // arr 变为 [1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2]arr[4] = 'qaq';arr; // arr 变为 [1, 2, undefined, undefined, 'qaq'] 同 python 的切片类似，slice() 可以将一个数组的局部“拿出来”，变成一个新的数组。 12345var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']var aCopy = arr.slice();aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G'] 如果要在数组的头部添加若干元素，可以使用 unshift() ; shift() 则可以用来把数组的第一个元素删除。splice() 则可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素。 12345678var arr = [1, 2, 3, 4];arr.unshift('A', 'B'); // 返回Array新的长度: 6arr; // ['A', 'B', 1, 2, 3, 4]arr.shift(); // 'A'arr; // ['B', 1, 2, 3, 4]// 从索引 1 开始删除 3 个元素,然后再添加 2 个元素:arr.splice(1, 3, 'qaq', 222); // 返回删除的元素 [1, 2, 3]arr; // ['B', 4, 'qaq', 222] 如果要在数组的尾部添加/删除若干元素，可以使用 push() 和 pop()。 123456789var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] 对象在 JS 中，对象是一种无序的集合数据类型，由若干键值对组成。用法与 python 中的 dictionary 很像。但 JS 对象的键必须是字符串，值可以是任意数据类型。这一点和 dictionary 对键和值类型的无限制不同（ JS 中 Map 的引入解决了这个问题）。 12345678var xiaoming = { name: 'Yiling Zhang', birth: 2003, school: 'Xidian University', height: 1.77, weight: 65, score: 100}; 函数函数的定义与调用123456789101112function get_pow(x, y) { var res = 1, i; for (i = 1; i &lt;= y; i++) res = res * x; return res;}var get_pow = function (x, y) { var res = 1, i; for (i = 1; i &lt;= y; i++) res = res * x; return res;};//匿名函数，在 JS 中函数也可以作为变量，通过这个变量就可以调用该函数。 传入函数的多个变量以逗号分隔开。如果传入某个函数的变量的个数，比该函数预先设定的要多，程序仍然会返回正确的结果，且不会报错。如果要少，则不会报错，但是结果可能不正确。 在函数的内部，系统提供了关键字 arguments。该关键字只在函数内部起作用，通过该参数可以访问到传入该函数的所有参数。可以通过访问 arguments.length() 来获取到传入某个函数的参数的个数。 12345678910function abs() { if (arguments.length() == 0) return 0; else { var x = arguments[0]; return x &gt;= 0 ? x : -x; }}abs(); // 0abs(-2, 1); // 2 变量作用域与解构赋值局部作用域、块级作用域若在函数内部用 var 申明变量，则该变量的作用域是该函数内部，即这是一个局部变量。 在 JS 中允许函数的嵌套，即某个函数内可以定义另一个函数。同时允许内函数和外函数中定义重名的变量。 函数在查找变量时从自身函数定义开始，从内向外查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。 123456789use strict;function f() { var x = 1; function g() { var x = 2; x; // x = 2 } x; // x = 1} 在函数内部中用 var 申明一个变量，该变量会在整个函数中都起作用，不具有块级作用域。用 let 来申明则不会有这种问题，新申明的变量会具有块级作用域。 1234567891011function f() { var sum = 0; for (var i = 0; i &lt; 100; i++) sum += i; i++; // 仍然可以使用在上一个循环内定义的i}function f() { var sum = 0; for (let i = 0; i &lt; 100; i++) sum += i; i++; // SyntaxError （与在c++中的逻辑一样）} 请严格遵守在函数内部首先申明所有变量这一规则！否则会出一些奇奇怪怪的错误。 全局作用域不在任何函数内定义的变量就具有全局作用域。 JS 默认有一个全局对象window ，全局作用域的变量（变量、函数等）实际上被绑定到 window 的一个属性。 123var x = 1;alert(x); // 1alert(windows.x); // 1 解构赋值在 JS 中可以使用解构赋值，直接对多个变量同时赋值： 1234let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']];x; // 'hello'y; // 'JavaScript'z; // 'ES6' 12345678910111213var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school'};let {name, passport : id} = person; // 把passport属性赋值给变量id:name; // '小明'id; // 'G-12345678'// 注意: passport不是变量，而是为了让变量id获得passport属性:passport; // Uncaught ReferenceError: passport is not defined 解构赋值在很多时候可以大大简化代码。例如，交换两个变量 $x$ 和 $y$ 的值，可以这么写，不再需要临时变量： 12var x = 1, y = 2;[x, y] = [y, x] 快速获取当前页面的域名和路径： 1var {hostname : domain, pathname : path} = location; 如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个 Date 对象： 123456function buildDate({year, month, day, hour = 0, minute = 0, second = 0}) { return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);}buildDate({ year: 2017, month: 1, day: 1 }); // Sun Jan 01 2017 00:00:00 GMT+0800 (CST)// 传入的对象只需要year、month和day这三个属性 方法可以给对象绑定函数。绑定到对象上的函数叫 方法 ，其在内部使用了 this 关键字。 在方法内部， this 始终指向当前对象。 1234567891011var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; }};xiaoming.age; // function xiaoming.age()xiaoming.age(); // 今年调用是25,明年调用就变成26了 若不通过某个对象直接在函数里调用 this ，this 默认指向 windows 。在 strict 模式下，函数的 this 指向的是 undefined ，从而系统会报错提醒你这里的不规范写法。故要保证 this 指向正确，必须用 obj.xxx() 的形式调用，或者可以用一个变量首先捕获 this 。 12345678910111213'use strict';var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; }};var fn = xiaoming.age;fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined 12345678910111213141516'use strict';var xiaoming = { name: '小明', birth: 1990, age: function () { var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() { var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this } return getAgeFromBirth(); }};xiaoming.age(); // 25","link":"/2023/10/19/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[],"categories":[],"pages":[]}