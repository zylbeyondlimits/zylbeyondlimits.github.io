{"posts":[{"title":"About me","text":"今年大三，西安电子科技大学-计算机科学与技术专业在读。这个博客主要是用于记录自己学习生涯中的笔记、平时阅读到好书好句时的一些摘抄、以及一些随笔。后期可能会上传一些自己的摄影作品。希望自己能做一个万物学徒，一个一直在思考的人。","link":"/2023/10/19/About%20me/"},{"title":"算法题复健记录","text":"PTA CCCC L2-044. 大众情人Linkhttps://pintia.cn/problem-sets/994805046380707840/exam/problems/1518582589840875520?type=7&amp;page=0 Solution由题目中对两人距离的定义且结合数据范围，用 Flyod 求出各点之间的最短路，再求出不同性别的点之间的最长路。因为空格换行的问题超了几次时，无大语…… Codehttps://paste.ubuntu.com/p/Qjq7FHQpbG/ \\quadPTA CCCC L2-043. 龙龙送外卖Linkhttps://pintia.cn/problem-sets/994805046380707840/exam/problems/1518582482059845632?type=7&amp;page=0 Solution考虑到深度越深，从这个点回根结点的代价越大。所以最深的点一定最后访问。 将所有点分为两类： 对于不和最深的点在同一颗子树下的点 ，一定要花费 的代价（要去往下一个子树，必定要上去经过根结点）。 对于和最深的点在同一颗子树下的点 ，花费的代价是 ，其中 是 到已经访问过的点的距离。第一类问题也可以并到第二类中（若新加入的点在新的子树中，离它最近的、“被访问过的点”就是根结点）。 故每次加入新的点时，用一个变量累计每个点的所有代价，最后减去出现过的点中最深的那个点的深度。 Codehttps://paste.ubuntu.com/p/tgPvCvK8wm/ \\quadABC-222 D. Between Two ArraysLinkhttps://atcoder.jp/contests/abc222/tasks/abc222_d Solution令 表示现在考虑到了第 位，且让 时的方案数。 f_{i, j} = \\begin{cases} \\sum_{k = 0} ^ {j} f_{i - 1, k} \\quad , a_i \\leq j \\leq b_i \\\\ 1 \\quad , i = j = 0\\\\ 0 \\quad , otherwise\\\\ \\end{cases}最终的答案为： \\sum_{j = max\\{a_i\\}} ^ {max\\{ b_i\\}} f[n][j] \\quad, 1 \\leq i \\leq n利用前缀和优化的方法可以把时间复杂度由 降为 。 Codehttps://paste.ubuntu.com/p/2tdHH8HkQV/ \\quadNowcoder-75771 D. 我不是大富翁Linkhttps://ac.nowcoder.com/acm/contest/75771/D Solution将题目中“圆盘范围 ，最开始在 上”等效为 “圆盘范围 ，最开始在 上”。便可以使用余数的性质。 令 表示进行到了第 轮，能否到达 。两个方向分别转移即可。（不知道比赛的时候在干嘛，想成分别把 和 放进去然后 01 背包，最后看能否表示……不知道怎么想出这种“仔细一想就会发现问题”的做法的）。 Codehttps://paste.ubuntu.com/p/rvp9hbcVy5/ \\quadNowcoder-75771 E. 多重映射Linkhttps://ac.nowcoder.com/acm/contest/75771/E Solution由于前面的操作会被后面所覆盖，考虑逆序处理。同时还结合并查集的思想，是一道很妙的思维题。多组数据不能每次清空数组，这种情况下可以使用 map 动态维护。 Codehttps://paste.ubuntu.com/p/vsVmSMGjHZ/ \\quadAtcoder-dp SushiLinkhttps://www.luogu.com.cn/problem/AT_dp_j Solution拥有相同寿司数量的盒子被抽中的概率一样，且对答案的贡献也一样，故谁先谁后对答案无影响。这是期望 dp 常见的破局点，由此可以想到用个数与状态产生联系。 结合数据范围，令 表示当前有 个空盘子， 个有 1 个寿司的盘子， 个有 2 个寿司的盘子， 个有 3 个寿司的盘子时，清空他们需要的期望轮数。 f_{i, j, k, l} = \\frac{i}{i + j + k + l} \\cdot f_{i, j, k, l} \\ + \\ \\frac{j}{i + j + k + l} \\cdot f_{i + 1, j - 1, k, l} \\\\ + \\ \\frac{k}{i + j + k + l} \\cdot f_{i, j + 1, k - 1, l} \\ + \\ \\frac{l}{i + j + k + l} \\cdot f_{i, j, k + 1, l - 1} + 1 \\\\ \\quad \\\\ i + j + k + l = n移项化简可得： f_{i, j, k, l} = \\frac{j}{j + k + l} \\cdot f_{i + 1, j - 1, k, l} \\ + \\ \\frac{k}{j + k + l} \\cdot f_{i, j + 1, k - 1, l} \\ + \\ \\frac{l}{j + k + l} \\cdot f_{i, j, k + 1, l - 1} + \\frac{n}{j + k + l}发现 这一维度没有什么作用（本身也可以通过 计算出来，且保留的话状态数太多无法存下），所以可以删去。 Codehttps://paste.ubuntu.com/p/ZZ7DBh5Qs2/ \\quadPTA CCCC L2-039. 清点代码库Linkhttps://pintia.cn/problem-sets/994805046380707840/exam/problems/1386335159927652362?type=7&amp;page=1 SolutionSTL 的应用。通过这道题练习了 map 与 vector 的结合，以及 vector 有自带的比较运算（比较的方法： 比 大，当且仅当 ）。 Codehttps://paste.ubuntu.com/p/hKYgt6Dj77/https://paste.ubuntu.com/p/m6b798HjG5/ \\quadAcwing 340. 通信线路Linkhttps://www.acwing.com/problem/content/342/ Solution问题中的单调性显而易见，二分最终需要支付的最高费用 ，在图上跑最短路，计算起点到终点最少有几条电缆需要被免费升级（原图上边权大于 的边贡献为 ，否则贡献为 ）。 Codehttps://paste.ubuntu.com/p/Dwp4FrtHKX/ \\quadAcwing 1135. 新年好Linkhttps://www.acwing.com/problem/content/1137/ Solution考虑到亲戚的数量只有 5 个，故依次访问亲戚的顺序只有 种情况。以源点和每个亲戚为起点，预处理出到所有点的最短路，借助 next_permutation 枚举亲戚的访问顺序，统计答案。 Codehttps://paste.ubuntu.com/p/5tKpjCgGjM/ \\quadAcwing 100. 增减序列Linkhttps://www.acwing.com/problem/content/102/ Solution题目希望「选择多段区间 ，对区间整体加 / 减 」，联想到差分数组对区间进行修改；再看到「让所有数都一样」的最终目标，在差分数组上的体现是全为 。 故题目可以等效为：每次对差分数组选择两个位置 ，一个加 ，一个减 ，使得最终所有位置上的数字变成 。对于 上的每队正数和负数需要进行操作，剩余多出来的正数/负数可以放在 的位置 / 的位置。故最终必要的最少操作次数是 ，不同的结果有 。 Codehttps://paste.ubuntu.com/p/KRQn8BcHMM/","link":"/2023/10/16/%E7%AE%97%E6%B3%95%E9%A2%98%E5%A4%8D%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"title":"「加缪手记」摘抄","text":"10.15序：写下生命中对思考创作有意义的当下片段，本质上即是赋予无形体验以有形的存在和表现形式。 8月的雷雨天。热风和乌云。但东方却透出一抹晴蓝，轻盈而剔透。叫人无法直视。这样的蓝，对眼睛和灵魂来说都是一种折磨。因为美会让人受不了。美会让人万念俱灰，因为我们是多想要让这种刹那的永恒一直持续下去。 年轻时，我会向众生索要他们能力范围之外的：友谊长存，热情不灭。如今，我明白只能要求对方能力范围之内的：做伴就好，不用说话。而他们的情感、友谊和操守，在我眼中仍完全是一种奇迹，是恩惠的完全表现。 时间会过得这么快，是因为我们没办法在里面做什么记号。类似月亮是在天顶还是在地平线之上类的。这就是为什么那些青春岁月如此漫长，因为太丰盛，而年华老去时则光阴似箭，因为一切都已成定局。譬如我就发现几乎不可能盯着一根指针在钟面上绕五分钟，而不会感到漫长和厌烦的。 一阵颇带劲的微风从山上吹下来，翻搅着青草与阳光。令人赞叹之光从天而降。底下是光滑无痕的海面，正露着它的蓝色牙齿在微笑。我站在风里，头顶上的太阳只能晒到一边的脸庞。我凝视着这个独一无二的时刻流逝，不晓得该说些什么。 10.16有时候我也需要写下一些自己也不太明白，但却正好可以证明我有个无法羁束的内在的东西。 他每天都到山上去，又默默地回来，头发上都是草，身上都是一整天下来的刮痕。每一次都是无须勾引就被诱惑了。对这个不友善的地方，他内心的抗拒逐渐在减弱。他终于可以想象自己是棱线上那株孤杉背后的多多白云，是那漫山遍野、有着粉红斑点的柳叶菜、花楸和风铃草。他让自己融入了这个嶙峋的芬芳国度。登上遥不可及的山巅时，眼前豁然一片无际的风光，但他内心初生的爱意并未因此获得舒缓，而是暗自和这个不仁的天地订立某种约定，两张刚强倨傲的脸庞之间的停战协议，像敌人在互相威吓，而非朋友间的全然信赖。 在这个溢满繁星的夜里，他伸出手在夜空静谧无边的脸上比画着。他一只胳膊一挥，就把这颗明星和另外那颗时隐时现的星星分开了，一束束的星辰和一朵朵的云，就随着他的挥洒散落下来。于是天上有一池被他搅乱的水，而围绕着他的那座城市，宛如一顶缀满贝壳的华丽斗篷。 人在马赛，幸福和悲哀——在我内心最深处。我喜爱的繁华都市。但同时这孤独的苦味。 灿烂宣泄的阳光。摩纳哥的夹竹桃和繁花遍地的热那亚。利古里亚海岸线上的蓝色夜晚。我的疲倦和这股想哭的冲动。这种孤单和这份想要爱的渴望。比萨，一个腼腆而敏感的城市。夜里，在无人的街道上，它和我靠得这么近，我在街上漫游，想要流出来的眼泪终于决堤了。我内心那道伤口也开始愈合了。 10.17某些事物、某些生命正在等着我，而我当然也在期待着，用我所有的力量和悲情渴望着。 也许我眼前的景物已经被好几百万只眼睛注视过了，但对我而言，它宛如这世界浮现的第一抹微笑。这个世界很美，一切尽在其中。它耐心地宣扬它的伟大真理：那些所谓的精神和心灵，其实都是虚空。而在这个由骄阳下的发烫石头，晴空下更显高大的柏树所界定出来的、独一无二的天地中，“正确”的意思是“无人的大自然”。它带着我直到尽头。它心平气和地否定了我。而我，心悦诚服地，朝着某种圆融的智慧前进——如果我不要这样热泪盈眶，如果我想要号啕大哭的诗心未曾令我将这世界的真理抛却脑后。 舔舐自己的生命，仿佛那是一颗麦芽糖，塑造它，磨砺它，爱它。 我一定会努力将这场和自己的面对面一直延续到底，让它照见我在今生今世中的每一张脸，即使必须付出难以负担的寂寞代价亦在所不惜。我会竭尽全力去达成某个境界，在那儿和我的所爱会合，接着，我俩将以最大的热情去做那些构成我每日生活意义的事。 脸上交织着泪光和阳光的人生，没有盐巴的人生和热石头，一如我所爱、所渴望的人生，我一面怀想着，觉得似乎我所有绝望和爱的力量都因此集合起来了。 10.18艾尔凯达墓园。阴霾的天，满山的白纹和对面的大海。潮湿的土壤和树木。白色墓碑间的鸽子。一朵孤单的天竺葵，颜色难说是粉红还是红。一股迷茫而沉默的巨大悲伤，让死亡那张美丽纯洁的脸庞变得亲切起来。 他说：“每个人生命中都要有爱，一种大爱，因为这样就可以有借口不用去面对那些令人不堪负荷、说不出缘由的绝望。” 他轻轻咬着她的唇，然后，一连好几分钟，嘴对着嘴，吸吮着这令他心神荡漾的温热，仿佛整个世界都拥进怀里了。至于她，像个溺水的人似的抱着他，在这个被人推下去的黑洞里载沉载浮，那两片唇被推开后又会立刻黏上来，她于是再度坠入一片又冷又黑、宛如一群天使般让她浑身着火的水中。 10.25这个世界的悲惨和伟大：不给我们任何真相，但有许多爱。荒谬当道，爱拯救之。 尼采：“当我们见到美的时候心里想要的是什么呢？希望自己也是美的。我们可以想象有多少快乐都寄托在上面，但这是个错误。”（《人性的，太人性的》） 我们所感受到的情感并不会改造我们，但是会让我们有那种想要改变的念头。所以爱并不能让我们不再自私，却可以令我们对此有所察觉，并让我们开始向往一个没有自私的遥远国度。 艺术家和艺术作品。真正的艺术作品是那种点到为止的。一个艺术家的整体经验和他的想法、人生（就某种意义而言即他的“系统”——除掉这个字的系统性意涵的话）之间，有着某种关联，而作品正是这种经验的反映。如果艺术作品把整个经验都讲出来，还包上一层文艺的流苏，那么此一关联就是恶劣的。但如果艺术作品只是从整个经验中切削下来的一小块，像钻石的一个切面，内蕴的光芒将无穷扩散。第一种是超载的文学。第二种则是沃土般的作品，那些不言而喻的经验正暗示着它丰富的内容。问题在于如何取得这种超出写作技巧的处世之道（不如说是经验谈）。到头来，伟大的艺术家其实就是一个了不起的活人（“活着”在这里亦指思考生命——或说是经验和因而产生的意识之间的那种微妙关系）。 他躺下来，傻笑，两只眼睛闪闪发光。她觉得自己所有的爱都哽在喉头，热泪盈眶。她扑向他的双唇，泪珠都让两人的脸庞挤碎了。泪水也流进了她的嘴里。而他，他咬着这两片咸咸的嘴唇，像是在咀嚼他们爱情里的苦涩。 火车上的小情侣。两个都长得不好看。她拉着他，笑吟吟的，撒娇，撩拨他。而他，两眼无神，因在大庭广众之下被一个他并不引以为傲的女人爱着而感到尴尬。 今天，如果我试着去把这独特的感动说清楚，我可以从中看到很多东西。当然，这样的喜悦首先来自让娜——来自她身上的香水味，她紧紧扣着我手腕的手，一些我可预期的表情。但还有那些突然光芒四射的商店，在一个平常伸手不见五指的城区里，行色匆匆，手上提着大包小包的行人，街上孩子的欢笑声，一切都有助于把人从他的原本的孤独世界里拉出来。那些夹心巧克力的银色包装纸就是一种征兆，意味着一个模糊却嘈杂的黄金时期，正在向一些简单的心灵打开，于是让娜和我又依偎地更紧了。也许当时我们都模模糊糊地感觉到了那种独一无二的、当一个人跟自己的人生终于取得妥协时的幸福。通常是我们在一个爱已无立足之地的世界里，带着那片被我们用爱情施了魔咒的沙漠到处游走。而在那几天里，我们觉得当我们手牵手时，心中升起的那把热情，和在橱窗里、在对儿女牵肠挂肚的工人心里，以及在这12月冰冻而纯净的天空深处闪烁的，是一样的火焰。 天气只好一半：有云也有阳光。和谐的地方。只要一大块天，就能让最紧张的心平静下来。 从圣塔克鲁斯看米尔斯克比尔，给人一种雄伟感。壮观得毫不温柔。 10.27这棵柏树上饱吸的金色阳光艳澄欲滴，感觉仿佛有一股黄色汁液，从这树的黑色心底涌上来，流过它每一根短短的树枝直到末梢，然后一条条长长的浅褐色就沿着那些绿油油的叶片淌下来。 …就像有人动不动就喜欢拿铅笔在书上画线，似乎这样可以显示出该读者很有品味，很有智慧的样子。 战场上。人们评估着每一条战线各自的危险程度。“我的这条危险性最高。”在全面的沉沦之中，他们还能分高下。他们就靠这个渡过难关。 爱伦·坡的四大快乐要件。 （1）户外生活。 （2）有人爱。 （3）放开一切野心。 （4）创造。 大家都会问战争在何处——那种惨不忍睹的场面在哪里？然后意识到自己其实知道答案，战争就在我们心里。战争对大部分的人而言，是那份不自在，那种被迫做出的选择。选择出征的后悔自己勇气不足不敢缺席。选择缺席的则自责不能和其他人同生共死。战争在此，真真切切，而我们还在蓝天里、在世间的不仁中遍寻它。它就在身为战士和非战士的可怕孤寂里，在人人感同身受的屈辱和绝望里，在那种随着日子流逝，人们脸上愈来愈明显的卑鄙和龌龊里。牲畜横行的时代开始了。 我们在众生身上已经可以感受到这股愈来愈高涨的仇恨和暴力。他们心中的纯真已荡然无存。再也没有什么是无价之宝了。他们的想法都一样。路上碰到的都是禽兽，一些看起来很像动物的欧洲脸。这个令人作呕的世界和这股全球风行的昏庸愚昧，勇气变得微不足道，伟大可以仿冒，荣誉感逐日式微。 巴黎之春：某个预兆或栗树上一颗芽孢，人心就开始痒了起来。在阿尔及尔，春来得粗暴多了。这里不只是一颗玫瑰花苞，而是一千颗玫瑰花苞，在某天清晨，突然让你无法呼吸。在这里，我们不是被某种难以捕捉的热情闪过脑际，而是教千百种铺天盖地汹涌而至的香气和色彩贯穿全身。这里当道的不是敏感纤细，而是被突袭的身体。 10.30夜晚，在“两大奇景”的露天咖啡座上。我们可以隐约听见海在夜深处的悸动。橄榄树的微颤和从地面冒上来的雾气。冒出海面的岩石上立满白色海鸥。灰沉沉的一群，被翅膀上的雪光照亮了，宛如一个个晶莹的漂冢。 小说。故事在一片灼热而碧蓝的沙滩上展开，两个有着古铜色皮肤的年轻人——海水浴、浪花和日光的嬉戏——夏天夜晚，滨海公路上的果香和阴影深处飘来的雾气——轻衫中自由自在的身躯。吸引力，一颗17岁的心内的秘密微醺。同上。另外一个在寒冷的暴风雨夜开始的故事，仰躺在地，在一片丝柏的中间，天上流动着星星和云。刚开始这并非出于爱，而是一种活下去的欲念。然而，在那座正方形的盖在海上面的大房子里，当这两幅躯体结合在一起，于逆风登高之后紧紧相拥，听见大海那沉闷的呼吸声从地平线彼端传进这个与世隔绝的房间里时，爱情真的是如此遥远吗？在这个奇妙的夜晚，爱的希望和雨水、天空和大地的沉寂是紧紧结合在一起的。两个因大自然而结合的生命之间的微妙平衡，两人共同的那种对一切非此时此地者的漠视，让他们看起来很像。另外这一个仿佛是某种舞蹈的时刻，她穿着有设计的礼服，他则是全套舞衣。 从滨海公路上看过去，那些悬崖是如此之高，以至于眼前的风景因为太珍贵了，竟予人一种虚幻感。人类全被从里面赶了出来，而那种杳无人迹的程度，让这么沉重的美宛若来自另外一个世界。 “哦，我的灵魂，不要向往不朽的生命，但要穷尽一切的可能性。” 海在下面低嗥。但阳光、微风、阿福花的洁白、天上那种已经硬化的蓝，一切都让人想到夏日，它那金黄色的青春，那些女孩男孩的古铜色肌肤，初生的激情，长时间的日晒和傍晚骤然到来的温煦。还能赋予我们这个时代什么其他的意义，除了这高原的启示之外：一边是生，一边是死，在这两种美之间的，是忧郁。 奥兰。诺塞谷：沿着两边枯干而灰尘漫扬的坡地慢慢走。日头下的地面开始龟裂。石头色的乳香黄连木。头顶的天，按时地将它储备的热与火热倾泻而下。渐渐地，黄连木愈来愈高大，颜色也转绿了。走了很长一段路之后，黄连木渐渐被橡树取代，一切都变高长大也和缓了下来，然后，在一个急转弯处，一片开满花的杏林：像是给眼睛喝的凉水。一个宛如失乐园的小山谷。可以眺望大海的山坡路。车子能通但人迹罕至。现在上面都是花。雏菊和毛茛铺出了一条又黄又白的路。 释加牟尼在荒漠中多年，一动不动，眼睛望着天空。连神祇们都妒忌这种智慧和这磐石般的宿命。在他那张开的僵硬的手里，有燕儿来筑巢。但某天，它们展翅而去，一去不返。而那曾经令他内心之渴望与意志、荣耀与痛苦全部寂灭了的东西，开始分泌泪水。石头于是长出了花。 风，这世上罕见的干净东西之一。 11.1一旦做出了荒谬的结论并愿意接受这样的人生，人就会发现意识是世界上最难把持的东西。所有的状况几乎都在跟它作对。事关如何在一个分崩离析的世界里保持清醒。人于是发现，即使没有了上帝，真正的问题还是在于如何解决心理上的混乱（荒谬的作用实际上只会对精神和物质世界的形而上层面造成混乱）并得到内心的平静。他会发现未曾经过严格训练，不知如何与外界取得协调的话，内心就不可能获致平静。所以要去建立的，是尘世生活规范。过去的人生（工作、婚姻、以前的想法等等），那些已发生之事，都会带来阻碍。不规避此问题的任一成因。 海涅的墓志铭：“他喜欢布伦塔河的玫瑰。” 人永远都有一套哲理来解释自己为何缺乏勇气。 11.5面包总管。日出之前，在高耸丘陵上，那些冷杉和底下簇拥着的林涛仍浑然一体。接着，太阳从后面很远的地方把树梢全染成金色。于是在尚未褪色的天空下，仿佛有一整群头上插着羽毛的野蛮人，从山坡后面冒出来。太阳愈高，天空愈澄澈，冷杉也跟着长大，野蛮部队看似步步进逼，集结出一大片闹哄哄、准备发动攻击的羽毛。然后，当太阳爬得够高时，整面山坡上的冷杉一下子全被照亮了。看起来就像野人们正往谷底狂奔而去，一场剧烈而短暂的战斗已然开始，白日的蛮族即将对夜之冥思的残部展开驱逐。 面包总管。9月的第一场雨，伴随着一阵把黄叶打落大雨中的轻风。那些叶子会先在空中一阵飘荡，直到叶片上乘载的雨滴重得突然将它们压倒在地。如果风景很普通，像这里，反而让人更能察觉到四季的变换。 “在床尾，因这临终前的每一声喘息而抽搐，没有哭泣但偶尔会被眼泪湿透，我母亲看起来就像一片任凭风吹雨打，饱受摧残的叶子。”——盖尔芒特 10月。犹然青翠的草地上落叶枯黄。一阵急促而有力的风，用有声的阳光，在那片绿色的草原砧板上打造出一道光芒，里头群蜂嘈杂，声音一直传到我这边。红之美。壮丽、有毒和孤单，像橘红色一样。 相较于天才，这么拼命地努力就如蟋蟀那断断续续的飞行之于燕子的翱翔。 “偶尔，在受够了这种听令于意志的日子，眼见着这件不许分心不许软弱，刻意忽略情绪和外界的工作逐渐完成，啊！那突如其来的是何等的懒散，我怀着的又是何等的解脱感，一头栽进这些日子以来一直陪伴着我的绝望之中。何其希望，何其渴求再也没什么需要建立的，并放弃这件作品，和我这张必然是它捏塑而变得严苛的脸。我曾经也会爱，会后悔，会有欲望，总之我也曾经是个正常人……”“……夏日荒漠般的天空，我如此热爱的大海，还有那些迎上来的唇。” 秋天的森林里，山毛榉就像一块块金黄色斑点，孤立在树林边缘上的，看起来就像从一片大蜂巢淌流出来的金色蜂蜜。 秋天，这片景色里的叶子全盛开了——樱桃树成了大红，槭树是黄的，山毛榉是古铜色的。草原上覆满了这第二春之千朵焰火。 一位作家首先要学会的技巧，就是如何将他感受到的转换成他想要让人感受到的。前面几次的成功都是偶然。但接下来偶然一定要被才情所取代。所以说天才的崛起有一部分须归功于运气。 我高坐船头，继续着这趟在漠然国度里一动不动的航行。至少需要整个大自然和这种冬日为太热情的心所带来的白色和平——才能安抚这颗为苦恋所吞噬之心。我望着天空中那片越来越膨胀、否认了一切死亡预兆的光。未来的象征，终于出现在我这如今只知追忆过往之人的顶上。闭嘴吧，肺！大口大口地吞下这苍白而凛冽、可以滋养你的空气。别再吵了。愿我无需再被迫听着你那缓慢的腐朽——愿我终于能够朝向……","link":"/2023/10/15/%E3%80%8C%E5%8A%A0%E7%BC%AA%E6%89%8B%E8%AE%B0%E3%80%8D%E6%91%98%E6%8A%84/"},{"title":"MIT 6.824 - Lab 1: MapReduce","text":"coordinator = master. Notes： worker 通过 RPC 与 master 进行交流。 worker 向 master 主动申请被分配一个任务。若该 worker 未在 10 秒内完成任务，master 应将该任务分发给另一个 worker。 在 mr/master.go, mr/worker.go, mr/rpc.go 中编写程序。 mrsequential.go：串行实现 MapReduce 的示例。可从中借鉴以下功能的实现：reading Map input files、sorting intermedate key/value pairs between the Map and Reduce、storing Reduce output in files. main\\mrmaster.go、main\\mrworker.go：master 和 worker 的示例程序，从中得知主要的流程。","link":"/2024/04/23/MIT-6-824-Lab-1-MapReduce/"},{"title":"Go学习笔记","text":"Syntax Summary Go 中的 if 与 for 必须要加大括号 {}。 函数列表里的变量定义，先名称后类型。 Web crawler1. 串行实现基于深度优先搜索。在找到一个 url 后，从这个 url 继续往下搜。本质是递归，串行。 12345678910111213141516// Serial crawlerfunc Serial(url string, fetcher Fetcher, fetched map[string]bool) { if fetched[url] { return } fetched[url] = true urls, err := fetcher.Fetch(url) if err != nil { return } for _, u := range urls { Serial(u, fetcher, fetched) } return} 2. 并行实现1 - WaitGroup12345678910111213141516171819202122232425262728293031323334353637383940414243// Concurrent crawler with shared state and Mutextype fetchState struct { mu sync.Mutex fetched map[string]bool}func ConcurrentMutex(url string, fetcher Fetcher, f *fetchState) { f.mu.Lock() already := f.fetched[url] f.fetched[url] = true f.mu.Unlock() if already { return } urls, err := fetcher.Fetch(url) if err != nil { return } var done sync.WaitGroup for _, u := range urls { done.Add(1) //u2 := u //go func() { // defer done.Done() // ConcurrentMutex(u2, fetcher, f) //}() go func(u string) { defer done.Done() ConcurrentMutex(u, fetcher, f) }(u) } done.Wait() return}func makeState() *fetchState { f := &amp;fetchState{} f.fetched = make(map[string]bool) return f} 3. 并行实现2 - Channel123456789101112131415161718192021222324252627282930313233343536// Concurrent crawler with channelsfunc worker(url string, ch chan []string, fetcher Fetcher) { urls, err := fetcher.Fetch(url) if err != nil { ch &lt;- []string{} } else { ch &lt;- urls }}func master(ch chan []string, fetcher Fetcher) { n := 1 fetched := make(map[string]bool) for urls := range ch { for _, u := range urls { if fetched[u] == false { fetched[u] = true n += 1 go worker(u, ch, fetcher) } } n -= 1 if n == 0 { break } }}func ConcurrentChannel(url string, fetcher Fetcher) { ch := make(chan []string) go func() { ch &lt;- []string{url} }() master(ch, fetcher)} 附：其他部分的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// mainfunc main() { fmt.Printf(\"=== Serial ===\\n\") Serial(\"http://golang.org/\", fetcher, make(map[string]bool)) fmt.Printf(\"=== ConcurrentMutex ===\\n\") ConcurrentMutex(\"http://golang.org/\", fetcher, makeState()) fmt.Printf(\"=== ConcurrentChannel ===\\n\") ConcurrentChannel(\"http://golang.org/\", fetcher)}// Fetchertype Fetcher interface { // Fetch returns a slice of URLs found on the page. Fetch(url string) (urls []string, err error)}// fakeFetcher is Fetcher that returns canned results.type fakeFetcher map[string]*fakeResulttype fakeResult struct { body string urls []string}func (f fakeFetcher) Fetch(url string) ([]string, error) { if res, ok := f[url]; ok { fmt.Printf(\"found: %s\\n\", url) return res.urls, nil } fmt.Printf(\"missing: %s\\n\", url) return nil, fmt.Errorf(\"not found: %s\", url)}// fetcher is a populated fakeFetcher.var fetcher = fakeFetcher{ \"http://golang.org/\": &amp;fakeResult{ \"The Go Programming Language\", []string{ \"http://golang.org/pkg/\", \"http://golang.org/cmd/\", }, }, \"http://golang.org/pkg/\": &amp;fakeResult{ \"Packages\", []string{ \"http://golang.org/\", \"http://golang.org/cmd/\", \"http://golang.org/pkg/fmt/\", \"http://golang.org/pkg/os/\", }, }, \"http://golang.org/pkg/fmt/\": &amp;fakeResult{ \"Package fmt\", []string{ \"http://golang.org/\", \"http://golang.org/pkg/\", }, }, \"http://golang.org/pkg/os/\": &amp;fakeResult{ \"Package os\", []string{ \"http://golang.org/\", \"http://golang.org/pkg/\", }, },}","link":"/2024/04/06/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"大数据安全与隐私 - Lab1 - 现代密码学基础技能","text":"1. 实验内容模拟实现 DH 密钥交换协议（基于大素数进行算法实现），并生成会话密钥。利用会话密钥对字符串进行正确的加密和解密，且需要使得相同内容每次发送的密文不同。 2. 实验原理2.1 Diffie–Hellman 密钥交换协议利用离散对数问题的特性（ 是一个单位元为 的、其中一个生成元为 的乘法循环群）： Alice 和 Bob 想要通过对称加密来传输信息，现他们需要协商那个用于后续加密的密钥。 以下运算默认在模 意义下进行。 在整个过程中，, , , 都作为公开信息在信道上传输，有被 Eve 获取到的可能性。但很难从这些信息推出 与 。 就作为那个协商好的密钥。 123456789101112131415161718192021222324252627282930# generate_large_prime函数，用于生成大素数def generate_large_prime(bits): while True: # 生成一个 bits 位的随机数作为候选素数 candidate = random.getrandbits(bits) # 调用 nextprime 函数检查候选数是否为素数，并返回下一个素数 prime_candidate = nextprime(candidate) if prime_candidate.bit_length() == bits: return prime_candidate# 使用 Diffie-Hellman 密钥交换协议生成两个大素数g = generate_large_prime(1024) # prime1: gp = generate_large_prime(1024) # prime2: pprint(\"\\nThe 1st 1024-bit big prime number is: \", g)print(\"\\nThe 2nd 1024-bit big prime number is: \", p)a = randint(2**10, 2**20)b = randint(2**10, 2**20)x = pow(g, a, p) # x = g ^ a % py = pow(g, b, p) # y = g ^ b % pkeya = pow(y, a, p) # keya = ((g ^ b) ^ a) % p = (g ^ ab) % pkeyb = pow(x, b, p) # keyb = ((g ^ a) ^ b) % p = (g ^ ab) % pprint(\"\\nA's secret key is:\", keya)print(\"\\nB's secret key is:\", keyb)# 检查双方的密钥是否相同，如果相同则表示 Diffie-Hellman 密钥交换成功if keya == keyb : print(\"\\nA's secret key is equal to B's secret key.\") print(\"\\nDiffie-Hellman key exchange succeed.\") 2.2 AES 加解密AES 加密算法在该实验中通过 Crypto.Cipher.AES 模块实现，具体使用的是 CBC（Cipher BlockChaining）模式。 AES 是一种分组加密算法，它将明文分成固定大小的块，然后使用相同的密钥对每个块进行加密。本次实验中 AES 密钥的长度为 256 位（使用 SHA256 方法），分组块的长度为 128 位。 CBC 模式通过将前一个密文块的加密结果（除了第一个块，使用初始化向量IV）与当前明文块进行异或操作后再加密，从而增加加密的复杂性和安全性。这种模式可以有效防止相同明文块产生相同的密文块，提高了安全性。 代码中还引入了 pad 与 unpad 功能。使用他们是为了确保 AES 加密和解密操作的正确性和完整性（AES 算法要求加密的数据必须是固定大小的块）。 12345678910111213141516171819202122232425# generate_key函数，用于从共享密钥生成 AES 密钥def generate_key(secret): # 使用 SHA-256 散列算法对共享密钥进行散列，然后返回散列值作为 AES 密钥 key = hashlib.sha256(secret.encode()).digest() return key# encrypt_message函数，用于加密消息def encrypt_message(message, key): # 使用 AES 算法和 CBC 模式创建一个新的加密器实例 cipher = AES.new(key, AES.MODE_CBC) # 对消息进行填充，然后使用加密器进行加密 ciphertext = cipher.encrypt(pad(message.encode(), AES.block_size)) iv = cipher.iv return iv + ciphertext# decrypt_message函数，用于解密消息def decrypt_message(encrypted_message, key): # 从加密的消息中提取 IV 和密文 iv = encrypted_message[:AES.block_size] ciphertext = encrypted_message[AES.block_size:] # 使用 AES 算法和 CBC 模式创建一个新的解密器实例 cipher = AES.new(key, AES.MODE_CBC, iv) # 对密文进行解密和去填充，然后返回解密后的消息 decrypted_message = unpad(cipher.decrypt(ciphertext), AES.block_size) return decrypted_message.decode() 3. 实验结果 上面两个结果表明，可以选择命令行手动输入/本地文件输入想要加密的信息。程序成功生成了两个大素数，且在此基础上计算出来的 Alice 与 Bob 的密钥（共享密钥）相同，说明成功共享了一个用于后续加密的密钥。 后续给出了 AES 的加密结果、解密结果，解密结果与输入的内容一致。 4. 实验心得Python 中提供了很方便的库，让复杂的加密过程得以被轻松的实现。 本人只实现了对文本文件的加解密，可以提升的地方包括：支持其他文件类型的加解密（如图片、pdf等）、支持将加密结果无差错的保存至本地的文件中。","link":"/2024/04/05/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%B8%8E%E9%9A%90%E7%A7%81-Lab1-%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/"},{"title":"MIT 6.824 - Lecture 1","text":"可扩展性（Scalability）如果你构建了一个系统，并且只要增加计算机的数量，系统就能相应提高性能或者吞吐量，这将会是一个巨大的成果，因为计算机只需要花钱就可以买到。 假设我们建立了一个常规网站，一般来说一个网站有一个 HTTP服务器，还有一些用户和浏览器，用户与一个基于Python或者PHP的web服务器通信，web服务器进而跟一些数据库进行交互。 当你只有1-2个用户时，一台计算机就可以运行web服务器和数据，或者一台计算机运行web服务器，一台计算机运行数据库。 但是有可能你的网站一夜之间就火了起来，为了提升性能，你要做的第一件事情就是购买更多的web服务器，然后把不同用户分到不同服务器上。这样，一部分用户可以去访问第一台web服务器，另一部分去访问第二台web服务器。 只要单台web服务器没有给数据库带来太多的压力，你可以在出现问题前添加很多web服务器，但是这种可扩展性并不是无限的。因为它们都在和同一个数据库通信。现在，数据库突然成为了瓶颈，并且增加更多的web服务器都无济于事了。 可用性（Availability）大型分布式系统中有一个大问题，那就是一些很罕见的问题会被放大。一台计算机正常工作很长时间并不少见，但对于1000台计算机也意味着平均每天会有3台计算机故障。 在一个大规模分布式系统中，各个地方总是有一些小问题出现。所以大规模系统会将一些几乎不可能并且你不需要考虑的问题，变成一个持续不断的问题。因为错误总会发生，必须要在设计时就考虑，系统能够屏蔽错误，或者说能够在出错时继续运行。 某些系统通过这种方式提供可用性。比如，你构建了一个有两个拷贝的多副本系统，其中一个故障了，另一个还能运行。当然如果两个副本都故障了，你的系统就不再有可用性。所以，可用系统通常是指，在特定的故障范围内，系统仍然能够提供服务，系统仍然是可用的。如果出现了更多的故障，系统将不再可用。 另一种容错特性是自我可恢复性（recoverability）:如果出现了问题，服务会停止工作，不再响应请求，之后有人来修复，并且在修复之后系统仍然可以正常运行，就像没有出现过问题一样。 一致性（Consistency）从性能和容错的角度来说，我们通常会有多个副本。但是在一个分布式系统中，由于复制或者缓存，数据可能存在于多个副本当中，于是就有了多个不同版本的key-value对。 强一致（Strong Consistency）:想办法使得get请求可以得到最近一次完成的put请求写入的值。虽然强一致可以确保get获取的是最新的数据，但是实现这一点的代价非常高。如果你有多个副本，那么不管get还是put都需要询问每一个副本，需要大量的通信才能得到一个数据。 所以，人们常常会使用弱一致系统，你只需要更新最近的数据副本，并且只需要从最近的副本获取数据。在学术界和现实世界（工业界），有大量关于构建弱一致性保证的研究。 MapReduceMapReduce是由Google设计，开发和使用的一个系统。Google当时面临的问题是，他们需要在TB级别的数据上进行大量的计算。比如说，为所有的网页创建索引。在当时，整个互联网的数据也有数十TB。构建索引基本上等同于对整个数据做排序，而排序比较费时。如果用一台计算机对整个互联网数据进行排序，要花费很长很长时间。 所以，当时Google非常希望能将对大量数据的大量运算并行跑在几千台计算机上，这样才能快速完成计算。Google买了大量的计算机，并让它的聪明的工程师在这些计算机上编写分布式软件，这样工程师们可以将手头的问题分包到大量计算机上去完成，管理这些运算，并将数据取回。 如果你只雇佣熟练的分布式系统专家作为工程师，尽管可能会有些浪费，也是可以的。但是Google想雇用的是各方面有特长的人，不一定是想把所有时间都花在编写分布式软件上的工程师。所以Google需要一种框架，可以让它的工程师能够进行任意的数据分析，工程师只需要实现应用程序的核心，就能将应用程序运行在数千台计算机上，而不用考虑如何将运算工作分发到数千台计算机，如何组织这些计算机，如何移动数据，如何处理故障等等这些细节。 MapReduce的思想是，应用程序设计人员和分布式运算的使用者，只需要写简单的Map函数和Reduce函数，而不需要知道任何有关分布式的事情，MapReduce框架会处理剩下的事情。 MapReduce 的两个示例 MapReduce 架构","link":"/2024/03/29/MIT-6-824-Lecture-1/"},{"title":"CMU CSAPP Lecture 2 &amp; 3","text":"Byte = 8 bits：1 个字节有 8 个二进制位。 8 位二进制数字表示的范围不是很大，若完全用二进制表示数字的话，0 和 1 的个数将十分庞大。 引入十六进制（HEX）： to to 。 Shift Operations：","link":"/2024/03/10/CMU-CSAPP-Lecture-2-3/"},{"title":"MIT 18.06 - Lecture 10","text":"Four subspacesAny matrix determines four subspaces (possibly containing only the zero vector): Column space, consists of all combinations of the columns of and is a vector space in . The pivot columns form a basis for . dim \\ C(A) = r.Nullspace, consists of all solutions of the equation and lies in . The special solutions to correspond to free variables and form a basis for . An matrix has free variables: dim \\ N(A) = n - r.Row space, consists of all combinations of the rows of and is a vector space in .We equate this with , the column space of the transpose of . To get the basis of the row space, one obvious way is to perform row reduction on , but instead we make use of , the row reduced echelon form of . During the process, it leads to the difference of column space between and (after many row changes operations).Although the column spaces of and are different, the row space of is the same as the row space of (row changes don’t influence the row space). The rows of are combinations of the rows of . The first rows of are the ”echelon” basis for the row space of : dim \\ C(A ^ T) = r.Left nullspace, We call the nullspace of the left nullspace of A. This is a subspace of . The matrix has columns. We just saw that is the rank of , so the number of free columns of must be . dim \\ N(A ^ T) = m - r.The left nullspace is the collection of vectors for which Equivalently, ; here and are row vectors.","link":"/2024/03/09/MIT-18-06-Lecture-10/"},{"title":"MIT 18.06 - Lecture 9","text":"Linear independenceWe say vectors are linearly independent (or just independent)：if only when are all 0. Thinking of as a linear combination of the column vectors of A, we see that the column vectors of are independent exactly when the nullspace of contains only the zero vector.In other words, the only solution to is . If the columns of are independent then all columns are pivot columns, the rank of is , and there are no free variables.If the columns of are dependent then the rank of is less than and there are free variables. 包含零向量的向量组，他们之间必定线性相关。 Spanning a spaceVectors span a space when the space consists of all combinations of those vectors. For example, the column vectors of span the column space of . Basis and DimensionBasis：A basis for a vector space is a sequence of vectors with two properties: are independent. span the vector space. In general, vectors in form a basis if they are the column vectors of an invertible matrix. Dimension：Given a space, every basis for that space has the same number of vectors, that number is the dimension of the space.So there are exactly vectors in every basis for .","link":"/2024/03/09/MIT-18-06-Lecture-9/"},{"title":"姚期智 - 亿万富翁问题","text":"Solution Mathematical Model该过程是一个非对称加密。Alice 有公钥，有私钥，资产 亿元；Bob 有公钥，无私钥，资产 亿元。 1. Bob 操作 选取一个大数字 ，，。 令 ，将 作为密文传输给 Alice。 2. Alice 操作 计算 ，即 。 解密：令 ，不难发现 。 求模：令 ，其中 是一个较大的质数。 保持 不变， 加 1。并将 重传给 Bob。 3. Bob 检验若 ，则证明 ；若 ，则证明 。","link":"/2024/03/05/%E5%A7%9A%E6%9C%9F%E6%99%BA-%E7%99%BE%E4%B8%87%E5%AF%8C%E7%BF%81%E9%97%AE%E9%A2%98/"},{"title":"MIT 18.06 - Lecture 7 &amp; 8","text":"Solving Ax = 0 对 进行消元。在消元的过程中，可能会遇见该列没有主元的情况，继续寻找下一个主元即可。在消元的过程中，可能会遇见某一行被消为 0 的情况：这说明在 中这一行是其他行的线性组合。 有主元的列（pivot columns），没主元的列（free columns）对应的方程组中的变量 可以取任意值，也称他们为自由变量。通过自由变量的取值，可以确定主元的取值。 矩阵中主元的个数 也被称作该矩阵的秩（rank），自由变量的个数 。一般每个自由变量轮流取值为 ，其余全都取 。由此可以得到 个特解。这 个特解的线性组合就是 对应的零空间。 通过消元，使得 变成 ；再将所有 pivots 的值都变成 1，且 pivots 之上和之下都变成 0，实现从 变成 的过程。 最终的 被称作简化行阶梯形式（reduced row echelon form）的矩阵。 由于 对应的零空间是 中列向量的线性组合，所以可以将 的列进行交换。转化成上图中 的形式后，可以借助矩阵乘法，引入一个零空间矩阵 使得 ，不难得出 的样子。 中的每一列就是自由变量不同取值所得到的特解， 中列向量线性组合的结果就是 所对应的零空间。用这种方法可以很快的得到 的解。 Solving Ax = b“If there is a solution to , then must be a linear combination of the columns of . The system of linear equations is solvable exactly when is a vector in the column space of A.” 满足条件 的所有解：特解 + 零向量空间中的所有向量。 特解：让所有的自由变量取值为 0。 Augmented matrix：增广矩阵 由于 ，故通过这种方式可以得到所有满足条件的解。 上图中的 中，第二项前少加了 。 矩阵的秩与线性方程组的解的关系对于一个 的矩阵 ，其秩为 。 行满秩（Full row rank, r = m）最简矩阵形式：没有全是 的行，故对 无要求（因为消元后不会出现 的线性组合 的情况），即 对任何 始终有解，且有无穷多解。自由变量的个数 （零空间的维度是 ）。 列满秩（Full Column rank, r = n）最简矩阵形式： 在这种情况下，零向量空间只包含零向量，也代表着列向量们是线性无关的。 自由变量的个数 （自由变量的个数相当于是零空间的维度），即若 有解，则必定是唯一解。即在列满秩的情况下， 的解的个数是 0 或 1。 行列同时满秩（Full row and column rank, r = m = n）最简矩阵形式：代表着 是一个可逆方阵。The nullspace has dimension zero, and has a unique solution for every in .","link":"/2024/03/01/MIT-18-06-Lecture-7-&-8/"},{"title":"MIT 18.06 - Lecture 5 &amp; 6","text":"置换矩阵（permutation） P ^ {-1} = P ^ T \\\\ P P ^ {-1} = I转置（transposes） (A ^ T)_{ij} = A_{ji}对称矩阵（symmetric martix）满足 的矩阵，称为对称矩阵。构造对称矩阵的通用方法：（所有矩阵，不是方阵也可以）， 一定是一个对称矩阵。（）。 向量空间（vector spaces）If a collection of vectors is closed under linear combinations (i.e. under addition and multiplication by any real numbers), and if multiplication and addition behave in a reasonable way , then we call that collection a vector space. 向量子空间（vector subspaces）A vector space that is contained inside of another vector space is called a subspace of that space. The union of those two subspaces is not a subspace, the intersection of those two subspaces is a subspace. 向量列空间（column spaces） If there is a solution to , then must be a linear combination of the columns of . The system of linear equations is solvable exactly when is a vector in the column space of A. 向量零空间（nullspace） 使得 的 组成了矩阵 的向量零空间（为什么是空间的证明很简单，在上面已给出）。但使得 的 构不成一个空间，因为不包含零向量。","link":"/2024/02/28/MIT-18-06-Lecture-5-&-6/"},{"title":"UCB - CS161 - Lecture 5","text":"1. Kerckhoff’s PrincipleCryptosystems should remain secure even when the attacker knows all internal details of the system.The key should be the only thing that must be kept secret, and the system should be designed to make it easy to change keys that are leaked (or suspected to be leaked).If your secrets are leaked, it is usually a lot easier to change the key than to replace every instance of the running software. 加解密算法是公开的，加解密密钥是保密的： 维护密钥的保密性更容易。 若密钥暴露，换密钥即可。 面对多对加密通信的需求，使用相同的加密算法和不同的密钥即可。相比于使用不同的加密算法，设计成本和复杂程度及各方面代价都大大降低。 开放密码学设计的优势： 可以使该算法承受公开的钻研和分析，因此可以变得更加强壮。 公开后有更大的可能被正义黑客发现，比被敌人发现要好。 公开设计使标准更容易建立。 系统的安全取决于算法的保密性，对代码的逆向抵抗力很差。密钥不是代码的一部分，不存在这个问题。 2. Symmetric-Key Encryption 密文的长度无需成为加密的信息（从反面的角度来论证这种做法的优势）。 对称加密的大体模式： 安全性的考量： partial information leak（通过加密程序返回的密文试探有关信息） deterministic encryptions（相同明文的密文一旦相同，被破解后能大大加快破解全部密文的速度） 2.1 IND-CPA SecurityIND-CPA：Indistinguishability under Chosen-plaintext Attack（选择明文攻击下的不可区分性）。 2.2 One-Time Pad虽安全性极高，但只能用于一次性加密解密，不符合 IND-CPA。 Both the size of key and message is ，（randomly chosen）, ，。 2.3 Block CiphersIntuitively, a block cipher transforms a fixed-length, -bit input into a fixed-length -bit output. The block cipher has different settings for scrambling, so it also takes in a -bit key as input to determine which scrambling setting should be used. Encryption function ：，This notation means we are mapping a -bit input (the key) and an -bit input (the plaintext message) to an -bit output (the ciphertext). Once we fix the key , we get a function mapping bits to bits：. The inverse mapping of this permutation is the decryption algorithm ：. 2.3.1 ECB Mode 2.3.2 CBC Mode 2.3.3 CFB Mode","link":"/2024/02/27/UCB-CS161-Lecture-5/"},{"title":"MIT 18.06 - Lecture 4","text":"A = LU 分解 矩阵是一个下三角矩阵， 矩阵是一个上三角矩阵。这种表示方式相对于 而言更加合适。 \\quad高斯消元的时间复杂度是 级别的，编程难度不算很大。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;const int N = 150;const double eps = 1e-7;using namespace std;int n;double ans[N], a[N][N];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n + 1; j++) cin &gt;&gt; a[i][j]; } for (int i = 1; i &lt;= n; i++) { int pos = i; for (int k = i + 1; k &lt;= n; k++) { if (fabs(a[i][i]) &lt; fabs(a[k][i])) pos = k; } if (fabs(a[pos][i]) &lt; eps) { cout &lt;&lt; \"No Solution\" &lt;&lt; endl; return 0; } if (pos != i) swap(a[i], a[pos]); double div = a[i][i]; for (int j = i; j &lt;= n + 1; j++) a[i][j] /= div; for (int k = i + 1; k &lt;= n; k++) { div = a[k][i]; for (int l = i; l &lt;= n + 1; l++) a[k][l] -= div * a[i][l]; } } ans[n] = a[n][n + 1]; for (int i = n - 1; i &gt;= 1; i--) { ans[i] = a[i][n + 1]; for (int j = i + 1; j &lt;= n; j++) ans[i] -= ans[j] * a[i][j]; } for (int i = 1; i &lt;= n; i++) cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ans[i] &lt;&lt; endl; return 0;} 对于消元过程中碰到 pivot 为 0 的情况，需要进行行交换。行交换等价于在原矩阵的左边乘一个置换矩阵（permutation matrix）。因此， 分解写成 的形式将更完整。 置换矩阵 的一个重要性质： 。","link":"/2024/02/26/MIT-18-06-Lecture-4/"},{"title":"MIT 18.06 - Lecture 3","text":"多角度理解矩阵乘法（Matrix Multiplication）Assume matrix is the result of matrix times matrix , in other words . 行乘列 equals the dot product of row of matrix and column of matrix . In other words： c_{ij} = \\sum_{k = 1} ^ {n} a_{ik} \\cdot b_{kj} It can be directly calculated in . 行变换（A 是变换矩阵） The rows of are combinations of rows of . 列变换（B 是变换矩阵） The columns of are combinations of columns of . 列乘行 The product of an vector with a vector is a matrix. \\left[\\begin{array}{c} 2 \\\\ 3 \\\\ 4 \\end{array}\\right] \\left[\\begin{array}{c} 1 \\quad 6 \\end{array}\\right] = \\left[\\begin{array}{c} 2 \\quad 12 \\\\ 3 \\quad 18 \\\\ 4 \\quad 24 \\end{array}\\right] The columns of this matrix are multiples of the column of . The rows of this matrix are multiples of the row of . 分块矩阵的乘法 \\left[\\begin{array}{c} A_1 & A_2 \\\\ A_3 & A_4 \\end{array}\\right] \\left[\\begin{array}{c} B_1 & B_2 \\\\ B_3 & B_4 \\end{array}\\right] = \\left[\\begin{array}{c} C_1 & C_2 \\\\ C_3 & C_4 \\end{array}\\right] , and are matrixs, are blocks of a bigger matrix and are blocks with the same cutting methods like . What amazing is that it still fits the rules of matrix multiplication！ In other words, 矩阵的逆（Inverses）如何理解矩阵的逆？For understand the inverse matrix easily, we need to use the Elimination Matrix which we have metioned in the lecture 2. Assume a elimination matrix , the second row of means subtracting times row from row . To “undo” this operation we must add times row to row using the inverse matrix: E_{21} ^ {-1} = \\left[\\begin{array}{c} 1 & 0 & 0 \\\\ 3 & 1 & 0 \\\\ 0 & 0 & 1 \\end{array}\\right]It is obviously that . 可逆矩阵/非奇异矩阵的定义If is a square matrix, the most important question you can ask about it is whether it has an inverse . If it does, then and we say that is invertible or nonsingular. For a singular matrix , which means doesn’t have its corresponding inverse matrix , it can be proved that we can always find some non-zero vector which . This conclusion can be proved by using reduction to absurdity. Assume has its inverse matrix , then is equivalent to , which means . But the precondition is that is an non-zero vector. Thus contradiction occurs so that singular matrices don’t have their inverse matrices. 求逆矩阵的方法 — Gauss-Jordan EliminationWe combine the method of Guass Elimination with block matrices to get the Gauss-Jordan Elimination. The main idea is: E[ \\ A \\ | \\ I \\ ] = [ \\ I \\ | \\ E \\ ] is the product of all of the elimination matrices during the process of transforming to using Guass Elimination.The correctness of this method is obviously due to . According to the defination of inverse martix, .","link":"/2024/02/17/MIT-18-06-Lecture-3/"},{"title":"MIT 18.06 - Lecture 1 &amp; 2","text":"线性方程组的几何化e.g. 2x - y = 0 \\\\ -x + 2y = 3 行视角（Row Picture）:解集是直线们的交点 或 平面们的交线等。 列视角（Column Picture）:找到已知向量组的线性组合，来表达出目的向量。 矩阵视角（Matrix Picture）:写成 的形式，其中 是系数矩阵， 是未知数向量， 是结果向量。 线性（不）相关给定矩阵 ，若对于任意一个向量 ，都能找到一个向量 满足 ，则说明 中的列向量们的线性组合”可以触碰到所处空间的任何一个角落”（二维平面、三维空间……），称 中的列向量们是线性不相关的（linearly independent）。 若不能，则称 为奇异矩阵（singular matrix），在这个奇异矩阵中的列向量们是线性相关的（linearly dependent），因此他们的线性组合总是汇集在一个点/一条线/一个平面/…上，因此无法触碰到所处空间的任何一个角落。 高斯消元法 (Guass Elimination)求解线性方程组的解时，若采用矩阵视角，可以写成 。 e.g. 然后通过消元，求解出未知数向量 即可（保证 可逆），步骤如下： 找到该行的 pivot ，将下面每行该位置的数变成 0（We recopy the first row, then multiply the numbers in it by an appropriate value and subtract those values from the numbers in the second row.）。 若该行的 pivot 为 0 ，可以通过把后续行与该行进行交换，来继续消元。 直到 变成一个上三角矩阵 （upper triangular matrix），停止消元。 通过上述步骤，我们把 变成了 的形式，接着通过回代法（back substitution）便可以得到原方程的解。 \\quad刚才 变成 的过程，可以用矩阵乘法来描述。每次消元的步骤 1，都可以表示成在当前矩阵的左侧乘上了一个消元矩阵（下图左侧的消元矩阵叫做 ，因为我们正在想办法将矩阵中第 2 行第 1 列的数字消去）。 所以上述例子的 到 的过程，可以描述为 ，也可以写成: (E_{32}E_{31}E_{21})A = U \\\\ EA = U, \\ E = E_{32}E_{31}E_{21} \\quad还可以发现一些有趣的性质： 若想对 进行行变换，则在 左边乘上对应的行变换矩阵。 \\left[\\begin{array}{c} 0 & 1 \\\\ 1 & 0 \\end{array}\\right] \\left[\\begin{array}{c} a & b \\\\ c & d \\end{array}\\right] = \\left[\\begin{array}{c} c & d \\\\ a & b \\end{array}\\right] 若想对 进行列变换，则在 右边乘上对应的列变换矩阵。 \\left[\\begin{array}{c} a & b \\\\ c & d \\end{array}\\right] \\left[\\begin{array}{c} 0 & 1 \\\\ 1 & 0 \\end{array}\\right] = \\left[\\begin{array}{c} b & a \\\\ d & c \\end{array}\\right] 是矩阵乘法中行变换、列变换的基础。","link":"/2024/02/17/MIT-18-06-Lecture-1-&-2/"},{"title":"「期末复习」- 计算机安全导论 - chap6","text":"1. 域名系统 DNS1.1 DNS域名系统（DNS）是一个基本的应用层协议，负责将域名映射到 IP 地址。 2. 防火墙防火墙是一种集成的安全措施集合，旨在防止对网络计算机系统未经授权的访问。 2.1 防火墙策略为了保护专用网络和个人计算机的安全，需要部署防火墙过滤流入或流出的流量，基于的预定义规则集称为防火墙策略。 流经防火墙的数据包会有以下三种结果： 接受：允许通过防火墙； 丢弃：不允许通过防火墙，且无失败指示； 拒绝：不允许通过防火墙，并试着告诉发送方，数据包已被拒绝。 防火墙处理数据包的策略是基于被检查数据包的一些特性，包括所使用的协议： TCP 或 UDP； 源 IP 地址或目的 IP 地址； 数据包应用程序级的有效载荷（如是否包含病毒）； 创建防火墙策略的两种基本方法（规则集）：黑名单和白名单。为了有效地使对外部世界的脆弱性最小化，同时保持受信任内部网（或个人计算机）中计算机所需要的功能，有两种基本方法来创建防火墙策略（或规则集）。 黑名单方法：除了那些符合黑名单所定义的具体规则的数据包之外，其他所有的数据包都允许通过防火墙；这种类型的配置更具灵活性，能确保内部网的服务不被防火墙中断，但从安全角度分析，这种方法已经假定网络管理员能列举出所有恶意流量的本质特性。 白名单方法：一种更安全的定义防火墙规则集的方法是默认拒绝策略，除非防火墙接受数据包，否则数据包会被丢弃或拒绝。 2.2 防火墙类型 数据包过滤器（无状态防火墙） 如果数据包与数据包过滤器的规则集匹配，则数据包过滤器将丢弃或接受它； 状态过滤器（状态防火墙）维护通过它的所有连接的记录，并可以确定数据包是新连接的开始、现有连接的一部分还是无效数据包； 应用层防火墙它就像一个代理，可以“理解”某些应用程序和协议；它可能会检查流量的内容，当其被视视为不当内容（即网站，病毒，漏洞……）时阻止该流量； 2.2.1 无状态防火墙无状态防火墙将每个尝试通过它的数据包视为独立，而不考虑先前已经处理过的数据包（不存储先前的状态）。 无状态防火墙可能必须具有严格的限制性，以防止大多数攻击。 2.2.2 状态防火墙状态防火墙可以区分数据包是否是受信任网络内发起的合法会话的一部分。 状态防火墙维护一些表，表中包含每个活动连接的信息，包括 IP 地址、端口和数据包的序列号。 使用这些表，状态防火墙可以只允许响应内部网发起连接的 TCP 数据包流入。 3. 隧道通常 TCP 数据包的内容是不加密的，因此如果有人窃听 TCP 连接，他会知道该会话中有效载荷的所有内容。使用隧道协议无需改变软件的执行，就能防止这种窃听。在隧道协议中，客户端和服务器之间的通信是自动加密的，窃听是不可行的。 3.1 安全的Shell（SSH）一次安全的交互式命令会话：客户端通过一个TCP会话连接到服务器；客户端与服务器交换管理细节的信息，如支持的加密方法、各自协议的版本，每一方都要选择另一方支持的一组协议；客户端和服务器进行密钥交换，创建共享的秘密会话密钥，用会话密钥加密双方的通信（但不用于身份验证）。这个会话密钥配合选择的块加密（通常是AES、3DES、Blowfish或IDEA）来加密所有后续的通信；服务器向客户端发送可以接受身份验证列表，客户端将按顺序尝试。最常见的机制是使用密码或以下的公共密钥身份验证方法：如果选定的机制是公共密钥身份验证，则客户端向服务器发送自己的公钥；然后服务器检查是否这密钥已存储在其授权的密钥列表之中。如果在，服务器使用客户的公钥加密挑战，并将其发送给客户端；客户用自己的私钥解密挑战，并向服务器发回响应，证明自己的身份；一旦身份验证已顺利完成，服务器允许客户端访问相应的资源，如命令提示符；","link":"/2024/01/07/%E3%80%8C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E3%80%8D-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA-chap6/"},{"title":"「期末复习」- 计算机安全导论 - chap7","text":"1. 万维网万维网主要包括：超文本标记语言HTML（Hyper Text Markup Language）超文本传输协议HTTP（Hypertext Transfer Protocol ） 1.1 HTMLHTML：创建网页的标准标记语言，用于描述网页的内容和格式，运行在浏览器上，由浏览器来解析。HTML特点：是一种静态文档描述语言，支持链接到其他页面或者嵌入图像，通过表单（Forms）将用户输入发送到服务器。 扩展：通过插件支持的其他媒体内容（如PDF、视频）通过嵌入所支持的程序（如Javascript，Java），提供与用户交互的动态内容；修改浏览器用户界面；访问客户端计算机环境等。 1.2 HTTPHTTP：用于检索请求的 Web 页；先检索本地 DNS，如果没有找到则查询 DNS 服务器；解析 IP 地址之后，建立 TCP 连接 HTTP 请求和响应通过 TCP 的端口 80 传输但默认端口 80 有许多安全和隐私问题标准HTTP协议不提供任何方式的数据加密，以明文发送内容。 1.3 HTTPS安全套接字层超文本传输协议（HTTPS）：与 HTTP 语法相同，但使用了安全套接字层SSL或传输层安全TLS。 2. 网络钓鱼网络钓鱼（Phishing）伪造网页以欺诈方式获取敏感资料，用户一般是从垃圾邮件中访问网络钓鱼页面。 2.1 网络钓鱼的预防 不能在网络或者其他途径暴露自己的身份资料，如手机号码、身份证号、银行卡号或者金融账号等。 如果涉及到金钱交易、商业合同、工作安排等重大事项，一定要多加小心。 不要轻易相信通过电子邮件、网络论坛等发布的中奖信息、促销信息等，正规公司一般不会通过电子邮件给用户发送中奖信息和促销信息。 不要打开陌生人的电子邮件，更不要轻信他人说教，特别是即时通讯工具上的传来的消息，很有可能是病毒发出的。 3. 可移动代码定义：可执行、通过网络发送、在目标电脑上执行的代码程序。 4. Cookies定义：是存储在计算机上、与特定服务器关联的一小部分信息。 当您访问特定网站时，它可能会将信息存储为 Cookie。每次您重新访问该服务器时，Cookie 都会被重新发送到服务器。用于在会话中保存状态信息。Cookie可以保存任何类型的信息。可以保存敏感信息：包括密码，信用卡信息，社保号码等等。 分类： 会话型cookie：是浏览器的处理过程中保留的，是暂时性的，当浏览器关闭时则消除。 持久性cookie：而持久性的是保存在客户端的硬盘上的，浏览器关闭也不会消除。 许多网站要求你启用Cookie才能访问站点：它们存在你的计算机上，自然利于使用（思考ActiveX如何利用cookie ……）你可以(而且应该)定期清理你的cookie。大多数浏览器可以选择关闭cookie；将某些站点排除在添加cookie之外；并且只接受某些站点的cookie。","link":"/2024/01/07/%E3%80%8C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E3%80%8D-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA-chap7/"},{"title":"「期末复习」- 计算机安全导论 - chap8","text":"1. 加密 2. 攻击 3. 替换密码和频率分析替换密码：每个字母用不同的独一无二的其他字符取代，存在 个可能的替换密码。 替换密码的弱点在于：它们不隐藏明文中不同字母的基本频率。因为自然语言中字母（例如英语）是不均匀分布的，所以对于字母频率的分析是针对替换密码的有效攻击手段。 4. 一次一密一次一密是一种牢不可破的替换密码，由于每次都是完全随机地选择移动量，在密文中字母表的每个字母出现的概率几乎相同。 弱点：密钥块的长度 必须和明文的长度 相同，密钥不可以被重用。 5. 分组密码 5.1 AES 加密AES：交替的使用替换和置换加密。 5.2 分组密码的操作模式使用分组密码有几种方法，如 AES 是使用固定长度的分组进行操作。加密算法所使用的不同方法被称为操作模式。 ECB模式：适合于数据较少的情况 CBC模式： 6. 流密码 9. RSA 算法 10. 生日攻击 11. 消息认证码","link":"/2024/01/07/%E3%80%8C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E3%80%8D-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA-chap8/"},{"title":"「期末复习」- 微机原理与系统设计 - chap4","text":"总线：计算机组件间、计算机间、计算机与设备间连接的信号线和通信的公共通路。 1. 总线竞争同一总线上，同一时刻，有两个或两个以上的器件输出其状态。此时总线上会是一种不高不低的非TTL电平，严重时会烧坏器件。特例：集电极开路/漏极开路输出，此时不会烧坏器件。 如何避免总线竞争：与三态门相连后再接到总线上。三态门：高电平、低电平、高阻。 2. 总线负载直流负载：如果驱动门输出高电平时，没有能力提供负载需要吸收的电流，会导致高电平电压高不上去。如果驱动门输出低电平时。吸收电流的能力不够，会导致低电平电压低不下来。 取 min。 3. 总线驱动设计如果连接到总线上的模块很多，也就是总线的负载很重，就需要加驱动器。对于单向的总线控制信号，比如地址、读写控制信号，情况相对简单。双向数据总线如果要加驱动，稍有不慎就会引起总线竞争。 74LS244 可以当驱动器（或者说缓冲器）来用，它主要用来实现单向的总线信号驱动。 双向数据总线驱动器可以选择 74LS245 芯片实现，通过控制允许信号和方向控制信号来避免总线竞争。 e.g.1. 某内存板，板内地址为 A0000H～FFFFFH，试画出板内双向数据总线驱动与控制电路 。 防止总线竞争原则：只有当 CPU 读本电路板内的内存地址时，才允许双向驱动器指向系统总线的三态门是导通的。 对板内内存地址进行分析，找出地址特征。发现只需让 参与译码。 设计译码电路，用来控制双向数据总线驱动器，使之满足防止总线竞争原则 与非门输入的都得为1，输出才为0！。 接 ：内存读时为低电平， 表示从 到 ，即从右侧的电路内存板向左侧输信息（读内存）。 e.g.2接口板板内接口地址为 5000H～7FFFH，试画出板内双向数据总线驱动与控制电路。 防止总线竞争原则：只有当 CPU 读本电路板内的内存地址时，才允许双向驱动器指向系统总线的三态门是导通的。注意：设计接口地址译码电路时，需要增加一个 AEN ＝ 0 的条件。相比于例1：内存读、内存写信号 接口读、接口写信号。（AEN = 0：CPU，AEN = 1：DMA，DMA 直接和内存进行数据传送，此时不能让其他接口误以为是要读自己的数据）。 地址分析： 根据地址特征，画控制电路（利用 3-8 译码器译码）。 要考虑 的原因： 的时候， 的取值只有 一种，即 的地址是不合法的。故 也要参与译码。 e.g.3（1）某微型机电路板上有内存 C0000H～EFFFFH 和接口 A000H～BFFFH，试画出该电路板板内双向数据总线驱动与控制电路。 防止总线竞争原则：只有当CPU读板内内存或读板内接口时，才允许双向数据驱动器指向系统总线的三态门是导通的。 地址分析（内存、接口）： 画驱动与控制电路： （2）","link":"/2024/01/06/%E3%80%8C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E3%80%8D-%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-chap4/"},{"title":"「期末复习」- 计算机安全导论 - chap5","text":"网络如何影响计算机安全目标 C.I.A. 机密性：网络协议的任何分层中，都没有要求传输数据的机密性。需要修订相关协议来完成机密性。可以在应用层进行加密协议的设计，也可以在网络层。 完整性：封装的数据包中的头和尾部都有简单的校验和，以检查传输数据是否有改变。但这些校验和不是密码学意义下安全的，因此不能提供计算机安全层面的完整性。 可用性：网络协议设计之初主要考虑的是节点发生故障时如何保证可用性，并未考虑攻击者存在时的情形。如拒绝服务攻击会影响系统可用性。 网络如何影响计算机安全目标 A.A.A. 保证：默认情况下网络中数据包可以在任何两个节点间传输。如果需要引入权限和策略来控制网络中的数据流，必须通过显式得的措施来实现。 真实性：网络协议的数据格式中没有存储数字签名的字段，也没有用户身份的概念。如果需要引入身份证明和数字签名，必须在应用层完成。 匿名：网络协议没有用户身份的概念，因此具有内在的匿名性。对于匿名攻击，可以通过确定用户正在使用网络中的哪台计算机来确定。 1. 以太网基本概念：以太网包括通信所使用的物理介质以及链路层的协议标准 IEEE 802.3，是现有局域网采用的最通用的技术标准。不同帧在以太网电缆上同时传输时会产生冲突，需要丢弃并重传冲突帧。 冲突处理：以太网协议使用 CSMA/CD（载波监听多路访问及冲突检测）技术来避免冲突。 集线器：工作与物理层，将所有帧广播给与之相连的所有设备。缺点是与集线器相连的所有设备共享带宽，传输效率低下。且由于是广播，所以数据容易被窃听。 交换机：设备首次使用时，与集线器类似。但随着时间的推移，交换机会记录连接到自己各个接口的计算机地址。之后交换机会将接收到的帧发送到特定的接收端，而不是广播出去。 2. MAC 地址用来表示互联网上每一个站点的标识符，采用十六进制数表示，共六个字节。其中，前三个字节是由IEEE的注册管理机构RA负责给不同厂家分配的代码(高位24位），后三个字节(低位24位)由各厂家自行指派给生产的适配器接口，称为扩展标识符（唯一性）。 一个地址块可以生成 个不同的地址。因此，在相同网络中两个设备具有相同 MAC 地址的概率只有百万分之一。MAC地址是网卡决定的，一般是固定的。但可以通过网卡的驱动程序软件来修改 MAC 地址。如Linux下可以通过 ifconfig 来修改。从安全角度考虑，不能使用MAC地址作为识别网络流源头的依据。 3. ARP 欺骗3.1 ARP 简介ARP（Address resolution protocol）：地址解析协议，是一种链路层协议，其主要功能是将给定主机的网络层地址解析为主机的硬件地址。 主机发送信息时，将包含目标 IP 地址的 ARP 请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址。收到返回消息后，将该 IP 地址和物理地址存入本机 ARP 缓存中，并保留一定时间，下次请求时直接查询 ARP 缓存以节约资源。 3.2 ARP 欺骗攻击ARP 建立在网络中各个主机互相信任的基础上。攻击者可以向某一主机发送伪 ARP 应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个 ARP 欺骗。 ARP 协议简单高效，但缺乏身份认证，容易受中间人攻击。 例：攻击者 C 向 A 发送一个 ARP 响应，将 B 的 IP 地址与 C（自己）的 MAC 地址关联；同时 C 还向 B 发送一个 ARP 响应，将 A 的 IP 地址与 C（自己）的 MAC 地址关联。这会导致：最终所有 A 和 B 之间的通信都将经过 C。 3.3 ARP 欺骗预防 检查相同 MAC 地址是否在局域网中多次出现，将其作为是否存在 ARP 欺骗的标志。 静态ARP表：网络管理员手动指定路由器的 ARP 缓存来将具体的 MAC 地址和特定的 IP 地址进行绑定。由于新设备加入网络时，需要手动添加，所以该方法不够灵活。 更加复杂和灵活的措施：anti-arpsroof、XArp、Arpwatch，这些程序会仔细检查所有的 ARP 数据包，并将数据包的内容与所存储的 ARP 表项纪录做比较，以检测并防止 ARP 欺骗。 4. 网际协议（IP）IP：网络层协议，尽最大努力将一个数据包从源节点路由到目的节点。节点由 IP 地址标识，IPv4 地址为 32 位，IPv6 地址为 128 位。 IP 包路由：如果数据包的目的地址与发送数据包的主机在同一个局域网内，则使用 ARP 协议确定目的地址的 MAC 地址，并发送包；否则，数据包被传送至局域网的网关，网关根据路由表来确定如何转发数据包。 路由器：为数据包寻找一条最佳的传输路径，并将该数据有效地传送到目的站点。选择最佳路径的策略即路由算法。为了便于选择，在路由器中保存着传输路径的相关数据（路由表）供路由选择时使用，表中包含的信息决定了数据转发的策略。 TTL(time-to-live)：每个数据包在路由过程中的生存周期，用跳数来决定，一般最大跳数为 255。 路由器操作：对每个数据包执行丢弃、发送或转发三个操作。 路由协议：OSPF（Open shortest path first）决定如何在自治系统中路由数据包，其策略是数据包应沿最短路径传输。BGP（Border gateway protocol）决定如何在自治系统间路由数据包。 IP 地址与子网掩码：例如 IP 地址为 192.168.1.100，子网掩码为 255.255.255.0，则该地址的网络部分为 192.168.1.0，主机部分为 0.0.0.100。 IPv4 地址已经快耗尽的解决方案： IPv6 网络地址转换（Network address translation, NAT)大部分电脑都配置有 NAT 服务，该服务允许设备在本地使用自定义的私人 IP 地址。当要与互联网通信时，NAT 会将私人 IP 转译为其在互联网上的真实 IP。 IP 数据包： 5. 网际控制消息协议（ICMP）ICMP 协议：用于在主机、路由器之间传递控制消息。控制消息：网络通不通、主机是否可达、路由是否可用等网络本身的消息。 ICMP 消息类型： 回显请求（echo request） 回显响应（echo response） 超时（time exceeded） 目的地不可达（destination unreachable） 使用 ICMP 消息的常用网络管理工具：ping 命令和 traceroute 命令. Ping (Packet Internet Groper)，因特网包探索器，用于测试网络是否通畅或者网络连接速度的程序。Ping 发送一个 ICMP 回声请求消息给目的地，并报告是否收到 ICMP 回声应答消息。 Traceroute，利用 ICMP 协议定位计算机和目标计算机之间的所有路由器。 6. IP 地址欺骗（IP Spoofing）6.1 IP 地址欺骗原理IP 地址欺骗：恶意用户产生的 IP 数据包中的源 IP 地址是伪造的，以便冒充其他系统或发件人的身份。源 IP 地址修改后，IP 数据包头部校验和也需重新计算。 如果攻击者用假冒的源 IP 地址，那么他不会收到服务器的响应，服务器会把数据包返回给具有假冒 IP 地址的主机。攻击者采用 IP 地址欺骗时，表明他不在乎是否能收到响应，或者他有接收到响应的其他方法。如拒绝服务攻击。 IP 地址欺骗可以用在规避防火墙策略(6.2节)或者进行TCP会话劫持(5.4节)中。 6.2 IP 地址欺骗应对措施 边缘路由器配置边缘路由器在配置时，可以阻止源地址在域内，但实际地址是域之外的数据包。边缘路由器也可以阻止源地址是域外的，但是从域内往域外发送的数据包。 IP 追踪技术这一技术可以追踪数据包返回到实际源地址的路径。根据追踪到的信息，可以向各种自治系统发送请求，要求自治系统阻止来自该路径的数据包，直到确定恶意软件或恶意用户被清除为止。 7. 数据包嗅探（Packet Sniffing）7.1 WiresharkWireshark（前称Ethereal）是一个网络数据包分析软件。其功能是撷取网络封包，并尽可能显示出最为详细的网络数据包资料。Wireshark 使用 WinPCAP 作为接口，直接与网卡进行数据报文交换。使用时网卡被设置为混杂模式（Promiscuous Mode）。 混杂模式： 一般情况下，当电脑通过网卡 NIC 接收到数据包时，会检测目的地址是否与自己的 MAC 地址相同来判断“这个数据包是不是发给我的”。如果不同则大多数情况下会选择丢弃该数据包。 OS 提供了一种特殊模式来支持数据包嗅探（即使不是发给自己的也不选择丢弃，这样才可以“偷”到别人的数据包），该模式叫做混杂模式（Promiscuous Mode）。在混杂模式下，一台机器的网卡能够接收所有经过它的数据流，而不论其目的地址是否是它。 网络管理员使用 Wireshark 来检测网络问题，网络安全工程师使用 Wireshark 来检查资讯安全相关问题。开发者使用 Wireshark 来为新的通讯协定除错，普通使用者使用 Wireshark 来学习网络协定的相关知识。当然，有的人也会居心叵测的用它来寻找一些敏感信息。 7.2 防止数据包嗅探 使用以太网交换机而不是集线器，降低数据包被嗅探的可能性。但对于无线网络，该方法无能为力。 检测网卡是否被设置为混杂模式。可能的检测方式：(1) 当处于混杂模式时，计算机系统处理所有数据包会比较慢。(2) 对无效数据包的响应，有可能表明网卡处于混杂模式。例如向一台被怀疑的主机发送数据包，其 IP 地址与 MAC 地址不匹配，网卡会丢弃数据包。但如果网卡运行在混杂模式，有可能会发送一个响应。 高层协议使用加密防止敏感信息泄露，如 HTTPS 协议。 8. 传输层端口：16 比特的端口号，用来标识应用层不同服务。例如，FTP 使用 21 端口号，Telnet 使用 23 端口号，SMTP 使用 25 端口号，HTTP 使用 80 端口号， HTTPS 使用 443 端口号。 TCP：面向连接的、可靠的。面向连接意味着实现会比较复杂，可靠的是指信息会完整、有序地到达。如果数据包丢失，TCP会保证重传。 TCP是传输文件、网页和电子邮件的首选协议。 UDP：无连接的、不可靠但速度快。基于IP的语音会话(VoIP)适合于使用UDP协议。 8.1 TCP 协议基于 IP 协议，使用三次握手协议初始化，每个数据包都有编号。 累积确认：发送方向接收方发送指定的数据包后，接收方向发送方发送确认收到这些数据包。 流量控制：用来防止在数据传送过程中“发送方发送速度过快，接收方来不及接受从而导致数据包意外丢失”的情况。流量控制主要使用滑动窗口协议。 拥塞控制：用来防止“过多的数据注入到网络，导致网络中的路由器或链路过载”的情况。 校验和：使用循环冗余校验（CRC） 来确保传送数据的正确性，检测由网络错误引发的数据不一致性，但不能检测恶意篡改。 8.2 UDP 协议无需三次握手建立连接，允许直接发送数据报。UDP是不可靠连接，不保证数据包的有序到达。它假定检查数据报序列中丢失数据报的工作由应用程序完成。使用16 位的校验和来验证每个数据包的完整性。UDP 的数据传输速度要远远快于 TCP。它常用于对时间敏感的应用程序，其更加注重传输速度而不是完整性，如 DNS 和 VoIP。 9. TCP会话劫持TCP 序列预测攻击企图猜测 TCP 会话时的初始序列号，以建立伪造的 TCP 会话。 一个可能的攻击方案如下： 攻击者针对受害客户端发动拒绝服务攻击，防止客户端干扰自己的攻击； 攻击者向服务器发送一个 SYN 包，将源 IP 地址伪造成受害客户端的 IP 地址； 在等待服务器向客户端发送响应之后，攻击者通过发送一个 ACK 数据包来结束 TCP 握手，该数据包的序列号是预测的下一个序列号； 攻击者以受害客户端名义向服务器发送请求。 9.1 盲注入TCP 序列号预测攻击中使用了 IP 欺骗，攻击者将无法从服务器收到任何响应。盲注入允许攻击者使用请求者的源 IP 地址来执行某些命令，从而破坏系统。盲注入一般会注入包含命令的数据包，从而建立将响应返回给攻击者的连接。 9.2 ACK 风暴盲注入后客户端不会向服务器发送同步消息，导致不同步现象。此时，客户端和服务器会向对方发送 ACK 消息，每一方都想告诉对方需要开始使用正确的序列号。这种反复的通信被称为 ACK 风暴。 9.3 完全会话劫持当攻击者与目标服务器或客户端在同一网段时，攻击者可以完全劫持已有的 TCP 会话。使用数据包嗅探攻击，攻击者可以知道建立会话时数据包的序列号。 完全会话劫持与 ARP 欺骗结合的中间人攻击：攻击者首先使用 ARP 欺骗，将会话双方的通讯流暗中改变，这种改变对会话双方来说是透明。其次，攻击者利用完全会话劫持来截获会话双方的所有消息。 9.4 针对会话劫持的安全措施在 IP 层或者应用层使用认证和加密，如 IPSec 或者应用层安全协议。网站应避免创建以安全身份验证措施开始，但后来切换到未加密交换的会话，这样会产生 TCP 会话劫持攻击的风险。 10. 拒绝服务攻击拒绝服务攻击亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。 当攻击者使用网络上两个或以上被攻陷的电脑作为“僵尸”，向特定的目标发动“拒绝服务”式攻击时，其称为分布式拒绝服务攻击。攻击发起者一般针对重要服务进行攻击，如银行，信用卡支付网关，甚至根域名服务器。 攻击症状：网络异常缓慢（打开文件或访问网站）、特定网站无法访问、无法访问任何网站、垃圾邮件的数量急剧增加、无线或有线网络连接异常断开、长时间尝试访问网站或任何互联网服务时被拒绝、服务器容易断线、卡顿等。 10.1 ICMP 攻击ping 洪水攻击：通过功能强大的计算机，向单个受害服务器发送大量回显请求（echo request）命令。这样受害服务器会被这些网络流量淹没，无法响应合法的请求。 Smurf 攻击：攻击者向网络广播地址发送 ICMP 包，并将回复地址设置成受害主机的 IP 地址，通过使用 ICMP 应答请求数据包来淹没受害主机的方式进行。 如何阻止 Smurf 攻击： 管理员应该将网络中的主机和路由器配置为忽略广播请求。 避免直接向广播地址转发数据包。 忽略 ping 请求。 10.2 SYN 洪水攻击攻击者故意延迟或不发送握手确认消息。 假设连接发起方是 A，接受方是 B。A 发送 SYN 消息给 B，B反馈 SYN-ACK 消息给 A，使连接进入半打开状态。此时 B 会给每个半打开连接都设一个 Timer，如果超过时间还没有收到 A 的 ACK 消息，则重新发送一次 SYN-ACK 消息给 A，直到重试超过一定次数时才会放弃。B 维护半打开连接需要分配内核资源，如果 A 发送大量的 SYN 消息给 B 而不回复 ACK 时，SYN Flood 攻击就形成了。攻击方 A 可以控制肉鸡向 B 发送大量 SYN 消息但不响应 ACK 消息，或者干脆伪造 SYN 消息中的 Source IP，使 B 反馈的 SYN-ACK 消息石沉大海，导致 B 被大量注定不能完成的半打开连接占据，直到资源耗尽，停止响应正常的连接请求。 10.3 防范 SYN 洪水攻击SYN Cookie机制：在TCP服务器接收到TCP SYN包并返回TCP SYN+ACK包时，不分配专门的数据区，而是根据SYN包计算一个cookie值。 这个cookie作为将要返回的SYN ACK包的初始序列号。 SYN + ACK包的32比特结构如下：(1) 前5比特是时间戳，由每分钟按模32递增的计数器实现。(2) 中间3比特是编码值，表示传输段的最大值。(3) 最后24比特是基于密钥k，由服务器和客户端IP地址，端口号和前面使用的时间戳计算出来的MAC值。 当客户端返回一个ACK包时，服务器首先根据其前5比特判断是否过期；其次服务器根据包头信息重新计算24比特的MAC值，与返回的确认序列号(初始序列号 + 1)进行对比；最后，服务器对中间3比特进行解码，完成对SYN队列项的重构。如果验证通过，则服务器发起TCP会话。 11. IP 地址回溯由于 IP 地址欺骗，很难确定攻击者的真正源 IP 地址。IP 地址回溯能够确定数据包的真实来源，而不依赖于数据包头部的 IP 地址。 数据包标记技术：路由器基于数据包的相关路径信息确定地或者概率地标注转发数据包。受害者收集到足够数据包就能够重构攻击者的路径。一个简单的标注方法在经过路由器的数据包中追加其 IP 地址，但路由器开销会增加。 节点采样：不在每个数据包中追加路径信息，而使用 IP 数据包中的一个字段就可以记录路径信息。每个路由器以概率 p 用自己的地址覆盖每个数据包的这个字段。如果标记足够多的数据包，受害者就可以使用这个字段来确定攻击者和受害者之间途径的每个路由器。","link":"/2024/01/05/%E3%80%8C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E3%80%8D-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA-chap5/"},{"title":"「期末复习」- 微机原理与系统设计 - chap3","text":"1. 寄存器（16位） 在 14 个寄存器中，只有 A～DX 既可以当作 16 位寄存器，也可以当作 2 个 8 位寄存器。 除了当通用寄存器，BX 可以当作指针，用来寄存器间接寻址，即 [BX]。（ [AX], [CX], [DX] 都是不合法的写法） 访问堆栈的时候可以用 BP（基址指针寄存器）来间接寻址，读/写堆栈里面任何位置的数据，同时不会破坏栈的结构（不会影响栈顶当前的位置）。 SP、BP、SI、DI、IP 用来存段内偏移，CS、DS、SS、ES 用来存段起始地址的高16位。 指令指针寄存器（IP）：默认CS：IP。CX：LOOP指令实现循环时记录剩余循环次数。 1.1 标志寄存器（PSW/FLAGS） AF：辅助进位标志位，加法时若 向 有进位， AF 置 1 。CF：进位/借位标志位，若加法时最高位向更高位有进位或减法时最高位向更高位有借位， CF 置 1 。PF：奇偶标志位，若运算结果低八位中 1 的个数是偶数，PF 置 1 。SF：符号标志位，反映运算结果的最高位，最高位是什么 SF 就是什么。ZF：零标志位，若运算结果为 0 ， ZF 置 1 。OF：溢出标志位，若运算结果溢出， OF 置 1 。 2. 常用指令 S 前缀：Sign（有符号），即有符号的都是 S 开头的。BYTE（DB）：8 位（字节有 8 位）。WORD（DW）：16 位（1 个字长 = 2 个字节）。DWORD（DD）：32 位（双字，D Double）。 2.1 数据传送指令2.1.1 MOV 指令 MOV Y X，先目的操作数 Y，再源操作数 X。 立即数不能直接送至段寄存器，要先送到一个通用寄存器中。 2.1.2 PUSH、POP 指令2.3 算术运算指令2.3.1 ADD、SUB 指令 将同尺寸的源操作数和目的操作数相加减，结果存在目的操作数中（不改变源操作数）。 影响的标志位：CF、ZF、SF、OF、AF、PF。 2.3.2 ADC、SBB 指令 扩展加/减法，利用他们可方便地实现任意大小数字的加减运算。 ADC：带进位加，目的操作数 + 源操作数 + 进位标志 = 目的操作数。 SBB：带进位减，目的操作数 - 源操作数 - 进位标志 = 目的操作数。 2.3.3 INC、DEC 指令 INC/DEC reg/mem，INC 加1，DEC 减1。 INC 和 DEC 不影响进位标志位 CF。 2.3.4 NEG 指令 NEG reg/mem，作用是求负。 认为操作数是有符号数，形式是补码。该指令将操作数按位取反、末位加 1。 影响的标志位：CF、ZF、SF、OF、AF、PF。 2.3.5 MUL、DIV 指令 单操作数指令，操作数为乘（除）数。 操作数都为 8/16/32 位的内存变量 or 寄存器，不能是立即数。 进行的是无符号整数乘（除）法。 可以这么理解：根据乘（除）数的位数，决定从哪里取被乘（除）数，以及乘（除）法的结果存放在哪里。 MUL：被乘数和乘数的位数必须相同。8 位数 8 位数 用 16 位表示。16 位数 16 位数 用 32 位数表示（高 16 位在 DX，低 16 位在 AX）。 DIV：除数是8位，被除数必须是16位，商和余数也得是8位。除数是 16 位和 32 位时同理。 MUL 中两个 位数相乘用 位表示，肯定不会溢出。DIV 有可能溢出，除法溢出时会在 CPU 内部产生 0 号中断。 2.4 逻辑/移位指令2.4.1 AND、OR 指令 将两个位数相同的操作数进行按位与/或，结果存在目的操作数中。 影响的标志位：总是清除 OF 和 CF，根据结果修改 SF、ZF、PF。 2.4.2 NOT 指令 将操作数所有数据位取反，结果为反码。123asmmov al,11110000bnot al ; AL = 00001111b 2.4.3 SHL、SHR 指令 SHL，SHR：逻辑左（右）移。 SAL，SAR：算术左（右）移。 ROL，ROR：循环左（右）移，可以做到不丢失任何数据位。 RCL，RCR：带进位的循环左（右）移。 可以用移位指令进行一些快速的乘除法（2 的次幂）。 移位指令们影响 OF、CF。 2.5 循环跳转指令 JMP ：无条件转移 123top: jmp top ;repeat the endless loop LOOP ：条件转移 1234567mov ax,0mov ecx,5L1: inc axloop L1;循环体的第一条指令必须要给标号。循环体的最后一条指令要用loop，后面跟这个标号 ;循环结束时，AX = 5, ECX = 0 2.6 比较测试指令 TEST 和 CMP 都“不返回结果”（不修改目的操作数），只会根据结果设置标志位。 2.6.1 TEST 指令 TEST：两操作数按位与。 功能：可用来测试操作数的某一位是 0 还是 1（与一个数做按位与，判断 ZF 的值）。 影响的标志位：清除 OF、CF，修改 SF、ZF、PF。 2.6.2 CMP 指令 CMP：与减法指令一样执行减法操作（目的操作数 - 源操作数）。 影响的标志位：修改 OF、SF、ZF、CF、AF、PF。 2.7 条件转移指令 3. 常用寻址方式 COUNT 本质是常量，是立即寻址（如果是变量则是直接寻址） 12345.dataarrayB WORD 0000h, 8000h.codemov ax [arrayB + 2]neg ax","link":"/2024/01/02/%E3%80%8C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E3%80%8D-%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-chap3/"},{"title":"「期末复习」- 计算机安全导论 - chap4","text":"1. 内部攻击定义：指控制和保护资产的内部人员，利用安全漏洞进行的攻击。在恶意软件中，内部攻击是指由某位程序员在软件系统中创建的安全漏洞。 后门：程序中隐藏的功能或命令（正常情况下这些操作是不允许用户执行的）。逻辑炸弹：是一种程序，它根据一定的逻辑条件执行恶意操作。 防御内部攻击： 避免单点故障 使用代码走查 使用归档和报告工具 限制授权和权限 重要系统的物理安全 监控员工行为 控制软件的安装 2. 计算机病毒计算机病毒是一种能自我复制的计算机指令或程序代码。它通过修改其他文件与程序来插入代码，且能进一步自我复制。病毒的另一个特性是，其复制需要某种类型的用户协助（例如打开电子邮件附件或共享 USB 驱动器）。 2.1 病毒的特征 传染性 隐蔽性（代码短小精悍，隐藏巧妙） 潜伏性（病毒内部有一套触发机制，不满足触发条件时，除了传染外什么都不破坏） 多态性（不断变种，以防查杀） 破坏性（一旦触发，后果极为严重） 2.2 病毒执行的 4 个阶段 潜伏状态 \\Rightarrow 繁殖阶段 \\Rightarrow 触发阶段 \\Rightarrow 行动阶段3. 计算机蠕虫计算机蠕虫是一种恶意程序，不需要将自己注入其他程序，就能传播自己的副本，并且不需要与人交互。因此，从技术角度而言，计算机蠕虫不是计算机病毒（因为他们不会感染其他程序)，但两者本质上都是通过自我复制传播。在大多数情况下，计算机蠕虫会携带恶意的有效载荷，如删除文件或安装后门。第一个网络蠕虫：莫里斯蠕虫。 4. 特洛伊木马特洛伊木马（或木马）是一种恶意程序。表面上，它会执行一些有用的任务，但同时会隐形地执行具有负面后果的任务（eg.启动键盘记录器）。特洛伊木马可以作为其他恶意软件有效载荷的一部分，用户或管理员在有意或无意的情况下，安装了特洛伊木马。 特洛伊木马代码一般是程序员有意放在正常程序中。有的特洛伊木马代码分散在整个程序中，有的是在宿主程序执行后通过修改一串指令后才形成的。有的特洛伊木马指令则是以加密形式存放的，只有在执行的瞬间才解密。 一个完整的木马系统由三部分组成： 硬件部分：控制端、服务端、因特网； 软件部分：控制端程序、木马程序、木马配置程序； 具体连接部分：控制端IP、服务器端IP，控制端端口、木马端口 木马入侵的六步骤：（1）配置木马 （2）传播木马 （3）运行木马（4）信息反馈 （5）建立连接 （6）远程控制 特洛伊木马目前具有最大的感染潜力。 经常利用浏览器漏洞 通常用于在多阶段攻击中下载其他恶意软件 病毒、蠕虫、木马的对比 5. Rootkits（根工具包）这种恶意软件与操作系统深度结合，会修改系统实用程序或操作系统本身，以避免被检测和删除。 6. 广告软件与间谍软件6.1 广告软件定义： 广告软件是一种软件，旨在向用户展示广告，并通常通过弹出广告窗口、嵌入式广告或其他方式来产生广告收入。尽管某些广告软件可能是合法的，但有时它们可能会以侵犯用户隐私或干扰用户体验的方式存在。 基本原理： 绑定到免费软件： 广告软件通常与免费软件捆绑在一起，用户在安装免费软件时可能会不知不觉地安装广告软件。 监视用户行为： 一些广告软件可能会监视用户的浏览行为、搜索习惯或应用使用情况，以便更有针对性地显示广告。 显示广告： 广告软件的主要目的是向用户显示广告，以产生收入。这可能包括弹出广告、横幅广告或在应用程序界面中插入广告。 6.2 间谍软件定义： 间谍软件是一种恶意软件，设计用于在用户的计算机上悄悄收集个人信息、浏览习惯和其他敏感数据，通常用于广告定向、追踪或其他不法目的。 基本原理： 悄悄安装： 间谍软件通常通过欺骗、社交工程或漏洞利用等手段悄悄安装在用户计算机上。 监视用户活动： 一旦安装，间谍软件会监视用户的活动，包括浏览历史、键盘输入、登录凭据等。 传输数据： 收集到的敏感信息通常会被传输到远程服务器，供攻击者或广告公司使用。 隐秘性： 间谍软件通常设计为隐蔽运行，避免用户察觉其存在。 6.3 防范措施 使用安全软件： 安装和定期更新反病毒、反间谍软件，以及其他安全工具。 谨慎安装软件： 注意免费软件安装过程中的附加组件，避免不必要的工具栏和广告软件。 更新操作系统和应用程序： 保持操作系统和应用程序的最新更新，以修补已知漏洞。 定期扫描系统： 定期进行系统扫描，以便及时发现并清除潜在的广告软件和间谍软件。 7. 零日攻击指攻击者利用计算机系统、应用程序或服务中的未经公开披露的漏洞进行攻击的情况。这类漏洞通常被称为“零日漏洞”，因为在攻击发生之前，相关的漏洞并没有得到官方的修补或解决。攻击者利用这些漏洞，往往在被发现后，相关厂商才会发布相应的修补程序。 7.1 防范零日攻击 及时更新和修复： 维护者应定期更新操作系统、应用程序和其他软件，以安装最新的安全补丁和修复已知漏洞。 使用网络安全工具： 使用入侵检测系统（IDS）、入侵防御系统（IPS）等网络安全工具，以检测和防范零日攻击。 网络监控： 实施实时网络监控，以便检测不寻常的活动和潜在的攻击迹象。 教育和培训： 对系统管理员和终端用户进行安全教育和培训，提高他们对安全威胁的认识，减少社会工程学攻击的成功率。 使用应用程序白名单： 限制系统上运行的应用程序，只允许经过验证和授权的应用程序运行。","link":"/2024/01/02/%E3%80%8C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E3%80%8D-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA-chap4/"},{"title":"「期末复习」- 计算机安全导论 - chap3","text":"1. 进程安全1.1 引导顺序及安全引导：从关机状态到将操作系统加载到内存的操作。 计算机开机后，首先执行存储在 BIOS（基本输入/输出系统）中的代码。 BIOS 将第二阶段的引导加载程序加载到内存，该程序会将操作系统其余部分加载到内存，然后将控制权交给操作系统。 恶意用户可以利用引导过程的一些脆弱点来控制计算机的执行。 可以通过设置 BIOS 密码，来防止用户恶意引导第二阶段的加载程序。 1.2 引导设备的层次第二阶段引导程序允许用户指定应该使用哪个设备来加载操作系统。默认选项是从硬盘驱动器引导，也可以从外部介质（DVD驱动器、U盘）。BIOS 系统会提供一个引导的层次结构，它可以决定引导设备的优先级，应该确保操作系统是从值得信任的介质启动。 攻击者可以绕过运行的计算机上的安全机制，从外部介质引导其他的操作系统来访问硬盘。防止这类攻击的有效措施：对第二阶段引导程序的启动设置了密码保护，只允许授权用户从外部存储介质引导计算机启动。 1.3 监控、管理和日志事态感知：记录哪些进程正在运行、哪些计算机在联网。 如果操作系统遇到任何意外或者可疑操作，都会留下重要线索。这些线索可以帮我们解决问题，还能确定出现安全漏洞的原因。例如，反复失败的尝试登录日志可能警告有蛮力攻击，提示系统管理员修改密码以确保系统安全。 操作系统为监控和记录提供的主要手段：事件日志、进程监控和查看。 1.3.1 事件日志Windows 系统定义了三种日志源：系统、应用程序、安全。系统日志只有操作系统才能写入；应用程序只能写应用程序日志；而安全日志由操作系统提供的本地安全授权子系统（LSASS）服务才能写入。 Linux系统的具体日志机制跟发布的版本有关。通常情况下，日志文件存储在 /var/log 中，是具有描述性名称的简单文本文件。如 auth.log 包含用户身份验证记录，kern.log 记录内核操作等。通常情况下只有特殊的syslog守护进程才能写这些日志文件，日志项一般都包含时间戳和对时间的描述。 1.3.2 进程监控定义：用来探查计算机上正在运行的进程。Windows 系统可以使用任务管理器查看，Linux 可以使用 ps、top、pstree、kill 等命令。 2. 内存和文件系统安全2.1 虚拟内存安全Windows 系统中，虚拟内存页面存储在 C:\\pagefile.sys 中。Linux 系统需用户自己设定一个硬盘分区作为交换分区，存储内存页面关闭计算机时，硬盘上的虚拟内存页面会被删除。虚拟内存安全问题：如果攻击者突然将计算机断电，没有正常关闭计算机，此时虚拟内存页面可能未被删除。攻击者通过外部介质引导另一个操作系统，能够查看这些文件并重建部分内存，导致信息泄露。 解决办法：对硬盘内容进行加密。 2.2 基于密码的身份认证2.2.1 密码盐技术在散列之前将散列内容（例如：密码）的任意固定位置插入特定的字符串。这个在散列中加入字符串的方式称为「加盐」。 使用密码盐大大增加了字典攻击者所需的搜索空间（枚举是 级别的）。 2.3 访问控制 2.4 文件描述符存储在文件描述符表中的索引值，用来索引特定文件。 当程序需要访问文件时，访问 open 系统调用，该调用使内核创建一个文件描述符表中的新项并将其返回给程序，该项映射到文件的磁盘位置。程序可以使用文件描述符发送读/写命令。内核在接到读、写系统调用时，在文件描述符表中查找相关的表项，并在磁盘适当位置执行读、写操作。 完成操作后，要用 close 系统调用删除打开的文件描述符。使用文件描述符进行操作时，内核检查调用进程对文件是否有操作权限，如果没有相关的权限，返回操作失败。 文件描述符的漏洞：当进程创建子进程时，子进程会继承父进程打开的所有文件描述符副本。当程序以高权限打开文件描述符，但未关闭，然后又创建了低权限的进程，那么新进程就能够读写相关文件，但子进程本身不具有打开该文件的权限。 产生该漏洞的重要原因：在创建文件描述符项的时刻，操作系统只检查进程是否具有读写权限；在实际读写文件操作时，只根据文件描述符被打开时的权限来确认是否允许请求的操作。 2.5 符号链接和快捷方式对用户而言，能创建系统中其他文件的链接或快捷方式非常有用，因为它不需要将整个文件复制到新的位置。 Linux 系统：符号链接（使用 ln 命令来创建符号链接）。安全隐患：恶意方会利用符号链接诱使应用程序执行不良的操作。例如，考虑程序打开并读取用户指定文件的情形，假设这个程序不能读取一个特定文件 /home/admin/passwords。这个程序的不安全版本只检查用户指定的名是不是特定文件。然而，攻击者可以创建一个到该文件的符号链接，并指定符号链接的路径来欺骗这个程序。解决办法：程序检查文件名是否指向符号链接，以确定打开的实际文件名。 Windows系统类似的称为快捷方式。 两者的区别是：符号链接由操作系统处理，使用透明；而快捷方式是普通文件。 3. 应用程序安全3.1 编译和链接编译：将源代码转换为处理器能够执行的机器代码的过程。 静态链接：程序执行时所需的共享库需要复制到编译程序中（一般比较安全，但重复代码会占用额外的空间）。动态链接：程序真正运行时，才会加载共享库。加载程序确定待运行程序需要哪些共享库，然后在磁盘上找到这些库，并将它们导入进程的地址空间。 Windows中这些外部库称为动态链接库（DLL）；Linux中这些外部库称为共享对象（Shared object）。动态链接可以节省硬盘空间，允许开发者将代码模块化。例如为了修复 DLL 产生的漏洞，只需要改变一个特定 DLL。DLL 注入：通过共享库向程序注入任意代码的过程。优点是便于调试，缺点是潜在的安全风险，恶意用户能向合法程序注入自己的代码。 3.2 缓冲区溢出攻击缓冲区：进程为程序在内存中分配固定大小的存储空间。确保缓冲区安全：在向缓冲区复制用户数据时，进行边界检查。缓冲区溢出：如果不进行边界检查，攻击者提供的输入数据可能会超出缓冲区的大小，内存缓冲区之外的数据可能会被覆盖。攻击者利用缓冲区溢出获得进程的控制权，执行任意恶意代码。 3.2.1 基于栈的缓冲区溢出 12345678910111213#include &lt;string.h&gt;void foo(char *str) { char buffer[12]; strcpy(buffer, str); // buffer overflow will appear after excuting this.}int main() { char *str = \"wo bu xin bie kai zhe zhong wan xiao wo bi 12 chang.\"; foo(str); return 0;} 在上面的代码中， foo() 中的局部变量 拥有 字节的内存，foo() 使用 strcpy() 从 复制数据到 （直到碰到 \\0 才停止执行）。由于 的长度比 字节大， 中未被复制完的数据将会被放到 。 若 之上的区域包含一些关键数据，若他们被修改了，则会引发一些未知的错误。 123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;void foo(char *str) { char buffer[100]; strcpy(buffer, str);}int main() { char str[400]; FILE *badfile = fopen(\"badfile\", \"r\"); fread(str, sizeof(char), 300, badfile); foo(str); return 0;} 上述程序将系统磁盘上的文件 badfile 读入，该文件是用户可以自定义的，故带来了风险。 实际攻击中，攻击者需要猜测缓冲区中返回地址的位置，并确定用什么地址覆盖返回地址。难点在于： 进程不能访问其他进程的地址空间，因此恶意代码必须驻留在被攻击进程的地址空间内。一般驻留在缓冲区中或者在用户的 Shell 环境中。 给定进程的地址空间是不可预测的，程序在不同计算机上执行时，地址空间可能发生改变。 攻击者可以采取的相关技术有：NOP 指令滑动（NOP sledding）、返回到 libc（return-to-libc）、跳转到寄存器（jump-to-register）、蹦床技术（Trampolining）。 3.2.2 防治措施 - 栈的缓冲区溢出缓冲区溢出问题的根源在于不安全的编程实践，程序员需确保自己的程序复制的信息比缓冲区小。且只有 C 语言容易受缓冲区溢出攻击，其他语言不允许这种行为。可以使用更安全的函数来写代码，如用 strncpy 来代替 strcpy 函数。 操作系统也提供了保护机制以防止缓冲区溢出。如当检测到缓冲区溢出时，控制恶意代码的重定向。其具体实现包括： 防止攻击者覆盖返回地址 使用金丝雀技术 防止攻击者覆盖返回地址： 微软开发了一种编译器的扩展，称为 Point-Guard，其主要思想是将所有指针在使用前后都进行异或编码。 将内存的栈空间设置为非执行权限。 地址空间布局随机化（ASLR），随机地重新安排地址空间的数据，使得攻击者很难预测。 金丝雀预警技术： 重新组织分配程序的堆栈数据，使用一个金丝雀值（canary），将此值放在缓冲区和控制数据之间。系统定期检查 canary 值的完整性。若此值被更改，表明缓冲区溢出，就要防止恶意代码的执行。 3.2.3 基于堆的缓冲区溢出攻击堆（heap）是用来允许程序员动态分配内存的地址空间的。如果在堆上显示分配了内存（如使用 malloc、new 函数），但没有释放，会导致内存泄露问题。 基于堆的缓冲区溢出攻击，类似于基于栈的攻击。但基于堆的攻击更加复杂，它需要攻击者深入理解垃圾回收机制和堆是如何实现的。 攻击者一般通过修改堆中的数据或者滥用管理堆内存的函数和宏来执行恶意代码。 3.2.4 防治措施 - 堆的缓冲区溢出与栈溢出防御措施类似，如安全编程、地址空间随机化、设置堆数据不可执行、将存储堆内存的指针数据和存储堆中的实际数据相分离。 3.3 格式化字符串攻击C库函数在打印或者读入数据时，使用格式化字符串，如 printf(“%s”, str)。但如果不输入格式化信息，而是直接使用 printf(str)，会出现漏洞。 攻击者可以精心指定所使用的格式化字符串作为输入，并可以将输入写入内存的任意位置。如果写入的位置正好覆盖了返回地址、函数指针等，则攻击者能够取得控制权，并在程序的上下文中执行任意代码。 与格式化字符串相关的 C 库函数有 fprintf，printf，sprintf，snprintf，vfprintf，vprintf，vsprintf，vsnprintf 等。 格式化字符串参数包括 %%，%p，%d，%c，%u，%x，%s，%n等，其中 %x 从栈中读取数据，%s 读取字符串，%n 将当前打印出的字符数目写入参数指定的地址。 1234567891011121314151617#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main() { int cookie=1; char buf[8]; printf(\"%08x %08x\\n\", &amp;cookie, &amp;buf); printf(“%d\\n”, cookie); gets(buf); if(cookie == 0x61626364) printf(\"win\\n\"); return 0;}请尝试构建 buf 的输入值使得程序打印出 “win”，已知 cookie 和 buf 的地址分别为 0x0019ff2c 和 0x0019ff24，且英文字母 a 的 ASCII 码值为 61。（1）分析上述程序容易受到何种类型的攻击，并描述此攻击的基本原理。（2）请尝试构建 buf 的输入值使得程序打印出 “win”，已知 cookie 和 buf 的地址分别为 0x0019ff2c 和 0x0019ff24，且英文字母 a 的 ASCII 码值为 61。","link":"/2024/01/02/%E3%80%8C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E3%80%8D-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA-chap3/"},{"title":"「期末复习」- 计算机安全导论 - chap2","text":"1. 物理保护与攻击物理安全：泛指保护贵重物品、信息或访问受限资源所使用的物理措施，物理安全直接影响完整性。 电子密码锁：使用电磁铁或马达的电子结构来操作锁，例如通过打开或关闭电流事件来启动电磁铁或马达。电子密码锁的优点：便于更换密码、便于监控（如开锁时间）。 2. 身份认证技术条形码一维、二维码。条形码是方便但也是不安全的。由于条形码只是简单的图像，所以它们非常容易复制。 磁条卡磁条介质的一个漏洞是易于读取和复制。磁条阅读器可以以相对较低的成本购买，允许攻击者从卡上读取信息。攻击者只需结合稍微贵一点磁条编写器使用，就可以轻松克隆现有卡。因此，许多用途要求持卡人输入 PIN 后才可以使用他们的磁条卡。 智能卡智能卡包含一个集成电路，可选配一个板载微处理器，该微处理器具有读写功能，可以访问和更改卡上的数据。智能卡技术可以提供保护所有者信息的安全认证机制，并且极难复制。 它们通常被大公司和组织用作进行强认证的手段。智能卡还可以用作“电子钱包”，其可用于支付各种服务所产生的费用，包括停车费，公共交通和其他小型零售交易。 SIM 卡SIM 卡（Subscriber Identity Module card），许多移动电话使用这种用户识别模块卡的特殊智能卡。SIM 卡由网络提供商发行，用于维护用户的个人信息和联系信息，并允许用户向服务商所提供的蜂窝网络进行身份验证。 SIM 卡包含几条信息，用于识别所有者并对相应的蜂窝网络进行身份验证。每个 SIM 卡对应于其网络提供商维护的用户数据库中的一条记录。SIM 卡具有集成电路卡 ID (ICCID)，这是一个唯一的 18 位数字，用于硬件识别。SIM 卡包含唯一的国际移动用户标识（IMSI），其标识所有者的国家，网络和个人身份。SIM 卡还包含 128 位密钥，此密钥用于向移动网络验证电话。作为额外的安全机制，许多 SIM 卡在允许访问卡上的信息之前需要 PIN。 挑战响应协议 RFID射频识别（RFID）是一种快速兴起的技术，它依靠小型转发器，通过无线电波传输识别信息。RFID 芯片具有用于存储信息的集成电路，以及用于发送和接收无线电信号的线圈天线。 护照包括美国在内的几个国家的现代护照，都有一个嵌入式 RFID 芯片，其中包含有关所有者的信息，包括一张允许机场官员比较护照所有者与持护照人对比的数字面部照片。 为了保护护照上的敏感信息，所有 RFID 通信都使用密钥加密。 生物识别技术用于基于生物或生理特征唯一识别信息进行的任何身份度量。 要求：普遍性，独特性，持久性，可收集性。 3. 针对计算机的直接攻击信号发射计算机屏幕发出的射频信号可用于检测正在显示的内容。可见光反射也可用于从墙壁，咖啡杯或眼镜上的反射重建显示器。这两者都要求攻击者使接收器足够接近以检测信号。 键盘记录器键盘记录器是记录受害者击键的一种方法，通常用于窃听密码或其他敏感信息。硬件键盘记录器通常是安装在键盘和计算机之间的小型连接器。 法拉第笼为了阻挡空气中的电磁辐射，可以在敏感设备周围安装金属导电屏蔽或这种材料的网孔，网孔比我们希望阻挡的电磁辐射波长要小。这种外壳被称为法拉第笼。 ATM自动柜员机/自助存（取）款机（Automatic Teller Machine, ATM）是允许金融机构的客户在没有人工协助的情况下完成取款和存款交易的任何设备。通常，客户插入磁条信用卡或借记卡，输入 PIN 码，然后从其帐户存入或提取现金。 ATM 有一个内部加密处理器，用于加密输入的 PIN 并将其与存储在卡上的加密 PIN （仅适用于未连接到网络的旧系统）或远程数据库进行比较。 ATM 交易的当前行业标准是 Triple DES（3DES）密码系统，这是一种传统的对称密码系统，具有高达 112 位的安全性。 4. 计算机取证在计算机上保存、识别、提取、记录和解释数据的科学过程，用于获取潜在的法律证据。 5. RAID 系统独立硬盘冗余阵列（Redundant Arrays of Independent Disks, RAID）提出的背景： 采用单块硬盘进行数据的存取，I/O 性能低且存储容量受限。 单块硬盘容易出现物理故障，导致数据丢失。 RAID：将多块独立的硬盘结合在一起组成一个技术方案，来提高数据的可靠性和 I/O 性能。 RAID 的主要功能： 数据冗余和容错性：RAID 通过在多个硬盘上复制数据或计算冗余校验位，实现数据在硬件故障下的保护。这种冗余性质使得 RAID 能够抵御硬盘故障等风险，确保数据的完整性和可恢复性。 提高性能：通过数据条带化，RAID 将数据分块并分布到多个硬盘上，从而实现并行读写操作，显著提高数据传输速率和响应时间，特别是在大型文件的读取和复杂查询的执行过程中。 扩展存储容量：RAID 技术允许将多个独立的硬盘合并为一个逻辑硬盘，从而有效扩展存储容量，对于需要大规模存储的应用，如高清视频、大型数据库等具有重要意义。 平衡负载：在一些 RAID 模式中，数据可以根据负载情况自动分布到多个硬盘上，从而实现负载均衡。","link":"/2024/01/01/%E3%80%8C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E3%80%8D-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA-chap2/"},{"title":"「期末复习」- 计算机安全导论 - chap1","text":"1. C.I.A.信息安全：C.I.A.——机密性（confidentiality），完整性（integrity），可用性（availability）。 1.1 机密性定义：避免未授权信息的泄露（现今实现机密性也越来越困难）。 保护机密性： 加密（Encryption）：加密密钥，解密密钥，加密算法。 访问控制（Access control）：限制访问机密信息的一套规则和策略，需要提供身份信息或者角 色以访问机密信息。 认证（Authentication）：通过某个信息或某些信息的组合，确定某人的身份或角色。 授权（Authorization）：基于访问控制策略，确定一个人或者系统是否允许访问资源（同时应该阻止攻击者利用欺骗手段使其能够访问受保护的资源）。 物理安全（Physical security）：建立物理障碍限制访问受保护的计算资源。 1.2 完整性定义：确保信息不会在未被授权的情况下更改。 保护完整性： 备份（Backup）：数据的定期归档。 校验和（Checksum）：通过某个函数将文件内容映射为一个数值（特性：文件的小改变会使得函数输出有大变化）。 数据纠错码（data correcting codes）：在数据变化时可以检测并纠正。 保护元数据（metadata）：保护原数据的数据（文件所有者、最后更改时间等）。 1.3 可用性定义：确保授权用户能够对信息进行及时访问和修改。 保护可用性： 物理保护：在物理环境恶劣变化时也能够保护信息的可用性。 计算冗余：在部分计算机或者存储设备失效的情况下依然可以提供信息（磁盘冗余阵列 RAID）。 2. A.A.A.安全目标：A.A.A.——保证（Assurance），真实性（Authenticity），匿名性（Anonymity）。 2.1 保证定义：在计算机系统中，如何提供和管理信任。 系统资源的管理和保护：确保「系统资源使用」符合设定的策略。e.g. 在线音乐系统的设计者，可能规定了描述用户如何访问和复制歌曲的策略。 信息使用方式的管理：确保「信息如何被使用」符合设定的策略。e.g. 在线电影租赁系统的用户已租用了电影的电子版，我们只允许用户可以观看固定次数的电影。 2.2 真实性定义：确定人或者系统所发布的声明、策略和权限真实性的能力。 不可抵赖性：一个人或者系统不能否认其所发布的真实声明。 实现不可抵赖性：数字签名（一种加密计算方法，允许人或者系统以唯一的方式认可与其相关数据的真实性）。 2.3 匿名性定义：确保特定的记录或者交易不归因于任何个体的属性。 3. 威胁与攻击篡改：在未被授权的情况下修改信息。 抵赖：对承诺或者接收到数据的否认。 窃听：在通信信道中侦听发送给其他人的信息（数据包嗅探，Packet Sniffing）。 伪装：捏造消息并声称这些消息来自某人，但并非是消息的作者（数据包伪造，Packet Spoofing）。 拒绝服务攻击（Denial-of-service）：数据服务或者信息访问的中断、退化（e.g. 垃圾邮件，使邮件队列充满以降低邮件服务器的响应速度） 相关性和追溯：多个数据源和信息流来确定一个特定数据流或信息的源头。 4. 十大安全原则 机制的经济性：在设计和实现安全措施时的简洁性。 故障安全默认配置：所设计系统的默认配置应该具有最少的权限（保守的安全机制）。 完备调停：对于资源的每次访问，必须检查以确保不违背安全机制，注意访问权限可能随时间变化（银行要求用户定期重新登录）。 开放设计：系统设计和安全体系结构应该公开，安全仅依赖于对密钥的保密。 特权分离：只有在多个条件同时满足的情况下，才能访问受限资源，或者让程序执行某些操作。 最小特权：要求每个用户和程序在操作时应当使用尽可能少的特权。 最少公共机制：在多用户系统中，允许多个用户共享资源的机制应该最小化（如果多个用户都需要访问文件或者应用程序，那么这些用户应该通过各自的通道来访问资源）。 心理可接受性：用户接口应该精心设计且非常直观，所有与安全相关的设置都按普通用户的期望进行配置。 工作因素：在设计安全方案时，绕过安全机制的代价应与攻击者的资源做对比。 危害记录：有时候记录入侵细节，比采用更复杂的措施来预防入侵更为理想。 5. 访问控制通过确定谁有权限访问各种信息，从源头上阻止攻击。 5.1 访问控制矩阵定义访问权限的表（行：主体；列：资源/资源所在路径；值：拥有的读、写、执行等权限） 优点：能够简单、直观地观察访问控制关系；控制粒度细，针对每一个主客体对。缺点：缺乏可扩展性，访问控制矩阵有可能会很大（ 的规模）。 5.2 访问控制列表对于每个资源都建立一个表，表中包含每个主体及他们拥有的权限。 优点：与访问控制矩阵比小很多，可将客体的列表以元数据形式存储。缺点：枚举每个主体的访问权限复杂度高。这种枚举是必须的，例如将一个主体从系统中移除的时候。 5.3 能力列表对于每个主体建立一个表，表中包含对每个资源及对他们能执行的操作。由于原理相同，优缺点与访问控制列表类似。 5.4 基于角色的访问控制定义角色，并对角色指派访问控制权限，而不是直接对主体。（一个角色可能包含若干个主体。一个主体也可能有多个角色） 优点：存储高效，降低需要记录的规则数量。缺点：在目前操作系统中未实现。 6. 加密6.1 加密加解密算法是公开的，加解密密钥是保密的： 维护密钥的保密性更容易。 若密钥暴露，换密钥即可。 面对多对加密通信的需求，使用相同的加密算法和不同的密钥即可。相比于使用不同的加密算法，设计成本和复杂程度及各方面代价都大大降低。 开放密码学设计的优势： 可以使该算法承受公开的钻研和分析，因此可以变得更加强壮。 公开后有更大的可能被正义黑客发现，比被敌人发现要好。 公开设计使标准更容易建立。 系统的安全取决于算法的保密性，对代码的逆向抵抗力很差。密钥不是代码的一部分，不存在这个问题。 6.1.1 凯撒密码将每个字符替换为字母集中它后面的第三个字符。 6.1.2 对称加密A 与 B 共享一个密钥，同时用在加密和解密中。 6.1.3 对称加密分发每一对通信实体，独立的共享一个密钥。 个人形成一张完全图，用到 个钥匙。 6.1.4 公钥加密加密和解密使用不同的密钥。 例：B 有两个密钥，私钥 由 B 保密，公钥 由 B 公开。A 向 B 发送加密的消息时， A 首先需要获取 B 的公钥 ，并使用 加密消息 ：，将加密结果 发给 B。最后 B 使用私钥解密得到明文 ：。应用：数字签名。 6.2 数字签名公钥加密体制可以用来构造数字签名。数字签名文件的完整性容易验证的，而且数字签名具有不可抵赖性。 例：为了对一个消息 签名，A 用自己的私钥 对 加密：。任何人可以使用 A 的公钥 解密密文 ： ，并与消息 进行比较。缺点：若待签名消息 很长的话，签名也会与 一样长，导致效率低下。 6.3 哈希函数消息 的一个校验和，需要满足单向性和抗碰撞性。 单向性：计算 很容易，但从 得到 很难。抗碰撞性： 应尽可能是个单射。 应用：数字签名中减少代签名消息的长度，首先对消息 应用哈希函数，对其输出的结果再应用数字签名算法。 6.4 数字证书A 如何确认获取的 B 的公钥确实是 B 的：数字证书将用户身份和其公钥绑定，并与第三方可信机构（CA）的私钥签名。 6.5 中间人攻击对加密机制、数字签名的中间人攻击。 7. 可用性计算机安全解决方案应该高效：用户不喜欢用很慢、且操作复杂的系统。例如：经常用公钥体制进行密钥交换，而在随后通信中采用对称加密。 8. 密码的字典攻击定义：在破解密码时，逐一尝试用户自定义词典中的可能密码的攻击方式。 与暴力破解的区别是：暴力破解是枚举所有的可能性，而字典式攻击是使用一个预先自定义好的、可能的密码列表。 9. 社会工程学定义：指利用人们内心深处的弱点，用计谋来绕过计算机安全的防护措施。 社会工程攻击，是对计算机安全解决方案的最强攻击手段之一。","link":"/2024/01/01/%E3%80%8C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E3%80%8D-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA-chap1/"},{"title":"杜文亮深度实践笔记 - chap13 - 对TCP的攻击","text":"13.1 Introduction to TCP13.1.1 Advantage of TCP即使传输层中拥有了 UDP 协议，但还是有些功能需要更高级的协议来实现。 1. Providing a Virtual ConnectionTCP 需要在通信的两端建立一条逻辑上的连接。可以把它想象为进行通信的应用程序之间的数据管道（pipe）。 2. Maintaining order由于 TCP 的传输机制，可以保证接收方接收到从发送方发送的有序的数据包，这个功能对于一些“阅读顺序不同则会导致意思不同”的情况非常重要。 3. ReliablityTCP 具有“发现数据包在传输过程中丢失”的功能，在发现有数据包在传输过程中丢失时，TCP 会尝试重传丢失的数据包，以保证通信的可靠性。 4. Flow and Congestion ControlTCP 在内部还提供流量控制与拥塞控制。流量控制用来防止在数据传送过程中“发送方发送速度过快，接收方来不及接受从而导致数据包意外丢失”的情况，拥塞控制用来防止“过多的数据注入到网络，导致网络中的路由器或链路过载”的情况。 13.1.2 Principles When TCP WorkingTCP CilentCilent 是建立连接的一端。TCP Client Program 展示了 Client 需要做的事情： 建立一个 socket。 当建立 socket 时，需要指明通信的类型。TCP 使用 SOCK STREAM 类型，而 UDP 使用 SOCK DGRAM 类型。 设定目的地信息。 需要提供服务端的信息，以便系统知道将 TCP 数据发送到哪里。服务端信息包括 IP 地址和端口。在本例中，服务器程序运行在 10.0.2.17 的 9090 端口上。 连接服务端。 TCP 是一个面向连接的协议，这意味着在两端可以互相交换数据之前，需要先建立连接（TCP 的三次握手协议）。这不是一条从客户端到服务端的物理连接，而是一条客户端和服务端之间的逻辑连接。 这个连接可以通过一个四元组来表示：源IP 地址、源端口号、目的IP地址和目的端口号。 发送和接收数据。 一旦连接建立，两端便可通过系统调用发送和接收数据。 发送数据可以使用 write()、send()、sendto() 和 sendmsg() 等系统调用。 接收数据可以使用 read()、recv() 和 recvfrom() 等系统调用。 关闭连接。 一旦通信结束，连接需要被关闭，这样它占用的系统资源将被释放。 通过使用系统调用 close() ，程序将会发送一个特别的数据包告知对方连接将被关闭。 TCP ServerServer 会监听 Client 建立的连接。TCP Server Program 展示了 Server 需要做的事情： 建立一个 socket。这个步骤与客户端相同。 绑定一个端口号。 一个应用如果需要与其他应用通过网络连接，则需要在主机上注册一个端口号。这样当一个数据包到达时，基于数据包内指定的端口号，操作系统可以知道哪个应用是数据包的接收者。服务器需要告知操作系统它使用的端口号，这是通过系统调用 bind() 来完成的。 在本例中，服务端程序使用 9090 端口。流行的服务器通常会绑定一些知名的特定端口号，以便客户端可以很容易地找到服务器监听的端口。例如，典型的 Web 服务器使用端口 80 和 443 , SSH 使用端口 22。 Client 也需要注册端口号，这也可以通过 bind() 系统调用完成。然而，客户端并不需要事先指定任何特定的端口号，这是因为客户端不需要被他人主动发现。客户端会首先找到服务端，告知服务端它目前正在使用的端口号。因此，就像代码所展示的那样，客户端程序不需要通过 bind() 系统调用注册端口号，这将交由操作系统决定。也就是说，如果客户端没有注册端口号，当初始化一个连接时，操作系统将会随机分配一个端口号。 监听连接。 一旦连接建立，程序使用系统调用 listen() 等待连接。这个调用没有阻塞，因此它并不是真的在“等待”连接。它告知操作系统自己已经准备完毕，可以接收连接请求了。一旦收到连接请求，操作系统将会执行三次握手协议与客户端建立连接。建立好的连接被放置于一个队列中，等待应用接管。listen() 的第二个参数指明了队列最多能存放多少个等待的连接。如果队列已满，后来的连接请求将不会被接受。 接受连接请求。 虽然连接已经建立，但对应用程序来说它还是不可用的。一个应用需要明确地表示“接受”连接，这便是系统调用 accept() 的目的。它从队列中取出一个连接请求，建立一个新的 socket，并把 socket 的文件描述符返回给应用程序。如果这个 socket 被标记为不可阻塞，并且队列中没有等待的连接，accept() 将会阻塞调用它的应用。 在程序开头建立的 socket 只被用来和客户端建立连接，它并不被用在任何一个连接上。 当一个连接建立好后，一个新的 socket 会被建立，应用可以通过这个新的 socket 来使用该连接。这样，原来的 socket 就可以继续用来等待新的连接请求。 发送和接收数据。 一旦连接建立并被接受，连接双方就可以传输数据了。服务端发送和接收数据的方式与客户端相同。实际上，对于一条建立起来的连接，从数据传输的角度看，两端是平等的，客户端与服务端之间并没有任何不同。 接受多条连接：上面的程序是 TCP 服务端程序的简单例子，它只接受一个连接。一个更实际的 TCP 服务端程序允许多个客户端连接它。实现这个功能的典型做法是在接受一个连接后创建一个子进程，然后再使用新创建的子进程去接管这个连接，这样父进程就会空出来，可以继续通过 accept() 系统调用处理另一个等待的连接请求。","link":"/2023/12/18/%E6%9D%9C%E6%96%87%E4%BA%AE%E6%B7%B1%E5%BA%A6%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0-chap13-%E5%AF%B9TCP%E7%9A%84%E6%94%BB%E5%87%BB/"},{"title":"抽象代数笔记 - 7.3 - 特殊的格","text":"7.3 特殊的格7.3.1 分配格设 是由格 所诱导形成的代数系统，若 满足： a \\wedge (b \\vee c) = (a \\wedge b) \\vee (a \\wedge c) \\\\ a \\vee (b \\wedge c) = (a \\vee b) \\wedge (a \\vee c)则称 是分配格。 分配格的定理 设 中 对 可分配，则 对 也可分配，反之亦然。 每个链都是分配格。 一个格是分配格，当且仅当它不存在与钻石格和五角格同构的子格。 分配格的子格也是分配格。 7.3.2 有界格全上（下）界：若格 中存在一个元素 ，使得 ，都有 （），则称 为格 的全上（下）界。通常将全上界称为 ，全下界称为 。 既有全上界也有全下界的格，称为有界格。 定理：每个有限格都是有界格。 7.3.3 有补格补元：设 是一个有界格。对于 中的一个元素 ，若 ，使得： a \\wedge b = 0 \\\\ a \\vee b = 1则称 是 的补元，记作 。同时 也是 的补元，记作 。 有补格：在有界格中，若每个元素至少有一个补元，则称此格为有补格。 7.3.4 布尔格既是有补格又是分配格的格，称为布尔格。 定理：布尔格中的每个元素都有唯一的补元。","link":"/2023/12/17/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0-7-3-%E7%89%B9%E6%AE%8A%E7%9A%84%E6%A0%BC/"},{"title":"抽象代数笔记 - 7.2 - 子格与格同态","text":"7.2 子格、格同态7.2.1 子格的定义设 是由格 所诱导形成的代数系统。设集合 且 。若 中的两个运算 和 在 上是封闭的，则称 是 的子格。 一个格中的部分元素在原偏序关系上构成一个格，不能说明它就是原格的子格。主要看该子集上的任意两个元素在原运算保交和保联下的结果是否也在该子集中。 7.2.2 格同态设 和 是两个格，由他们所诱导的代数系统分别为 和 。若存在映射 ，使得 满足： f(a \\wedge b) = f(a) \\wedge' f(b) \\\\ f(a \\vee b) = f(a) \\vee' f(b)则称 为从 到 的格同态，称 为 的同态象。 格同态的保序性设 是从格 到格 的格同态，则 ，若 ，则有 。 格同构设 是从格 到格 的格同态，若 是双射函数，则称 为从 到 的格同构。","link":"/2023/12/17/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0-7-2-%E5%AD%90%E6%A0%BC%E4%B8%8E%E6%A0%BC%E5%90%8C%E6%80%81/"},{"title":"抽象代数笔记 - 7.1 - 格","text":"7.1 格7.1.1 格的定义设 是一个偏序集，若集合 中的任意两个元素都有唯一的最小上界和最大下界，则称 为格。 判断是否为偏序关系：满足自反性、反对称性、传递性。 自反性： 反对称性： 传递性： 7.1.2 格的运算保交运算 a \\wedge b = glb \\{ a, b\\}表示求 的最大下界。 保联运算 a \\vee b = lub \\{ a, b\\}表示求 的最小上界。 格的对偶定理若 是一个格，则 也是一个格。 设 是一个命题。 的对偶命题 ，是将关系符 换成 ，将保交 与保联 运算符互换所得的命题。若 中对一切格都为真，则 对一切格也都为真。 7.1.3 代数格设 是一个格，。在 上可以定义两个运算 和 ： 也可以写成 。 也可以写成 。 则称 、 为格 所诱导的代数系统，简称代数格。 代数格的定理 在一个格 中，，有： a \\leq a \\vee b, \\quad b \\leq a \\vee b \\\\ a \\wedge b \\leq a, \\quad a \\wedge b \\leq b 在一个格 中，，若 且 ，则有： a \\vee c \\leq b \\vee d \\\\ a \\wedge c \\leq b \\wedge d 代数格的性质 若 是一个代数系统，其中 和 都满足吸收律，则运算 和 都满足等幂律。 若 是一个代数系统，其中 和 都是二元运算且满足交换律、结合律、吸收律，则 上存在偏序关系 ，使得 是一个格。","link":"/2023/12/08/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0-7-1-%E6%A0%BC/"},{"title":"杜文亮深度实践笔记 - chap12 - 数据包嗅探和伪造","text":"课程前置计算机网络知识回顾 \\quadClassful Addressing 将 IP 地址分为 5 类。由于网络地址长度是固定的，故每一类 IP 地址可分配的数量也是固定的。这样在分配给企业时有可能造成 IP 地址过多浪费等问题。 Classless Addressing 中网络地址的长度可以自定义（即IP 地址 / 后的数字），引申出子网掩码（Net Mask）的概念。 随着互联网设备的增多，IPV4 已经不能满足为所有设备提供唯一的 IP 地址。IPV6 可以暂时地解决 IP 地址不足的问题，但 NAT（Network Address Translation）可以完美地解决这个问题。大部分电脑都配置有 NAT 服务，该服务允许设备在本地使用自定义的私人 IP 地址，当要与互联网通信时，NAT 会将私人 IP 转译为其在互联网上的真实 IP。 获取 IP 地址的方法有手动和自动。自动获取 IP 地址需借助 DHCP（Dynamic Host Configuration Protocol） 。 DNS（Domain Name System）将 IP 地址与主机名进行对应，方便人们记忆。 12.1 Introduction数据包嗅探和伪造（Packet Sniffing and Spoofing）是两种常见的攻击形式，也是众多其他网络攻击的基础。嗅探（Sniffing）：Trying to receive everybody’s packets.伪造（Spoffing）：Put some fake information into the packet and send it out. 12.2 Use Socket to send packets将数据打包成数据包是很复杂的事情，这件事由 OS 来完成。应用只需要使用 OS 提供的系统调用，将数据通过对应的 API 传入内核即可。 Packets 中不止要包括传输的信息，还需包括使用的协议、目的 IP 地址等信息。 以下是分别使用 Python 和 C++ 编写的 UDP 程序，来进行 Packets Sending 的过程。 12.3 Receiving Packets1. IP layer and above IP layer：判断“我”是否是该数据包要被传送到的最终地址。 Transport layer：IP layer 会判断该数据包所采取的 Transport Protocol（e.g. UDP, TCP），并送至对应的模块。 Application：应用通过端口 port 来接受数据包，因此可以通过 OS 与指定的端口号进行绑定。所以每当数据包到来时，传输层得以知道这是哪个应用需要的数据包。传输层会将数据包存储至对应端口的缓冲区 buffer。 2. IP layer and below &amp; Packet Sniffing一般情况下，当电脑通过网卡 NIC 接收到数据包时，会检测目的地址是否与自己的 MAC 地址相同来判断“这个数据包是不是发给我的”。如果不同则大多数情况下会选择丢弃该数据包。 OS 提供了一种特殊模式来支持 Packet Sniffing（即使不是发给自己的也不选择丢弃，这样才可以“偷”到别人的数据包），该模式叫做混杂模式（Promiscuous Mode）。在混杂模式下，一台机器的网卡能够接收所有经过它的数据流，而不论其目的地址是否是它。 由于 Sniffer Program 位于上层，在 Protocol stack 中的 IP layer 仍会对该数据包的 IP 地址进行检查。也就是说不是发给自己的数据包会在 IP layer 的时候会被检测到异常，从而被丢弃。可以通过一种特殊的 Socket（Raw Socket）来避免这个问题。若存在 Raw Socket，所有数据包会被进行复制并传给这个 Raw Socket。 有时我们只需要对我们有用的数据包，如和 DNS 有关的数据包。所以对嗅探到的数据包进行筛选是很重要的。 BPF 是一种高效的、提前筛选的方法。 12.4 Packet Sniffing","link":"/2023/11/30/%E6%9D%9C%E6%96%87%E4%BA%AE%E6%B7%B1%E5%BA%A6%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0-chap12-%E6%95%B0%E6%8D%AE%E5%8C%85%E5%97%85%E6%8E%A2%E5%92%8C%E4%BC%AA%E9%80%A0/"},{"title":"抽象代数笔记 - 6.8 - 环和域","text":"6.8 环和域6.8.1 环若代数系统 满足： 是阿贝尔群（ 是群且 在 上可交换）。 是半群（ 在 上可结合）。 乘法 对加法 是可分配的。即 ，有： a \\cdot (b + c) = a \\cdot b + a \\cdot c \\\\ (b + c) \\cdot a = b \\cdot a + b \\cdot c 则称 是环。 环的定理设 是环， 是 的幺元。则 ，有： （ 同时也是 的零元） 是 的加法逆元，将 记作 。 特殊的环设 是环: 交换环：若运算 是可交换的。 含幺环：若 含有幺元。 含零因子环： 是 的幺元，若 ，使得 ，则称 是零因子，称 是含零因子环。 整环： 是可交换独异点且无零因子（独异点：不要求所有元素可逆的群）。 整环的定理设 是环， 是 的幺元。 无零因子当且仅当 满足可约律（即 ，若 ，必有 ）。 6.8.2 域在代数系统 中， 是 的幺元，若： 是阿贝尔群（ 是群且 在 上可交换）。 也是阿贝尔群。 乘法 对加法 是可分配的。 则称 是域。 域的定理域一定是整环。可以通过整环的概念来定义域： 设 是整环，，且 是群，则 是域。 有限整环一定是域。","link":"/2023/11/28/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0-6-8-%E7%8E%AF%E5%92%8C%E5%9F%9F/"},{"title":"数据库系统笔记 - chap7 - 数据库设计","text":"7.1 数据库设计概述数据库设计的基本步骤：需求分析 概念结构设计 逻辑结构设计 物理结构设计 数据库实施 数据库运行和维护。 7.2 需求分析阶段需求分析即分析用户的要求。需求分析结果是否准确反映用户的实际要求，将直接影响到后面各阶段的设计，并影响到设计结果是否合理和实用。 7.2.1 需求分析任务调查现实世界要处理的对象，充分了解原系统的工作概况，明确用户的各种需求，然后在此基础上确定新系统的功能。新系统也必须充分考虑今后可能的扩充和改变。 7.2.2 数据流图 &amp; 数据字典对收集到的需求信息进行加工整理，以数据流图和数据字典的形式进行描述，作为需求分析阶段的成果，这也是下一步设计的基础。 7.3 概念结构设计阶段在需求分析阶段所得的数据流图和数据字典基础上，将用户需求抽象为信息结构（即概念模型）的过程就是概念结构设计。 7.3.1 E-R 模型E-R 模型（entity-relationship model）是描述概念模型的工具。目前大部分数据库设计工具和产品均采用 E-R 模型进行数据库的概念结构设计。 完整的 E-R 图：属性、实体、联系都要完整。 E-R 图的表示 实体之间的联系 若一个联系具有属性，则这些属性也要用无向边与该联系连接起来。 7.3.2 概念结构设计实体与属性的划分原则为了简化 E-R 图的处置，现实世界的事物能作为属性对待的，尽量作为属性对待。 两条准则： 作为属性，不能再具有需要描述的性质，即属性必须是不可分的数据项，不能包含其他属性。 属性不能与其他实体具有联系，即 E-R 图中所表示的联系是实体之间的联系。 E-R 图的集成E-R 图的集成一般需要分两步： 合并:解决各分 E-R 图之间的冲突，将分 E-R 图合并起来生成初步 E-R 图。 修改和重构:消除不必要的冗余，生成基本 E-R 图。 各个局部应用所面向的问题不同，各个子系统的 E-R 图之间必定会存在许多不一致的地方，称之为冲突。各子系统的 E-R 图之间的冲突主要有三类：属性冲突、命名冲突和结构冲突。 7.4 逻辑结构设计逻辑结构设计的任务是把概念结构设计阶段设计好的基本 E-R 图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构。 7.4.1 E-R 图向关系模型的转换将 E-R 图转换为关系模型，实际上就是要将实体型、实体的属性和实体型之间的联系转化为关系模式。","link":"/2023/11/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-chap7-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"},{"title":"抽象代数笔记 - 6.7 - 群","text":"6.7 群6.7.1 群的定义群：设 是一个代数系统。若 运算是可结合的（是半群），并且存在幺元（是独异点），并且 ，都存在其唯一的逆元 ，则称 是一个群。 群的阶数：群的元素个数，记作 。根据 可以将群分为有限群和无限群。 6.7.2 群的性质 群中无零元。 （因为零元不可逆，故群中一定不含零元。） 群中每个元素的逆元唯一。 设 是一个群，对于 ，必存在唯一的 ，使得 。 （即群中任何两个元素都能通过运算相互表示。） 设 是一个群， ，若有 或者 ，则必有 （消去律）。 （因为没有零元，所以可以直接消去。） 设 是一个群，除幺元 外，不可能有任何别的等幂元。 （幺元是唯一的等幂元。） 群 的运算表的每一行/每一列都是 中所有元素的一个置换。 （ 中每一个元素都会在运算表中的每一行/每一列出现，并且只出现一次。） 6.7.3 群中元素的阶设 是一个群， 是幺元， 。若存在唯一且最小的正整数 使得 ，则称 为元素 的阶（或周期）；否则称元素 的阶是无限的。 证明的时候一定要证最小性！ 定理1若群 的元素 拥有一个有限阶 ，则 当且仅当 是 的倍数。 定理2群中任何一个元素 与它的逆元 都具有相同的阶。 定理3有限群 中任何一个元素的阶最多是 。 6.7.4 阿贝尔群与循环群阿贝尔群：若群 中 运算是可交换的，则称该群为阿贝尔群（Abel 群）或交换群。 循环群：设 是群，若 ，则称 为循环群。 是循环群 的一个生成元。一个循环群的生成元个数可以不唯一。与循环独异点不同的是，循环群中 中的 可以取负整数。在这里理解成对 先求逆，再进行 次的运算。 任何一个循环群必定是阿贝尔群。（证明：将元素写成生成元的幂的形式，再证明 的可交换性，其中用到了加法是可交换的。） 6.7.5 循环群的性质设 是循环群，它的生成元是 ，，则： 是使 的最小正整数。 。 定理：循环群的子群必是循环群。 6.7.6 子群和群同态设 是群， 是 的非空子集。若： —— 在 上封闭。 —— 中所有元素可逆。 ， 其中 是 的幺元 —— 包含和 中一样的幺元。 则称 是 的子群。 和 称作 的平凡子群。（联想到子代数和平凡子代数的概念） 子群的判定1设 是群， 是 的非空子集。若运算 在 上封闭，并且 ，则称 是 的子群。 子群的判定2设 是群， 是 的非空子集。若 是有限集，并且 在 上封闭，则称 是 的子群。 子群的判定3设 是群， 是 的非空子集。若 ，则称 是 的子群。 判定的方法越来越简短，有特殊性质的时候，就可以直接用靠后的判定方法来判定。 群同态设 和 是两个群， 是 到 的映射。若 ，都有 ，则称 是 到 的群同态， 称作 的同态象。（本质与之前的同态概念相同，先运算再映射 = 先映射再运算） 之前的同态是针对普通代数系统的，群同态的概念只是在代数系统是群的条件上产生的。 群同态的定理群 的同态象 ，不光是群，而且是群 的子群。证明： 群：证普通代数系统拥有封闭性、可结合性、含幺元、元素可逆。 子群：证普通代数系统拥有封闭性、可结合性、元素可逆、含相同幺元。 同态核设 是从群 到 的一个同态映射， 是 中的幺元。定义： Ker(h) = \\{ x | x \\in G \\wedge h(x) = e_{H}\\}称 为群同态映射 的核，简称 的同态核。 是 的子群。 循环群同态性质设 是一个循环群，其生成元为 。 若 是无限集，则 与 同构。 若 是有限集且其阶为 , 则 与 同构。 6.7.7 陪集设 是群 的一个子群。 左陪集：，集合 ，称为由 确定的 在 中的左陪集。元素 称为左陪集 的代表元素。 陪集的性质 设 是群 的一个子群， 和 是其任意两个左陪集。 或 。 。 设 是群 的一个子群，， 是由 确定的 在 中的左陪集。则 当且仅当 。 6.7.8 拉格朗日定理设 是群 的一个子群，则： 是 中的等价关系，且有 。 若 是有限群，，，则 （即子群的阶是原群的阶的因子）。 拉格朗日定理的推论 任何质数阶的群没有非平凡子群。 设 是 阶有限群，则 ， 的阶数必定是 的因子，且 （注意群的阶和元素的阶的区别）。 一个质数阶的群必定是循环群，且任何与幺元不同的元素均可作为生成元。","link":"/2023/11/21/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0-6-7-%E7%BE%A4/"},{"title":"数据库系统笔记 - chap6 - 关系数据理论","text":"6.2 规范化6.2.1 函数依赖（Functional Dependencies, FD）设 是属性集 上的关系模式， 和 都是 的子集。若对于 的任意一个可能的关系 ， 中不可能存在两个元组在 上的属性值相同，而在 上的属性值不等，则称函数 依赖于函数 。记作 。 完全函数依赖在 中，若 ，并且对于 的任何一个真子集 ，都有 , 则称 对 完全函数依赖 ，记作 。 部分函数依赖在 中，若 ，但 不完全函数依赖于 ，则称 对 部分函数依赖 ，记作 。 传递函数依赖在 中，若 ，，，则称 对 传递函数依赖，记作 传递。 e.g.1. 是完全函数依赖， 是部分函数依赖。由于 且 ，则 传递。 6.2.2 码候选码（candidate key）：设 为 中的属性或属性组合，若 ，则称 为 的候选码。 超码（surpkey）：若 部分函数依赖于 ，即 ，则称 为 的超码。候选码是最小的超码，即 的任意一个真子集都不是候选码。 主码（primary key）：若关系模式 有多个候选码，则选定其中的一个为主码。 主属性（prime attribute）：包含在任何一个候选码中的属性称为主属性，不包含在任何候选码中的属性称为非主属性。 外码（foreign key）：关系模式 中属性或属性组 并非 的码，但其是另一个关系模式的码，则称 是 的外码。 6.2.3 范式 &amp; 1NF范式是符合某一种级别的关系模式的集合，满足最低要求的叫第一范式，简称 1NF。 一个低一级范式的关系模式，通过模式分解（schema decomposition）可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化（normalization）。 6.2.4 2NF若关系模式 1NF，且每一个非主属性完全函数依赖于任何一个候选码，则 2NF。 e.g.2. S-L-C (Sno, Sdept, Sloc, Cno, Grade)，Sloc 为学生的住处，并且每个系的学生住在同一个地方。S-L-C 的码为 (Sno,Cno)。函数依赖如下图（用虚线表示部分函数依赖）： 由图，非主属性 Sdept、Sloc 并不完全函数依赖于码，因此 S-L-C 2NF。解决的办法是用投影分解把关系模式 S-L-C 分解成两个关系模式：SC(Sno,Cno,Grade) 和 S-L(Sno,Sdept,Sloc)。SC 的码为 (Sno,Cno)，S-L 的码为 Sno，这样就使得非主属性对码都是完全函数依赖了。 6.2.5 3NF设关系模式 1NF，若 中不存在这样的码 ，属性组 及非主属性 使得 成立，，则称 3NF。 在 6.2.4 的最后一张图中，关系模式 SC 没有传递依赖，关系模式 S-L 存在非主属性对码的传递依赖。因此 SC 3NF，S-L 3NF。 解决的办法是将 S-L 分解成 S-D(Sno,Sdept) 3NF 和 D-L(Sdept,Sloc) 3NF。分解后的关系模式 S-D 与 D-L 中不再存在传递依赖。 判断 3NF ：关系模式中没有属性对码函数传递依赖或函数部分依赖。 6.2.6 BCNF设关系模式 1NF，若 时 必含有码，则 BCNF。 换言之：关系模式 中，若每一个决定因素都包含码，则 BCNF。 6.2.7 多值依赖6.2.8 4NF6.2.9 规范化小结 在关系数据库中，对关系模式的基本要求是满足第一范式。 规范化程度过低的关系不一定能够很好地描述现实世界，可能存在插入异常、删除异常、修改复杂、数据冗余等问题。解决方法就是对其进行规范化，转换成高级范式。 一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式集合，这种过程就叫关系模式的规范化。 关系数据库的规范化理论是数据库逻辑设计的工具。 6.3 数据依赖的公理系统设关系模式 ， 是其属性集 上的函数依赖集。对于其中的任何一个关系 ，若函数依赖 都成立，则称 逻辑蕴含 ，也称 为 所蕴含。 6.3.1 Armstrong 公理系统设关系模式 ， 是其属性集 上的函数依赖集。于是有关系模式 有以下的推理规则： A1 自反律（reflexivity rule）：若 ，则 为 所蕴含。 A2 增广律（augmentation rule）：若 为 所蕴含，且 ，则 为 所蕴含（ 表示 ）。 A3 传递律（transitivity rule）：若 及 为 所蕴含，则 为 所蕴含。 根据 A1, A2, A3 这三条推理规则可以得到三条新的推理规则： 合并规则（union rule）：若 且 ，则 。 分解规则（decomposition rule）：若 且 ，则 。 伪传递规则（pseudo transitivity rule）：若 且 ，则 。 定理： 成立的充分必要条件是 成立。 函数依赖集的闭包","link":"/2023/11/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-chap6-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/"},{"title":"抽象代数笔记 - 6.6 - 半群与独异点","text":"6.6 半群与独异点6.6.1 半群与子半群半群：对于一个代数系统 ， 是 上的二元运算，若运算 是可结合的，则称 为半群。 子半群：设 是一个半群， 且 在 上是封闭的，那么 是 的子代数。 也是一个半群，称为 的子半群（因为结合律在子代数上可继承）。 6.6.2 独异点与子独异点独异点：含有幺元的半群。 子独异点：满足是原代数系统的子代数（封闭性），本身是独异点（含幺），且在相同运算下与原代数系统有相同幺元，那么称为是原独异点的子独异点。 6.6.3 半群与独异点的等幂元性质设 是一个半群，若 是一个有限集，则必存在 ，使得 。证明：结合鸽巢原理。 6.6.4 交换半群与循环独异点交换半群（独异点）：在半群（独异点）中，若运算是可交换的，则称此半群（独异点）为交换半群（独异点）。 循环独异点：设 是一个独异点，若 ，则 使得 （ 是 个 做运算的意思，任何元素的零次幂等于幺元 ），则称此独异点为循环独异点（存在一个数能把其他所有数都表示出来）。 称为该循环独异点的生成元，一个循环独异点的生成元个数可以不唯一。","link":"/2023/11/14/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0-6-6-%E5%8D%8A%E7%BE%A4%E4%B8%8E%E7%8B%AC%E5%BC%82%E7%82%B9/"},{"title":"抽象代数笔记 - 6.5 - 商代数","text":"6.5 商代数6.5.1 商代数的定义与性质设代数系统 ， 是 上的同余关系。则称 关于 的商代数 。其中 。 是集合的集合，即等价类的集合。该集合是 的一个划分，即该集合中任意两元素（集合）的交集是空集（因为等价具有传递性）。 是集合间的运算， 是代数常元的集合。 小结：由等价关系 可以得到代数系统 的载体的一个划分，以这个划分为新的载体，按照原运算的规则建立等价类之间新的运算，这样得到的代数系统是原代数系统的商代数。","link":"/2023/11/07/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0-6-5-%E5%95%86%E4%BB%A3%E6%95%B0/"},{"title":"抽象代数笔记 - 6.4 - 同余","text":"6.4 同余6.4.1 同余的定义设代数系统 ， 是载体 上的等价关系。 ： 当 时，若 ，则说明等价关系在一元运算 下是可保持的，称 是关于运算 的同余关系。 当 时，若 ，则说明等价关系在二元运算 下是可保持的，称 是关于运算 的同余关系。 若 在 上的所有运算下都是可保持的，则称 是代数系统 上的同余关系。 等价关系具有对称性、自反性、传递性。 6.4.2 与同态有关的定理设 是从 到 的一个同态映射。若在 上定义等价关系 ： \\langle a, b \\rangle \\in R, \\quad iff: g(a) = g(b)则 是 上的一个同余关系。","link":"/2023/11/06/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0-6-4-%E5%90%8C%E4%BD%99/"},{"title":"抽象代数笔记 - 6.3 - 同态","text":"6.3 同态6.3.1 同态的定义设 两个具有相同构成的代数系统， 是从 到 的一个映射， 且对 满足（先运算再映射 = 先映射再运算）： f(a\\ast b) = f(a) \\ast'f(b) \\\\ f(\\varDelta a) = \\varDelta'f(a) \\\\ f(k) = k'则称 为由 到 的一个同态映射， 简称同态， 记作 。 6.3.2 同态象设 是从 到 的同态映射，称 为 在映射 下的同态象。 6.3.3 同态的分类设 是从 到 的一个映射。 满射：若 中每个值都能在 中找到其原象，则称 是一个满射。 单射：若 ，都有 。则称 是一个单射。 双射：既是满射又是双射的映射。 设 是从 到 的一个同态映射。 若 是满射的，则称 是一个满同态。 若 是单射的，则称 是一个单一同态。 若 是双射的，则称 是一个同构映射，简称同构，记作 。 若 ，则称 为 上的自同态。 若 且 是双射的，则称 为 上的自同构。 6.3.4 同态的性质设 是从 到 的一个同态映射。那么 的同态象 。 是 的子代数。 若 在 中可交换（可结合），则 在 中也可交换（可结合）。 若在 中 对 可分配，则在 中 对 也可分配。 若 是 中关于运算 的幺元，则 也是 中关于运算 的幺元。 若 是 中关于运算 的零元，则 也是 中关于运算 的零元。 , 对运算 存在逆元 ；则在 中， 也有关于运算 的逆元 。","link":"/2023/11/05/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0-6-3-%E5%90%8C%E6%80%81/"},{"title":"抽象代数笔记 - 6.2 - 子代数","text":"6.2 子代数6.2.1 子代数的定义设 是一个代数系统， 分别是载体 上的二元运算和一元运算， 是代数常元。若： S' \\subseteq S \\\\ S' 对 \\ast 和 \\varDelta 均封闭 \\\\ k \\subseteq S'则称 是 的子代数系统。若 ， 被称为 的最大的子代数。若 ， 被称为 的最小的子代数。最大和最小子代数被称为 的平凡子代数。其余的子代数（）被称为 的真子代数。","link":"/2023/11/04/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0-6-2-%E5%AD%90%E4%BB%A3%E6%95%B0/"},{"title":"抽象代数笔记 - 6.1 - 代数结构","text":"6.1 代数结构代数系统（代数）：非空集合 和 上的 个一元或二元运算 组成的系统。记作 。 6.1.1 代数运算设 是非空集合， 是从 到 的一个映射，则称 为集合 到 的一个 元代数运算。（其中 称作该运算的阶）。 等这些符号加上 普通 的前缀，才代表的是其原来的运算。 运算的封闭性设 为集合 到 的一个 元运算。若 ,则称 在集合 上是封闭的。e.g. 普通减运算在 上不封闭。 若称一个运算是某个集合上的运算，则该运算必须满足在这个集合上具有封闭性。 1. 运算性质 - 交换律设 为 上的二元运算，若 都有： x \\ast y = y \\ast x则称运算 在 上可交换。若已知该运算的运算表，则可通过判断该表是否满足沿主对角线对称，来判断是否满足交换律。 2. 运算性质 - 结合律设 为 上的二元运算，若 都有: (x \\ast y) \\ast z = x \\ast (y \\ast z)则称运算 在 上可结合。判断该运算是否满足结合律，不能通过运算表直观的看出来。 3. 运算性质 - 分配律设 为 上的二元运算，若 都有： x \\ast (y \\circ z) = (x \\ast y) \\circ (x \\ast z), \\quad 称 \\ast 对 \\circ 左可分配 \\\\ (y \\circ z) \\ast x = (y \\ast x) \\circ (z \\ast x), \\quad 称 \\circ 对 \\ast 右可分配则称 对 可分配。 4. 运算性质 - 吸收律设 为 上的二元运算，若 都有： x \\ast (x \\circ y) = x, \\quad 称 \\ast 对 \\circ 左可吸收 \\\\ (x \\circ y) \\ast x = x, \\quad 称 \\circ 对 \\ast 右可吸收则称 对 可吸收。若 满足交换律，则只需证明一边满足吸收律即可。e.g. 集合中的 运算对 运算可吸收。因为 （右可吸收同理）。 5. 运算性质 - 等幂律设 为 上的二元运算，若 都有: x \\ast x = x则称运算 在 上满足等幂律。 6. 运算性质 - 消去律设 为 上的二元运算，某个元素 ，若 都有： a \\ast x = a \\ast y \\ \\Rightarrow x = y, \\quad 称a是左可消去的 \\\\ x \\ast a = y \\ast a \\ \\Rightarrow x = y, \\quad 称a是右可消去的则称 关于 运算 是可消去的。若 中所有的元素都满足消去律，则可说明 满足消去律。 叫做永真蕴含式。箭头左边的式子叫做前件，右边的叫做后件。永真蕴含式表明，若前件成立，则后件一定成立。永真蕴含式的逆否形式也成立。 可消去性可以从运算表中观察到。若 满足消去律，则运算表中每一行每一列中都没有相同的元素。 6.1.2 代数常元该代数系统中与运算相关的特殊元素称作代数常元。 1. 幺元设 是定义在 上的二元运算，若存在元素 (或 ) 使得 都有： e_l \\ast x = x \\quad （或 \\ x \\ast e_r = x）则称 (或 ) 是 中关于 运算的左（右）幺元。若 既是左幺元又是右幺元，则称 是 中关于 运算的幺元。且 是 上关于 的唯一的幺元。 2. 零元设 是定义在 上的二元运算，若存在元素 (或 ) 使得 都有： \\theta_l \\ast x = \\theta_l \\quad （或 \\ x \\ast \\theta_r = \\theta_r）则称 (或 ) 是 中关于 运算的左（右）零元。若 既是左零元又是右零元，则称 是 中关于 运算的零元。且 是 上关于 的唯一的零元。 3. 逆元设 是定义在 上的二元运算， 是 中关于 运算的幺元。对于 , 如果存在 （或 ）使得： y_l \\ast x = e \\quad （或 \\ x \\ast y_r = e）则称 (或 ) 是 的左（右）逆元。若 既是左逆元又是右逆元，则称 是 的逆元。 零元不存在逆元。 若 运算是可结合的，且对于 存在 ，则 是 的唯一的逆元, 。","link":"/2023/11/03/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0-6-1-%E4%BB%A3%E6%95%B0%E7%BB%93%E6%9E%84/"},{"title":"杜文亮深度实践笔记 - chap4 - 缓冲区溢出攻击","text":"4.1 程序的内存布局程序运行时需要在内存中存放数据。对于一个 语言程序，它的内存由 个段组成： 代码段（text segment）：存放程序的可执行代码，这一内存块通常是只读（Read Only）的。 数据段（data segment）：存放由程序员初始化的静态（static）/全局（global）变量。 BSS 段（BSS segment）：存放未初始化的静态/全局变量。 会把未初始化的变量初始化为 。 堆（heap）：用于动态内存分配，由 malloc(), free()等函数控制。 栈（stack）：存放函数内定义的局部变量，以及和函数调用有关的数据。 4.2 栈与函数调用4.2.1 栈的内存布局当程序中的函数被调用时，需要在栈中为该函数分配一些空间来存储数据，进而执行该函数。 12345void calc(int a, int b) { int x, y; // local variable x = a + b; y = a - b;} 当 calc() 被调用时， 会在栈顶为该函数分配一块内存空间，称作栈帧（stack frame）。栈帧的布局如下： 参数：保存给函数传递的参数。顺序是按照相反的顺序存储的。 返回地址：函数结束后需要返回，返回地址区域存储的是函数调用指令的下一条指令的地址。 前帧指针： 局部变量：存放函数中用到的局部变量。 4.2.2 帧指针在运行函数的时候，肯定会用到函数中的参数和局部变量，所以需要知道他们在内存中的地址。但这些地址在编译的时候是无法确定的，因为编译器无法预测到栈在运行时的状态。所以在 CPU 中引入一个寄存器——帧指针，这个寄存器指向栈帧中的一个固定地址，因此其他参数和局部变量的地址可以通过帧指针加上一个偏移量计算出来。 在 x86 架构中，帧指针寄存器（ebp）总是指向前帧指针的地址。对 32 位体系结构而言，返回地址和帧指针各占 个字节，故 和 的实际地址是 和 。 之前介绍到的按照相反顺序存储的原因在这里也能得到解释：从偏移度的角度来看顺序不是反的，由于栈是从高端地址向低端地址增长的，若先把参数 压入栈中， 的偏移值将会高于 。在阅读汇编代码的时候反而会感到奇怪。 4.3 栈的缓冲区溢出攻击4.3.1 &amp; 4.3.2 数据复制与缓冲区溢出12345678910111213#include &lt;string.h&gt;void foo(char *str) { char buffer[12]; strcpy(buffer, str); // buffer overflow will appear after excuting this.}int main() { char *str = \"wo bu xin bie kai zhe zhong wan xiao wo bi 12 chang.\"; foo(str); return 0;} 在上面的代码中， foo() 中的局部变量 拥有 字节的内存，foo() 使用 strcpy() 从 复制数据到 （直到碰到 \\0 才停止执行）。由于 的长度比 字节大， 中未被复制完的数据将会被放到 。 若 之上的区域包含一些关键数据，若他们被修改了，则会引发一些未知的错误。 4.3.3 缓冲区溢出漏洞123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;void foo(char *str) { char buffer[100]; strcpy(buffer, str);}int main() { char str[400]; FILE *badfile = fopen(\"badfile\", \"r\"); fread(str, sizeof(char), 300, badfile); foo(str); return 0;} 上述程序将系统磁盘上的文件读入，该文件是用户可以自定义的，故带来了风险。","link":"/2023/11/03/%E6%9D%9C%E6%96%87%E4%BA%AE%E6%B7%B1%E5%BA%A6%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0-chap4-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/"},{"title":"微机原理笔记 - chap4 - 总线技术","text":"总线概述总线：计算机组件间、计算机间、计算机与设备间连接的信号线和通信的公共通路。 总线的驱动与控制总线竞争与负载总线竞争同一总线上，同一时刻，有两个或两个以上的器件输出其状态。此时总线上会是一种不高不低的非TTL电平，严重时会烧坏器件。特例：集电极开路/漏极开路输出，此时不会烧坏器件。非OC门，如何避免总线竞争：用三态电路，严格控制逻辑。 总线负载直流负载：如果驱动门输出高电平时，没有能力提供负载需要吸收的电流，会导致高电平电压高不上去；输出低电平时如果吸收电流的能力不够，会导致低电平电压低不下来。 总线驱动设计如果连接到总线上的模块很多，也就是总线的负载很重，就需要加驱动器。对于单向的总线控制信号，比如地址、读写控制信号，情况相对简单。双向数据总线如果要加驱动，稍有不慎就会引起总线竞争。 74LS244 可以当驱动器或者说缓冲器来用，它主要用来实现单向的总线信号驱动。 双向数据总线驱动器可以选择 74LS245 芯片实现，通过控制允许信号和方向控制信号来避免总线竞争。 e.g.1. 某内存板，板内地址为 A0000H～FFFFFH，试画出板内双向数据总线驱动与控制电路。 防止总线竞争原则：只有当 CPU 读本电路板内的内存地址时，才允许双向驱动器指向系统总线的三态门是导通的。 对板内内存地址进行分析，找出地址特征。 设计译码电路，用来控制双向数据总线驱动器，使之满足防止总线竞争原则。 e.g.2. 接口板板内接口地址为 5000H～7FFFH，试画出板内双向数据总线驱动与控制电路。 防止总线竞争原则：只有当 CPU 读本电路板内的内存地址时，才允许双向驱动器指向系统总线的三态门是导通的。同时要注意接口地址译码电路，需要增加一个 AEN ＝ 0 的条件（AEN=0：CPU，AEN=1：DMA）。 地址分析： 根据地址特征，画控制电路（利用 3-8 译码器译码）。 要考虑 的原因： 的时候， 的取值只有 一种，即 的地址是不合法的。故 也要参与译码。 e.g.3. 某微型机电路板上有内存 C0000H～EFFFFH 和接口 A000H～BFFFH，试画出该电路板板内双向数据总线驱动与控制电路。 防止总线竞争原则：只有当CPU读板内内存或读板内接口时，才允许双向数据驱动器指向系统总线的三态门是导通的。 地址分析（内存、接口）： 画驱动与控制电路：","link":"/2023/10/30/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0-chap4-%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF/"},{"title":"计算机组织与体系结构课程设计 - 实验报告","text":"一. 实验目的 深入理解基本模型计算机的功能、组成知识。 深入学习计算机各类典型指令的执行流程。 学习微程序控制器的设计过程和相关技术，掌握 LPM_ROM 的配置方法。 自己设计 5～8 条机器指令，并编写相应的微程序，上机调试，掌握计算机整机概念。掌握微程序的设计方法，学会编写二进制微指令代码表，全面了解并掌握微程序控制方式计算机的设计方法。 二. 实验原理实验中，计算机数据通路的控制将由微过程控制器来完成，CPU 从内存中取出一条机器指令到指令执行结束的一个指令周期，全部由微指令组成的序列来完成，即一条机器指令对应一个微程序。 为了向 RAM 中装入程序和数据，检查写入是否正确，并能启动程序执行，还必须设计三个控制台操作微程序。 存储器读操作（KRD）：下载实验程序后按总清除按键（CLR）后，控制台 SWA、SWB 为 “0 0” 时，可对 RAM 连续手动读操作。 存储器写操作（KWE）：下载实验程序后按总清除按键（CLR）后，控制台 SWA、SWB 为 “0 1” 时，可对 RAM 连续手动写操作。 启动程序（RP）：下载实验程序后按总清除按键（CLR）后，控制台 SWA、SWB 为 “1 1” 时，即可转入到微地址 “01” 号 “取指令” 微指令，启动程序运行。 设计指令说明 其中 IN 为单字长（8 位二进制），其余为双字长指令，XX H 为 addr 对应的十六进制地址码。 当全部微程序设计完毕后，应将每条微指令代码化，设计出二进制微代码表（前提是去弄懂每一位的含义）。笔者在设计的时候为了方便查看，在下表中将每个在相同模块里的微指令用相同的颜色进行了标识。 微程序流程图 三. 实验步骤（1）微程序的输入根据设计出来的二进制微代码表，将微指令按顺序放入 LPM_ROM 配置文件 ROM_5.mif 里。 （2）编辑RAM中的内容 （3）指令功能的验证 编译工程文件，将 .sof 文件上传至实验箱内。 按 1 次系统复位键 8 ，并置键 8 为高电平，使 CPU 允许正常工作。 控制开关（键 4 、键 3 ）设置为 SWB,SWA = 1,1 ，处于程序执行方式。 通过键 2 、键 1 输入运算数据，如 34H ，按 4 次单步键 7，产生 2 个脉冲，执行 2 条微指令，微程序流程进入到控制台的 RP(11) ，此时的微指令地址是 23，微指令码 MC = 008001，IN = 34H。 再用键 7 产生 1 个脉冲，执行 1 条微指令，微程序流程进入到 运行微程序 的最上块： 此时 PC = 00 送地址寄存器 AR = 00 ， PC 自动加 1 ，PC = 01， MC = 01ED82，IN = 34H。 键 7 产生 1 个脉冲，执行微指令 MC = 00C048，RAM 中的第一条指令码 00 进入BUS，再由 BUS 进入指令寄存器 IR = 00。键 7 再进 1 个脉冲，进入 MC = 001001，执行指令 IN，送数 IN -&gt; R0 = 34H。 键 7 产生 1 个脉冲，执行完 IN 指令后，返回到初始端，执行微指令 MC = 01ED82。 键 7 产生 2 个脉冲后，执行微指令 MC = 01ED83，即执行 SUB 指令的第 1 步：PC 送 AR = 02 ，PC + 1 = 03 ，这时 RAM 中在 02 地址的 0AH 进入 BUS = 0A。 键 7 产生 1 个脉冲，执行微指令 MC = 00E004 ，即执行 SUB 指令的第 2 步： BUS 数据送 AR = 0A，由于 0A 是 SUB 指令的加数的间接地址，而在地址 0A 中放有 01H，最后完成的减法是 34H - 01H = 33H。 键 7 产生 1 个脉冲，MC = 00B005 ，执行 SUB 的第 3 步：将 RAM 中 0A 地址的数据 01H 送 BUS ，再送 DR2 = 01H。注意，此时指令寄存器 IR 中仍放有 SUB 的操作码 10H， PC = 03 指向下一条指令 AND。 键 7 产生 1 个脉冲，MC = 01A206，执行 SUB 的第 4 步（微地址是 05）， R0 送 DR1 = 34H。 键 7 产生 1 个脉冲，MC = 619A01 ，执行 SUB 的最后一步，DR1 - DR2 = 33H，通过总线 BUS 送 R0 = 33H。 键 7 再产生 1 个脉冲，返回到初始端，执行微指令 MC = 01ED82。 键 7 产生 2 个脉冲，MC = 01ED95，执行 AND 指令；键 7 再 4 个脉冲后，位运算与的结果 33H &amp; 12H = 10H 被写入 R0 ，即 R0 = 10H 。键 7 产生 1 个脉冲后返回到初始端，执行微指令 MC = 01ED82。 键 7 产生 2 个脉冲，MC = 01ED99，执行 MOV 指令；键 7 再 2 个脉冲后， RAM 中地址为 0C 的数字 00H 被写入 DR2，即 DR2 = 00H 。键 7 产生 1 个脉冲后返回到初始端，执行微指令 MC = 01ED82。 键 7 产生 2 个脉冲，MC = 01A21B，执行 INC 指令；键 7 再 1 个脉冲后，R0 中的值加 1，即 R0 = 11H 。键 7 产生 1 个脉冲后返回到初始端，执行微指令 MC = 01ED82。 附：实验过程中的图片 四. 实验感想由于「计算机组织与体系结构」是上学期的课程，时隔将近 4 个月后再接触到相关的知识，有一种熟悉又陌生的感觉，当时学到的一些知识已经有所遗忘。所以笔者在设计指令之前，又对 CPU 、数据通路、总线等相关知识进行了回顾与复习。在这次漫长的设计实验以后，我对这方面的知识理解得以更加深刻。 设计指令并构造 24 位微代码是十分辛苦的，在设计第一条指令时花费了很长时间。随着自己对每一位的含义的越来越熟悉，同时也发现了不同指令在某些地方的相似之处，我明白了老师课前所提到的“开头设计指令很慢，之后会越来越快”的含义：有些指令有许多部分是很相似的，在代码上的不同很少，主要是会因为执行下一条指令的位置不同而不同。 同时当时自己为了设计方便，构建微代码表时基本把相同的指令用到的微操作都放在了一起，不断向微地址大的地方累加，这也造成了本人微代码表中会有空行的出现（详见下图），这也是我在实验中意识到自己不足的一个地方。 总的来说这次实验虽然辛苦，但是我收获颇丰。当理论与实际结合起来，并通过自己的努力验证了理论的正确性的时候，心中的激动和成就感是很足的。 最后感谢老师在实验中耐心的答疑与同伴在我出现问题时的“拔刀相助”。","link":"/2023/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"title":"算法分析与设计 - Lab2 - 排序算法的性能比较","text":"一. 实验目的实现插入排序（Insertion Sort，IS），自顶向下归并排序（Top-down Mergesort，TDM），自底向上归并排序（Bottom-up Mergesort，BUM），随机快速排序（Random Quicksort，RQ），Dijkstra 3-路划分快速排序（Quicksort with Dijkstra 3-way Partition，QD3P）。 二. 实验内容在计算机上针对不同输入规模数据进行实验，对比上述排序算法的时间及空间占用性能。要求对于每次输入运行 10 次，记录每次时间/空间占用，取平均值。 三. 实验过程首先需要明白实验中所需排序算法的基本原理。笔者在相同的实验环境下分别实现了这几种排序，尽量保证了实验结果不受环境所影响。 1. 插入排序（Insertion Sort，IS）该排序每次将一个元素放到序列中的正确位置，做法是与它前面的元素依次比较，直到找到正确的位置。 正确性证明显而易见：由于是从左往右依次处理每个位置的元素的，所以待排元素左边的子序列一定是单调的。 算法的时间复杂度为 ，但由于其排序利用的性质，插入排序在大量递增的数据面前能有较好的表现。 12345678910void IS() { for (int i = 1; i &lt; n; i++) { int x = a[i], j = i - 1; while (j &gt;= 0 &amp;&amp; a[j] &gt; x) { a[j + 1] = a[j]; j--; } a[j + 1] = x; }} 2. 自顶向下归并排序（Top-down Mergesort，TDM）由于大的序列排序问题可以分解为其子序列的排序子问题（分治法），故可以将目前的 区间划分为 和 ，递归处理。递归回溯过后的这两段区间一定是有序的，进而可以合并这两个子区间，来得到排序过后的 。 合并的方法即每次取这两个子序列中较小的那个数字，依次放到新的序列里。最后还需要把未放完的子序列中的数字集体放入新序列中。这样得到的新序列一定是有序的。 算法的时间复杂度为 ，是一种比较稳定且优秀的排序方法，并且还有一些应用（e.g. 计算某个序列中的逆序对个数）。 1234567891011121314void TDM(int l, int r) { if (l == r) return ; int mid = (l + r) / 2; TDM(l, mid); TDM(mid + 1, r); int i = l, j = mid + 1, k = l; while (i &lt;= mid &amp;&amp; j &lt;= r) { if(a[i] &gt; a[j]) b[k++] = a[j++]; else b[k++] = a[i++]; } while (i &lt;= mid) b[k++] = a[i++]; while (j &lt;= r) b[k++] = a[j++]; for (int k = l; k &lt;= r; k++) a[k] = b[k];} 3. 自底向上归并排序（Bottom-up Mergesort，BUM）与 TDM 不同，我们也可以把小的有序序列们依次合并成大的有序序列，这样也可以实现整体的排序。元素的个数可以采用 的整数次幂，这样的子序列的长度也比较平均。 算法的时间复杂度为 。 12345678910111213141516171819202122void merge(int l, int mid, int r) { int n1 = mid - l + 1, n2 = r - mid; vector&lt;int&gt; b(n1 + 5), c(n2 + 5); for (int i = 1; i &lt;= n1; i++) b[i] = a[l + i - 1]; for (int i = 1; i &lt;= n2; i++) c[i] = a[mid + i]; int i = 1, j = 1, k = l; while (i &lt;= n1 &amp;&amp; j &lt;= n2) { if (b[i] &lt;= c[j]) a[k++] = b[i++]; else a[k++] = c[j++]; } while (i &lt;= n1) a[k++] = b[i++]; while (j &lt;= n2) a[k++] = c[j++];}void BUM() { for (int now = 1; now &lt;= n; now &lt;&lt;= 1) { for (int l = 1; l &lt;= n; l += 2 * now) { int mid = min(l + now - 1, n), r = min(l + 2 * now - 1, n); merge(l, mid, r); } }} 4. 随机快速排序（Random Quicksort，RQ）快速排序与归并排序（Merge Sort）一样，采用了分治的思想，在每次处理区间的时候，选取一个基准值 ，让 左边所有数字都小于它本身，让 右边所有数字都大于它本身。然后再去递归基准值左右两边的区间。 不难发现排序的快慢会受到 选取策略的影响。随机的去选择 可以让排序的效率不被输入数据的顺序、大小的特点而明显影响到。 算法的时间复杂度为 。 123456789101112131415void RQ(int l, int r) { if(l &gt;= r) return ; int i = l, j = r, pivot = a[l + rand() % (r - l + 1)]; while(i &lt;= j) { while(a[i] &lt; pivot) i++; while(a[j] &gt; pivot) j--; if(i &lt;= j) { swap(a[i], a[j]); i++; j--; } } RQ(l, j); RQ(i, r);} 5. Dijkstra 3-路划分快速排序（Quicksort with Dijkstra 3-way Partition，QD3P）QD3P 也使用了基准数 的概念，将数组分成三个部分：小于 的部分、等于 的部分和大于 的部分。然后递归地对这三个部分分别进行排序，以完成整个排序过程。在处理包含大量重复元素的数据时会展现出优秀的性能。 算法的时间复杂度为 。 123456789101112131415161718void QD3P(int l, int r) { if (l &gt;= r) return ; int lt = l, gt = r, i = l + 1, pivot = a[l]; while (i &lt;= gt) { if (a[i] &lt; pivot) { swap(a[lt], a[i]); lt++; i++; } else if (a[i] &gt; pivot) { swap(a[i], a[gt]); gt--; } else i++; } QD3P(l, lt - 1); QD3P(gt + 1, r);} 测量时间与空间占用量笔者在此次实验中采用了线上评测系统来更方便的去测试不同排序程序在不同规模数据下的性能表现。即先在本地通过数据生成器，将不同规模、不同特点的数据打包上传至评测系统的服务器，再将各个排序的程序分别提交，查看运行时候的时间、空间占用量。 本次线上评测系统选择的是洛谷平台，洛谷平台为用户提供了「创建题目」以及「提交测评」的功能。 评测结果界面： 以下是用于此次评测的题目的相关信息： 本地的数据生成器（generator.cpp）代码： 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int a[20050];void solve1() { for (int i = 1; i &lt;= n; i++) cout &lt;&lt; rand() % 50 &lt;&lt; (i == n ? \"\\n\" : \" \");}// generate random datavoid solve2() { int m = 0; for (int i = 1; i &lt;= n; i++) { int x = rand() % 100; a[++m] = x; } sort(a + 1, a + m + 1); for (int i = 1; i &lt;= m; i++) cout &lt;&lt; a[i] &lt;&lt; (i == m ? \"\\n\" : \" \");} //generate data which has been sortedint main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); srand(time(0)); // for random data freopen(\"sort.in\", \"w\", stdout); // write the generated data in the file int n = 20000, type; // set the number of data cout &lt;&lt; n &lt;&lt; endl; cin &gt;&gt; type; type ? solve1() : solve2(); // choose different kinds of data return 0;} 本地的排序过后（sort.cpp）的数据生成器： 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int n, a[20050];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"sort0.in\", \"r\", stdin); freopen(\"sort0.out\", \"w\", stdout); // generate the right answer after sorting cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; sort (a + 1, a + n + 1); for (int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; (i == n ? \"\\n\" : \" \"); return 0;} 运用线上评测的优势是方便查看时间、空间的占用量，并且能够检测程序的正确性。缺点是显示精度取决于评测提供方，结果可能不够精确。 四. 结果分析1. 大量有序数据（N = 20000）时间占用（单位：）： 空间占用（单位：）： 2. 大量重复数据（N = 20000）时间占用（单位：）： 空间占用（单位：）： 3. 大量随机数据（N = 20000）时间占用（单位：）： 空间占用（单位：）： 4. 少量随机数据（N = 1000）时间占用（单位：）： 空间占用（单位：）： 五. 问题回答 Which sort worked best on data in constant or increasing order (i.e., already sorted data)? Why do you think this sort worked best? (1). Insertion Sort. In the first test, Insertion Sort solves the problem the fastest. (2). This is because when the sequence is already sorted, everytime we want to arrange this element to its right position, we can add it to the final sequence directly. Its time complexity turns to . Did the same sort do well on the case of mostly sorted data? Why or why not? (1). For Insertion Sort, it runs much more faster than it runs on the random situation. The reason why has been explained in last question. (2). For QD3P, it runs much more slower than it runs on the mostly repeated situation. In general, did the ordering of the incoming data affect the performance of the sorting algorithms? Please answer this question by referencing specific data from your table to support your answer. (1). Yes. (2). For QD3P, when the data is generated randomly, the cost of time is much more shorter than it runs on sorted data. Which sort did best on the shorter (i.e., n = 1,000) data sets? Did the same one do better on the longer (i.e., n = 100,000) data sets? Why or why not? Please use specific data from your table to support your answer. (1). When is not very large (e.g. n = 1000), different algorithms takes almost same time to sort. (2). When is very large, which algorithm works best depends on whether the data is already sorted and the number of repeated number in the data set. Theoretically speaking, QD3P works best in most condition, especially when there are many repeated elements in the data set. But there are also some speical cases. In general, which sort did better? Give a hypothesis as to why the difference in performance exists. (1). QD3P works best in most condition. (2). The performance depends on many aspects, including the size of data, whether the sequence is already sorted, and whether it will use the space of system stack and so on. Are there results in your table that seem to be inconsistent? (e.g., If I get run times for a sort that look like this {1.3, 1.5, 1.6, 7.0, 1.2, 1.6, 1.4, 1.8, 2.0, 1.5} the 7.0 entry is not consistent with the rest). Why do you think this happened? (1). I think it is related to the data and system environment.","link":"/2023/10/27/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-Lab2-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E9%AA%8C%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"},{"title":"算法分析与设计 - Lab1 - 渗透问题","text":"一．实验目的使用并查集(union-find)数据结构，编写程序通过蒙特卡罗模拟(Monte Carlo simulation)来估计渗透阈值。 二．实验内容给定由随机分布的绝缘材料和金属材料构成的组合系统:金属材料占多大比例才能使组合系统成为电导体? 给定一个表面有水的多孔景观(或下面有油)，水将在什么条件下能够通过底部排出(或油渗透到表面)? 科学家已经定义了一个称为渗透(percolation)的抽象过程来模拟这种现象。 我们使用 网格点来模型化一个渗透系统。 每个格点或是 open 格点或是 blocked 格点。 一个 full site 是一个 open 格点，它可以通过一系列的邻近(左、右、上、下) open 格点连通到顶行的一个 open 格点。如果在底行中有一个 full site 格点，则称系统是渗透的。(对于绝缘/金属材料的例子，open 格点对应于金属材料，渗透系统有一条从顶行到底行的金属材料路径，且 full sites 格点导电。对于多孔物质示例，open 格点对应于空格，水可能流过，从而渗透系统使水充满 open 格点，自顶向下流动。) 在一个著名的科学问题中，研究人员对以下问题感兴趣:如果将格点以概率 独立地设置为 open 格点(因此以概率 被设置为 blocked 格点)，系统渗透的概率是多少? 当 时，系统不会渗出; 当 时，系统渗透。下图显示了 随机网格（左）和 随机网格（右）的格点空置概率 与渗滤概率。 当 足够大时，存在阈值 ，使得当 ，随机 网格几乎不会渗透，并且当 时，随机 网格几乎总是渗透。尚未得出用于确定渗滤阈值 的数学解。你的任务是编写一个计算机程序来估计 。 蒙特卡洛模拟(Monte Carlo simulation). 要估计渗透阈值，考虑以下计算实验: 初始化所有格点为 blocked。 重复以下操作直到系统渗出:2.1. 在所有 blocked 的格点之间随机均匀选择一个格点 。2.2. 设置这个格点 为 open 格点。 open 格点的比例提供了系统渗透时渗透阈值的一个估计。例如，如果在 的网格中，根据以下快照的 open 格点数，那么对渗滤阈值的估计是 ， 因为当第 个格点被 open 时系统渗透。 通过重复该计算实验 次并对结果求平均值，我们获得了更准确的渗滤阈值估计。 令是第 次计算实验中 open 格点所占比例。样本均值提供渗滤阈值的一个估计值; 样本标准差测量阈值的灵敏性。 \\mu = \\frac{\\sum_{i = 1}^{T}x_i}{T}, \\quad \\sigma^2 = \\frac{\\sum_{i = 1}^{T}(x_i - \\mu) ^ 2}{T - 1}假设 足够大，以下为渗滤阈值提供 置信区间: [\\mu - \\frac{1.96 \\sigma}{\\sqrt{T}}, \\mu + \\frac{1.96 \\sigma}{\\sqrt{T}}]三．实验过程并查集根据题意，在实验中，可以把首行中的 个点由一个特殊点（编号为 ）来代替。即在并查集的初始化过程中，把第一行的 个点都指向 号点。最后一行也同理。 如何给 个点编号？可以采用“先行后列，同时新的一行的第一个点保留”的方法来排号。“保留”的目的是我们需要把第一行、最后一行（第 行）的所有点都分别指向对应的特殊点。采用这种方法，可以很方便的通过某个点的行号 和列号 ，推导出其在这种方式下的真正编号。不难得出， 的真正编号为 。第一行的点全被指向 号点，第 行的所有点全被指向 号点，其余所有点最开始都指向自己。 同时本人在并查集中采用了路径压缩、按秩合并的技巧，减少了算法的时间复杂度。 该部分的源代码如下： 1234567891011121314151617181920212223242526272829303132333435363738int get_id(int i, int j) { return 1 + (i - 1) * (N + 1) + (j - 1); }struct union_find_set { int fa[MAXN * MAXN], rk[MAXN * MAXN]; int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); } // path compression bool connected(int x, int y) { return find(x) == find(y); } void initial() { for (int i = 1; i &lt;= N; i++) { for (int j = 1; j &lt;= N; j++) { int id = get_id(i, j); fa[id] = id; rk[id] = 1; if (i == 1 || i == N) fa[id] -= j; } } fa[top_id] = top_id; fa[bottom_id] = bottom_id; rk[top_id] = rk[bottom_id] = 2; } void unite(int x, int y) { int fx = find(x), fy = find(y); if (fx == fy) return ; if (rk[fx] &lt; rk[fy]) fa[fx] = fy; else { fa[fy] = fx; if (rk[fx] == rk[fy]) rk[fx]++; } } // weighted quick-union}s1; 注意到实验中还需要分析不带按秩合并的并查集在运行相同规模数据时候的表现，只需要在上述代码中的 initial 和 unite 部分中去除与 rk 有关的代码即可（ unite 中直接合并）。在这里不再赘述。 Percolations 与 PercolationStats 类结合题意，本人用 struct 创建了对应的数据类型及接口。 Percolations 部分的源代码： 1234567891011121314151617181920212223242526struct Percolations { struct node { int id, sta; }a[MAXN][MAXN]; bool isOpen(int i, int j) { return a[i][j].sta; } // is site (row i, column j) open? void open(int i, int j) { a[i][j].sta = 1; } // open site (row i, column j) if it is not already bool percolates() { return s1.connected(top_id, bottom_id); } // does the system percolate? void Percolation(int N) { for (int i = 1; i &lt;= N; i++) { for (int j = 1; j &lt;= N; j++) { a[i][j].sta = 0; a[i][j].id = get_id(i, j); } } } // create N-by-N grid, with all sites blocked}now; PercolationStats 部分的源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869struct PercolationStats { const int dirx[5] = {0, 0, 0, 1, -1}; const int diry[5] = {0, 1, -1, 0, 0}; double res, ave, sigma, sigma_squ; std::vector&lt;double&gt; esti_p; bool check_out(int i, int j) { return i &lt; 1 || j &lt; 1 || i &gt; N || j &gt; N; } // check whether (i, j) is out of the grid double mean() { return res / T; } // sample mean of percolation threshold double variance() { double val = 0; for (auto x : esti_p) val += pow((x - ave), 2); return val / (T - 1); } // sample variance of percolation threshold double stddev() { return sqrt(sigma_squ); } // sample standard deviation of percolation threshold double confidenceLo() { return ave - (1.96 * sigma) / sqrt(T); } // returns lower bound of the 95% confidence interval double confidenceHi() { return ave + (1.96 * sigma) / sqrt(T); } // returns upper bound of the 95% confidence interval void PercolationStat(int N, int T) { for (int k = 1; k &lt;= T; k++) { now.Percolation(N); s1.initial(); int cnt = 0; while (!now.percolates()) { int nx = rand() % N + 1, ny = rand() % N + 1; if (!now.isOpen(nx, ny)) { cnt++; now.open(nx, ny); } for (int i = 1; i &lt;= 4; i++) { int dx = nx + dirx[i], dy = ny + diry[i]; if (check_out(dx, dy)) continue; if (now.isOpen(dx, dy)) { int idu = get_id(dx, dy), idv = get_id(nx, ny); s1.unite(idu, idv); } } } double nowp = 1.0 * cnt / (N * N); esti_p.push_back(nowp); res += nowp; } } // perform T independent computational experiments on an N-by-N void Calculation() { ave = mean(); sigma_squ = variance(); sigma = stddev(); std::cout &lt;&lt; \"mean = \" &lt;&lt; ave &lt;&lt; \"\\n\"; std::cout &lt;&lt; \"stddev = \" &lt;&lt; sigma &lt;&lt; \"\\n\"; std::cout &lt;&lt; \"95% confidence interval is [\" &lt;&lt; confidenceLo() &lt;&lt; \", \" &lt;&lt; confi denceHi() &lt;&lt; \"]\" &lt;&lt; \"\\n\"; } // calculate the mean, stddev, and the confidence interval of this experiment}lab; 四. 结果分析quick-find 运行表现N = 200, T = 100: N = 2, T = 100000: N = 300, T = 500: weighted quick-find 运行表现N = 200, T = 100: N = 2, T = 100000: N = 300, T = 500: 不难发现在较大规模数据的时候，按秩合并优化对程序时间的减少效果是明显的。","link":"/2023/10/26/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-Lab1-%E6%B8%97%E9%80%8F%E9%97%AE%E9%A2%98/"},{"title":"微机原理笔记 - chap3 - Intel处理器指令系统及汇编语言","text":"汇编语言基础数据定义： 数据传送、算术运算、跳转指令MOV 指令“先目的操作数，再源操作数。” MOV 指令需要遵循的规则： 两个操作数的尺寸必须一致。 两个操作数不能同时为内存操作数。 1234567mov reg, regmov mem, regmov reg, memmov mem, immmov reg, immmov var2, var1 ;不合法，需要用寄存器来实现 目的操作数不能是 CS，EIP 和 IP。 立即数不能直接送至段寄存器。 XCHG 指令用来交换两个操作数的内容。 123xchg reg, regxchg reg, memxchg mem, reg 若要交换两个内存操作数，还是需要利用寄存器，即 MOV 与 XCHG 结合使用。 INC 和 DEC 指令分别实现加 1 与减 1 操作。 12inc reg/memdec reg/mem ADD 和 SUB 指令ADD 将同尺寸的源操作数和目的操作数相加，结果在目的操作数中（不改变源操作数）。 SUB 将源操作数从目的操作数中减掉，结果在目的操作数中（不改变源操作数） 两者都同 MOV 指令一样，先目的操作数，再源操作数。 1234567.datavar1 DWORD 20000hvar2 DWORD 10000h.codemov eax, var1add eax, var2 ;30000hsub eax, var2 ;20000h NEG 指令认为操作数是有符号数，形式是补码。该指令将操作数按位取反、末位加 1。 算术运算影响的标志 零标志位 ZF 12345mov cx, 1sub cx, 1 ; ZF = 1mov ax, 0FFFFh ; 全1理解成补码，真值就是-1inc ax ; ZF = 1inc ax ; ZF = 0 符号标志位 SF 123mov cx,0sub cx,1 ; SF = 1add cx,2 ; SF = 0 进位标志位 CF 1234567891011mov al,0FFhadd al,1 ; CF = 1mov ax,00FFhadd ax,1 ; CF = 0mov ax,0FFFFhadd ax,1 ; CF = 1mov al,1sub al,2 ; CF = 1。最高位向更高位有进位或借位时置1 溢出标识位 OF 其中 是符号位产生的进位，即标志位 CF； 是最高有效位向符号位产生的进位。 1234567891011mov al,+127add al,1 ; OF = 1mov al,-128sub al,1 ; OF = 1mov al,-128 ; AL = 10000000bneg al ; AL = 10000000b, OF = 1mov al,+127 ; AL = 01111111bneg al ; AL = 10000001b, OF = 1 JMP 和 LOOP 指令JMP ：无条件转移 12345top: jmp top ;repeat the endless loop LOOP ：条件转移 1234567mov ax,0mov ecx,5L1: inc axloop L1;循环体的第一条指令必须要给标号。循环体的最后一条指令要用loop，后面跟这个标号 ;循环结束时，AX=5 ECX=0 过程 条件处理AND 指令 与 OR 指令1AND / OR 目的操作数 源操作数 两个操作数可以是8、16 或 32位的，但它们的尺寸必须相同。影响的标志位：总是清除 OF 和 CF，根据结果修改 SF、ZF、PF。 AND 指令应用： OR 指令应用： NOT 指令将操作数所有数据位取反，结果为反码。 12mov al,11110000bnot al ; AL = 00001111b 条件跳转指令 整数算数指令移位指令 乘法和除法指令 字符串和数组基址变址 (base-index) 操作数：将两个寄存器的值相加(称为基址寄存器、变址寄存器)来产生偏移地址。保护模式程序中，可使用任意32位通用寄存器。 宏 使用I/O端口控制硬件x86属于独立编址，要访问接口地址空间只能用 IN 指令 和 OUT 指令。不管是8086还是32位、64位的CPU，接口地址都是16位的，端口地址范围为0~FFFFh。 32/64位处理器扩展指令 —— 多媒体/流媒体SIMD扩展指令集Pentium II：引入 MMX 指令集，实现64位并行处理。Pentium III：引入 SSE 指令集，实现128位并行浮点运算。Pentium 4：引入 SSE2 指令集，实现128位并行定点运算。","link":"/2023/10/19/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0-chap3-Intel%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8F%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"title":"微机原理笔记 - chap2 - Intel单核&#x2F;多核处理器","text":"单核处理器（8086/8088）8086/8088 功能特性第一次将流水线思想引进微处理器：指令级流水。存储器分段管理机制引入处理器，扩大寻址能力。 内存地址分段：寄存器最多存 16 位，故有些寄存器用来当段寄存器，代表着地址的高 16 位（低 4 位默认为 0 ）。再加上段内偏移寄存器的值（低 16 位），就可以实现 1MB 的内存寻址。 接口数量不会很多，所以地址不用分段。 8086/8088 体系结构 地址加法器的意义：避免结构冒险，保证计算地址和计算数据可以并行。 总线接口单元 BIU ：与存储器、IO接口相连；取指令，取数据，送数据。执行单元 EU ：执行指令。BIU 与 EU 相互独立，相互配合。 寄存器（16位） 在 14 个寄存器中，只有 A～DX 既可以当作 16 位寄存器，也可以当作 2 个 8 位寄存器。 除了当通用寄存器，BX 可以当作指针，用来寄存器间接寻址，即 [BX]。（ [AX], [CX], [DX] 都是不合法的写法） 访问堆栈的时候可以用 BP（基址指针寄存器）来间接寻址，读/写堆栈里面任何位置的数据，同时不会破坏栈的结构（不会影响栈顶当前的位置）。 SP、BP、SI、DI、IP 用来存段内偏移，CS、DS、SS、ES 用来存段起始地址的高16位。 指令指针寄存器（IP）：默认CS：IP。CX：LOOP指令实现循环时记录剩余循环次数。 标志寄存器（PSW/FLAGS） AF：辅助进位标志位，加法时若 向 有进位， AF 置 1 。CF：进位/借位标志位，若加法时最高位向更高位有进位或减法时最高位向更高位有借位， CF 置 1 。PF：奇偶标志位，若运算结果低八位中 1 的个数是偶数，PF 置 1 。SF：符号标志位，反映运算结果的最高位，最高位是什么 SF 就是什么。ZF：零标志位，若运算结果为 0 ， ZF 置 1 。OF：溢出标志位，若运算结果溢出， OF 置 1 。 8086/8088的主存结构 8088由于其总线数据线只有 8 根，故其是 8 位的，主存结构也较简单。 8086由于有时候也需要进行 8 位数据的读写，故采用奇偶地址分开的方法。 作为偶地址存储体的选择信号。 作为奇地址存储体的选择信号。 从偶地址开始读 16 位的数据只需要 1 个总线周期，而从奇地址开始读 16 位的数据则需要 2 个总线周期。故数据对齐是很重要的，对于 16 位的数据我们总是希望从偶地址开始存储。 8086 1MB 内存空间的使用情况 8086 最大最小模式","link":"/2023/10/19/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0-chap2-Intel%E5%8D%95%E6%A0%B8:%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/"},{"title":"微机原理笔记 - chap1 - 绪论","text":"Intel微处理器的发展 1978年：8086/8088微处理器出现，首枚16位微处理器。 微型计算机概述 计算机加电以后，首先运行 BIOS(Basic Input Output System) 系统，进行硬件的检查、初始化（加电时寄存器的内容是随机的）、给操作系统提供编程接口等。 通过硬件驱动程序、BIOS / UEFI 提供的编程接口，操作系统可以访问硬件。从而实现两台硬件层面不同的计算机可以安装相同的操作系统.","link":"/2023/10/19/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0-chap1-%E7%BB%AA%E8%AE%BA/"},{"title":"数据库系统笔记 - chap3 - SQL","text":"3.1 Introduction to SQLSQL（Structured Query Language），是关系数据库的标准查询语言。 SQL 的特点： 综合统一SQL 集数据定义语言（DDL），数据操纵语言（DML），数据控制语言 （DCL）功能于一体。 高度非过程化 SQL 只要提出“做什么”，而无须指明“怎么做”，因此无须了解存取路径。存取路径的选择以及 SQL 的操作过程由系统自动完成。 面向集合的操作方式SQL 采用集合操作方式，不仅操作对象、查找结果可以是元组的集合，而且一次插入、删除、更新操作的对象也可以是元组的集合。 以同一种语法结构提供多种使用方式 SQL 是独立的语言，能够独立地用于联机交互的使用方式。同时 SQL 也是嵌入式语言，能够嵌入到高级语言（例如 C，C++，Java）程序中，供程序员设计程序时使用。 在两种不同的方式下， SQL 的语法结构基本上是一致的。 支持 SQL 的关系数据库管理系统同样支持关系数据库三级模式结构，如下图所示。其中外模式包含若干视图（view）和部分基本表（base table），模式包括若干基本表，内模式包括若干存储文件（stored file）。 基本表是本身独立存在的表，在关系数据库管理系统中一个关系就对应一个基本表。一个或多个基本表对应一个存储文件，一个表可以带若干索引，索引也存放在存储文件中。 存储文件的逻辑结构组成了关系数据库的内模式。存储文件的物理结构对最终用户是隐蔽的。 视图是从一个或几个基本表导出的表。它本身不独立存储在数据库中，即数据库中只存放视图的定义而不存放视图对应的数据。这些数据仍存放在导出视图的基本表中，因此视图是一个虚表。视图在概念上与基本表等同，用户可以在视图上再定义视图。 3.3 数据定义CREATE 创建，DROP 删除，ALTER 修改（只有表和索引有这项）。 3.3.1 模式（SCHEMA）定义模式（CREATE SCHEMA）12CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;;/* 如果没有指定模式名，则模式名隐含为用户名 */ 为用户 CHEN 定义一个学生-课程模式 S-T。 1CREATE SCHEMA \"S-T\" AUTHORIZATION CHEN; 删除模式（DROP SCHEMA）1DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;; /* CASCADE 和 RESTRICT 两者必选其一 */ CASCADE（级联）：删除模式的同时把该模式中所有的数据库对象全部删除。RESTRICT（限制）：如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。仅当该模式中没有任何下属的对象时才能执行。 3.3.2 基本表（TABLE）定义基本表（CREATE TABLE） 建立一个学生信息表 Student。 1234567CREATE TABLE Student ( Sno CHAR(9) PRIMARY KEY, Sname CHAR(20) UNIQUE, Ssex CHAR(2), Sage SMALLINT， Sdept CHAR(20)); 建立一个学生选课表 SC 。 12345678CREATE TABLE SC ( Sno CHAR(9), Cno CHAR(4), Grade SMALLINT, PRIMARY KEY (Sno,Cno), /* 主码由两个属性构成，必须作为表级完整性进行定义 */ FOREIGN KEY (Sno) REFERENCES Student(Sno), /* 表级完整性约束条件 */ FOREIGN KEY (Cno) REFERENCES Course(Cno) /* 表级完整性约束条件 */); 如果完整性约束条件涉及该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级。 删除基本表（DROP TABLE）1DROP TABLE &lt;表名&gt; [RESTRICT | CASCADE]; CASCADE（级联）：删除该表没有限制条件。在删除基本表的同时，相关的依赖对象都将被一起删除。RESTRICT（限制）：删除该表是有限制条件的。欲删除的基本表不能被其他表的约束所引用（如 CHECK ， FOREIGN KEY 等约束），不能有视图、触发器、存储过程或函数等。如果存在依赖该表的对象，则此表不能被删除。 若表上建有视图，选择 RESTRICT 时表不能删除；选择 CASCADE 时可以删除表，视图也自动被删除。 12345678CREATE VIEW IS_StudentASSELECT Sno,Sname,SageFROM StudentWHERE Sdept='IS';DROP TABLE Student CASCADE;/* DROP TABLE Student RESTRICT; 会返回 Error */ 修改基本表（ALTER TABLE）12345678ALTER TABLE &lt;表名&gt;[ADD [COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [完整性约束]] [ADD &lt;表级完整性约束&gt;][DROP [COLUMN] &lt;列名&gt; [CASCADE| RESTRICT]][DROP CONSTRAINT &lt;完整性约束名&gt; [RESTRICT | CASCADE]][ALTER COLUMN &lt;列名&gt; &lt;数据类型&gt;]; ADD 子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件。 DROP COLUMN 子句用于删除表中的列，如果指定了 CASCADE 短语，则自动删除引用了该列的其他对象；如果指定了 RESTRICT 短语，则如果该列被其他对象引用，关系数据库管理系统将拒绝删除该列。 DROP CONSTRAINT 子句用于删除指定的完整性约束条件。 ALTER COLUMN 子句用于修改原有的列定义，包括修改列名和数据类型。 向 Student 表增加“入学时间”列，其数据类型为日期型。 1ALTER TABLE Student ADD S_entrance DATE; 将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数。 1ALTER TABLE Student ALTER COLUMN Sage INT; 增加课程名称必须取唯一值的约束条件。 1ALTER TABLE Course ADD UNIQUE(Cname); 模式与表每一个基本表都属于某一个模式，一个模式包含多个基本表。 定义基本表所属模式的三种方法： 在表名中明显地给出模式名。 1CREATE TABLE \"S-T\".Student(...); /* Student 所属的模式是 S-T */ 在创建模式语句中同时创建表。 12345678910/* 为用户 ZHANG 创建一个模式 TEST，并且在其中定义一个表 TAB1。 */CREATE SCHEMA TEST AUTHORIZATION ZHANGCREATE TABLE TAB1 ( COL1 SMALLINT, COL2 INT, COL3 CHAR(20), COL4 NUMERIC(10,3), COL5 DECIMAL(5,2)); 设置所属的模式，这样在创建表时表名中不必给出模式名。 3.3.3 索引（INDEX） WAITING TO BE UPDATED. 建立索引（CREATE INDEX）删除索引（DROP INDEX）修改索引（ALTER INDEX）3.4 数据查询3.4.1 单表查询只涉及一个表的查询叫做单表查询。 选择表中的若干列查询某个表的全部列： 1SELECT * FROM STUDENT; 查询某个表的部分列，列显示的具体顺序可以自定义： 1SELECT Sname, Sno FROM Student; 目标列表达式 不仅可以是算术表达式，还可以是字符串常量、函数等： 1SELECT Sname, 2021 - Sage FROM Student; 选择表中的若干元组消除取值重复的行：DISTINCT： 1SELECT DISTINCT Sno FROM SC; 查询满足条件的元组：WHERE 子句： 查询所有年龄在 20 岁以下的学生姓名及其年龄。 1SELECT Sname, Sage FROM Student WHERE Sage &lt; 20; 查询年龄不在 20~23 岁之间的学生姓名、系别和年龄。 1SELECT Sname, Sdept, Sage FROM Student WHERE Sage NOT BETWEEN 20 AND 23; 查询不是计算机科学系、数学系和信息系学生的姓名和性别。 1SELECT Sname, Ssex FROM Student WHERE Sdept NOT IN ('CS', 'MA', 'IS'); 查询所有有成绩的学生学号和课程号。 1SELECT Sno, Cno FROM SC WHERE Grade IS NOT NULL; /* `is NULL` 不能用 `= NULL` 代替 */ 查询计算机科学系年龄在 20 岁以下的学生姓名。 1SELECT Sname FROM Student WHERE Sdept = 'CS' AND Sage &lt; 20; /* AND 优先级比 OR 高，可用括号来改变优先级 */ 字符匹配 1[NOT] LIKE '&lt;匹配串&gt;' [ESCAPE '&lt;换码字符&gt;'] 其含义是查找指定的属性列值与 &lt;匹配串&gt; 相匹配的元组。&lt;匹配串&gt; 可以是一个完整的字符串，也可以含有通配符 % 和 _。 % 代表任意长度（长度可以为 0 ）的字符串。 e.g. a%b 表示以 a 开头，以 b 结尾的任意长度的字符串。 _ 代表任意单个字符。 e.g. a_b 表示以 a 开头，以 b 结尾的长度为 3 的任意字符串。 查询所有姓刘的学生的姓名、学号和性别。 1SELECT Sname, Sno, Ssex FROM Student WHERE Sname LIKE '刘%'; 查询姓 欧阳 且全名为三个汉字的学生的姓名。 1SELECT Sname FROM Student WHERE Sname LIKE '欧阳_'; 如果用户要查询的字符串本身就含有通配符 % 或 _ ，这时就要使用 ESCAPE &lt;换码字符&gt; 短语对通配符进行转义。 查询 DB_Design 课程的课程号和学分。 1SELECT Cno, Ccredit FROM Course WHERE Cname LIKE 'DB\\_Design' ESCAPE '\\'; ORDER BY 子句ORDER BY 子句可以对查询结果按照一个或多个属性列的升序(ASC)或降序(DESC)排列，默认值为升序。空值按最大值来参与排序。 查询选修了 3 号课程的学生的学号及其成绩，查询结果按分数的降序排列： 1SELECT Sno, Grade FROM SC WHERE Cno = '3' ORDER BY Grade DESC; 聚集函数为了进一步方便用户，增强检索功能，SQL 提供了许多聚集函数。 统计元组个数： COUNT(*) 统计一列中值的个数： COUNT([DISTINCT | ALL] &lt;列名&gt;) 计算一列值的总和（此列必须为数值型）： SUM([DISTINCT | ALL] &lt;列名&gt;) 计算一列值的平均值（此列必须为数值型）： AVG([DISTINCT | ALL] &lt;列名&gt;) 求一列中的最大值和最小值： MAX([DISTINCT | ALL] &lt;列名&gt;), MIN([DISTINCT | ALL] &lt;列名&gt;) 聚集函数只能用于 SELECT 子句和 GROUP BY 中的 HAVING 子句。 查询学生总人数。 1SELECT COUNT(*) FROM Student; 查询选修了课程的学生人数。 1SELECT COUNT(DISTINCT Sno) FROM SC; 计算选修 1 号课程的学生平均成绩。 1SELECT AVG(Grade) FROM SC WHERE Cno = '1'; 查询选修 1 号课程的学生最高分数。 1SELECT MAX(Grade) FROM SC WHERE Cno='1'; 查询学生 201215012 选修课程的总学分数。 1SELECT SUM(Ccredit) FROM SC, Course WHERE Sno = '201215012' AND SC.Cno = Course.Cno; GROUP BY 子句GROUP BY 子句将查询结果按某一列或多列的值分组，值相等的为一组。 将查询结果分组的目的是细化聚集函数的作用对象。如果未对查询结果分组，聚集函数将作用于整个查询结果。对查询结果分组后，聚集函数将分别作用于每个组，即每一组都有一个函数值。 查询平均成绩大于等于 90 分的学生学号和平均成绩。 1SELECT Sno, AVG(Grade) FROM SC GROUP BY Sno HAVING AVG(Grade) &gt;= 90; 3.4.2 连接查询若一个查询同时涉及两个以上的表，称为连接查询。连接查询是关系数据库中最主要的查询。 等值与非等值连接查询1[&lt;表名1&gt;.]&lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;.]&lt;列名2&gt; 查询每个学生及其选修课程的情况。 123SELECT Student.*, SC.*FROM Student, SCWHERE Student.Sno = SC.Sno; /* 将 Student 与 SC 中同一学生的元组连接起来 */ 自身连接一个表与其自己进行连接，称为表的自身连接。需要给表起别名以示区别。且由于所有属性名都是同名属性，因此必须使用别名前缀。 查询每一门课的间接先修课（即先修课的先修课）。 123SELECT FIRST.Cno, SECOND.CpnoFROM Course FIRST, Course SECONDWHERE FIRST.Cpno = SECOND.Cno; 外连接普通连接操作只输出满足连接条件的元组，而外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出。左外连接列出左边关系中所有的元组，右外连接列出右边关系中所有的元组。 使用外连接查询每个学生及其选修课程的情况。 12SELECT Student.Sno, Sname, Ssex, Sage, Sdept, Cno, GradeFROM Student LEFT OUTER JOIN SC ON (Student.Sno = SC.Sno); 多表连接两个以上的表进行连接称为多表连接。 查询每个学生的学号、姓名、选修的课程名及成绩。 123SELECT Student.Sno, Sname, Cname, Grade FROM Student, SC, CourseWHERE Student.Sno = SC.Sno AND SC.Cno = Course.Cno 关系数据库管理系统在执行多表连接时，通常是先进行两个表的连接操作，再将其连接结果与第三个表进行连接。 3.4.3 嵌套查询一个 SELECT-FROM-WHERE 语句称为一个查询块。嵌套查询是指将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中的查询。 123456SELECT Sname /* 外层查询或父查询 */FROM StudentWHERE Sno IN ( SELECT Sno /* 内层查询或子查询 */ FROM SC WHERE Cno = '2') 子查询的 SELECT 语句不能使用 ORDER BY 子句，ORDER BY 子句只能对最终查询结果排序。 不相关子查询：子查询的查询条件不依赖于父查询，即由里向外逐层处理。相关子查询：子查询的查询条件依赖于父查询。 带有 IN 谓词的子查询在嵌套查询中，子查询的结果往往是一个集合，所以谓词 IN 是嵌套查询中最经常使用的谓词。 查询与 刘晨 在同一个系学习的学生。 1234567SELECT Sno, Sname, SdeptFROM StudentWHERE Sdept IN ( SELECT Sdept FROM Student WHERE Sname = '刘晨') 也可以用自身连接来完成： 123SELECT S1.Sno, S1.Sname, S1.SdeptFROM Student S1, Student S2WHERE S1.Sdept = S2.Sdept AND S2.Sname = '刘晨'; 带有比较运算符的子查询 找出每个学生超过他自己选修课程平均成绩的课程号。 1234567SELECT Sno, CnoFROM SC x /* x 是表SC的别名，又称为元组变量，可以用来表示SC的一个元组 */WHERE Grade &gt;= ( SELECT AVG(Grade) FROM SC y WHERE y.Sno = x.Sno); 带有 ANY（SOME）或 ALL 谓词的子查询带有 EXISTS 谓词的子查询3.4.4 集合查询参加集合操作的各查询结果的列数必须相同；对应项的数据类型也必须相同。 查询计算机科学系的学生及年龄不大于 19 岁的学生。 123456SELECT * FROM Student WHERE Sdept = 'CS'UNION SELECT * FROM Student WHERE Sage &lt;= 19;/*UNION：将多个查询结果合并起来时，系统自动去掉重复元组UNION ALL：将多个查询结果合并起来时，保留重复元组。*/ 查询计算机科学系的学生与年龄不大于 19 岁的学生的交集。 1234SELECT * FROM Student WHERE Sdept = 'CS'INTERSECT SELECT * FROM Student WHERE Sage &lt;= 19;SELECT * FROM Student WHERE Sdept = 'CS' AND Sage &lt;= 19; 查询既选修了课程 1 又选修了课程 2 的学生。 12SELECT Sno FROM SC WHERE Cno = '1'INTERSECT SELECT Sno FROM SC WHERE Cno = '2'; 查询计算机科学系的学生与年龄不大于 19 岁的学生的差集。 1234SELECT * FROM Student WHERE Sdept = 'CS'EXCEPT SELECT * FROM Student WHERE Sage &lt;= 19;SELECT * FROM Student WHERE Sdept = 'CS' AND Sage &gt; 19; 3.5 数据更新数据更新操作有三种：向表中添加若干行数据、修改表中的数据和删除表中的若干行数据。 3.5.1 插入数据 将一个新学生元组（学号：201215128；姓名：陈冬；性别：男； 所在系：IS；年龄：18岁）插入到 Student 表中。 123INSERTINTO Student (Sno, Sname, Ssex, Sdept, Sage) VALUES ('201215128', '陈冬', '男', 'IS', 18); 将学生张成民的信息插入到 Student 表中。 123INSERT INTO Student VALUES ('201215126', '张成民', '男', 18, 'CS'); 对每一个系，求学生的平均年龄，并把结果存入数据库。 12345678910-- 第一步：建表CREATE TABLE Dept_age (Sdept CHAR(15), /*系名*/ Avg_age SMALLINT); /*学生平均年龄*/-- 第二步：插入数据 INSERTINTO Dept_age(Sdept,Avg_age) SELECT Sdept, AVG(Sage) FROM Student GROUP BY Sdept; 3.5.2 修改数据 将学生 201215121 的年龄改为 22 岁。 1UPDATE Student SET Sage = 22 WHERE Sno = '201215121' 将所有学生的年龄增加 1 岁。 1UPDATE Student SET Sage = Sage + 1; 将计算机科学系全体学生的成绩置零。 123456UPDATE SC SET Grade = 0 WHERE Sno IN (SELETE Sno FROM Student WHERE Sdept = 'CS'); 3.5.3 删除数据 删除学号为 201215128 的学生记录。 1DELETE FROM Student WHERE Sno = '201215128'; 删除所有的学生选课记录。 1DELETE FROM SC; 删除计算机科学系所有学生的选课记录。 123456DELETE FROM SC WHERE Sno IN (SELETE Sno FROM Student WHERE Sdept='CS'); 对某个基本表中数据的增、删、改操作有可能会破坏参照完整性，第5章第2节 参照完整性将详细讲解如何进行参照完整性检查和控制。 3.6 空值的处理3.7 视图视图是从一个或几个基本表（或视图）导出的表，是一个虚表。数据库中只存放视图的定义，不存放视图对应的数据，这些数据仍存放在原来的基本表中。一旦基本表中的数据发生变化，从视图中查询出的数据也随之改变。视图一经定义，就可以和基本表一样被查询、被删除。也可以在一个视图之上再定义新的视图，但对视图的更新（增、删、改）操作则有一定的限制。 3.7.1 定义视图组成视图的属性列名或者全部省略或者全部指定。如果省略了视图的各个属性列名，则隐含该视图由子查询中 SELECT 子句目标列中的诸字段组成。WITH CHECK OPTION 表示对视图进行 UPDATE、INSERT 和 DELETE 操作时要保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）。 建立信息系学生的视图。 12345CREATE VIEW IS_StudentASSELECT Sno, Sname, SageFROM StudentWHERE Sdept = 'IS'; 建立信息系学生的视图，并要求进行修改和插入操作时仍需保证该视图只有信息系的学生。 123456CREATE VIEW IS_StudentASSELECT Sno, Sname, SageFROM StudentWHERE Sdept = 'IS'WITH CHECK OPTION; 建立信息系选修了 1 号课程的学生的视图（包括学号、姓名、成绩）。 12345CREATE VIEW IS_S1(Sno, Sname, Grade)ASSELECT Student.Sno, Sname, GradeFROM Student, SCWHERE Sdept = 'IS' AND Student.Sno = SC.Sno AND SC.Cno = '1'; 建立信息系选修了 1 号课程且成绩在 90 分以上的学生的视图。 12345CREATE VIEW IS_S2ASSELECT Sno, Sname, GradeFROM IS_S1WHERE Grade &gt;= 90; 删除视图视图删除后视图的定义将从数据字典中删除。如果该视图上还导出了其他视图，使用 CASCADE 级联删除语句，把该视图和由它导出的所有视图一起删除。基本表删除后，由该基本表导出的所有视图均无法使用了，但是视图的定义没有从字典中清除。删除这些视图定义需要显式地使用 DROP VIEW 语句。 删除视图 BT_S 和 IS_S1。 12DROP VIEW BT_S; /* 成功执行 */DROP VIEW IS_S1; /* 拒绝执行 */ 由于 IS_S1 视图上还导出了 IS_S2 视图，所以该语句被拒绝执行。如果确定要删除 IS_S1，需使用级联删除语句： 1DROP VIEW IS_S1 CASCADE; /* 删除了视图IS_S1和由它导出的所有视图 */ 3.7.2 查询视图 在信息系学生的视图中找出年龄小于 20 岁的学生。 123SELECT Sno, SageFROM IS_StudentWHERE Sage &lt; 20; 视图消解转换后的查询语句为： 123SELECT Sno,SageFROM Student WHERE Sdept = 'IS' AND Sage &lt; 20; 定义视图并查询视图与基于派生表的查询是有区别的：视图一旦定义，其定义将永久保存在数据字典中，之后的所有查询都可以直接引用该视图派生表只是在语句执行时临时定义，语句执行后该定义即被删除。 3.7.3 更新视图更新视图是指通过视图来插入、删除和修改数据。 由于视图是不实际存储数据的虚表，因此对视图的更新最终要转换为对基本表的更新。 像查询视图那样，对视图的更新操作也是通过视图消解，转换为对基本表的更新操作。 为防止用户通过视图对数据进行增加、删除、修改时，有意无意地对不属于视图范围内的基本表数据进行操作，可在定义视图时加上 WITH CHECK OPTION 子句。 将信息系学生视图 IS_Student 中学号为“201215122”的学生姓名改为“刘辰” 。 123UPDATE IS_StudentSET Sname = '刘辰'WHERE Sno = '201215122'; 转换后的更新语句为： 123UPDATE StudentSET Sname='刘辰'WHERE Sno='201215122' AND Sdept='IS'; 向信息系学生视图 IS_Student 中插入一个新的学生记录，其中学号为“201215129” ，姓名为“赵新”，年龄为 20 岁。 123INSERTINTO IS_StudentVALUES('201215129','赵新',20); 转换后的插入语句为： 123INSERTINTO Student(Sno,Sname,Sage,Sdept)VALUES('201215129','赵新',20,'IS'); 删除信息系学生视图 IS_Student 中学号为“201215129”的记录。 123DELETEFROM IS_StudentWHERE Sno='201215129'; 转换后的删除语句为： 123DELETEFROM StudentWHERE Sno='201215129' AND Sdept='IS'; 在关系数据库中，并不是所有的视图都是可更新的，因为有些视图的更新不能唯一地有意义地转换成对相应基本表的更新。","link":"/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-chap3-SQL/"},{"title":"数据库系统笔记 - chap2 - 关系模型","text":"关系数据结构 关系代数A set of fundamental operations to retrieve and manipulate tuples in a relation. These operations take one or some relations as inputs, and outputs a new relation. 并、交、差、笛卡尔积与集合运算相似。 选择（Select）行视角，选择出符合条件的若干元祖集合。 符号: 举例: SQL写法: SELECT * FROM R WHERE Name = 'qaq' 投影（Projection）列视角，选择出若干属性列组成新的关系。 符号: 举例: SQL写法: SELECT Name, id FROM R WHERE Name = 'qaq' 投影运算会把新关系中的重复行删去（集合的不可重原则）。 连接（Join） 符号: 其中 是 与 上的度数相等且可比较的属性组， 是比较运算符。SQL: SELECT * FROM R JOIN S USING (ATTRIBUTE1, ATTRIBUTE2, ...) 若 为 ，则叫做等值连接。自然连接是一种特殊的等值连接，只不过是在等值连接的基础上去掉结果中重复的属性列。 关系的完整性关系的完整性约束是对关系正确性的限定。关系的完整性分为实体完整性、参照完整性和用户定义完整性。 实体完整性由于主码 Primary Key 是区分实体的唯一性标识，所以关系 的主码不能取空值 NULL （若主码由多个属性构成，则所有这些属性都不能取空值）。 12345678910111213141516171819CREATE TABLE Student ( Sno CHAR(9) PRIMARY KEY, // 列级 Sname CHAR(8), Ssex CHAR(2) CHECK(Ssex IN ('男', '女')),);CREATE TABLE Student ( Sno CHAR(9), Sname CHAR(8), Ssex CHAR(2) CHECK(Ssex IN ('男', '女')), PRIMARY KEY (Sno) // 表级);CREATE TABLE SC ( Sno CHAR(5), Cno CHAR(3), Grade int, PRIMARY KEY (Sno, Cno) // 表级，且只能是表级); 参照完整性参照完整性定义了外码 Foreign Key 与主码之间的引用规则，即外码的取值要么是 NULL （若外码包含多个属性，则这些属性的值均取 NULL ；但假如外码中的属性是主属性，则不能取 NULL ），要么是被参照关系中某元组在该属性的取值。（“你从别人那里引用到的任何值，别人得有才能给你引用”） 12345678CREATE TABLE SC ( Sno CHAR(5), Cno CHAR(3), Grade int, PRIMARY KEY (Sno, Cno), // 表级定义实体完整性 FOREIGN KEY (Sno) REFERENCES S(Sno), //表级定义参照完整性 FOREIGN KEY (Cno) REFERENCES C(Cno) //表级定义参照完整性); 用户定义完整性用户规定数据必须满足的一系列要求，包括属性上的约束与元组上的约束。 属性上的约束123456CREATE TABLE SC ( Sno CHAR(5) NOT NULL // 约束 Sno 非空 Cno CHAR(9) UNIQUE NOT NULL, // 约束 Cno 唯一且非空 Age SMALLINT CHECK (Age &gt;= 18 AND Age &lt;= 23), // 约束 Age 的范围在 [18, 23] 之间 PRIMARY KEY (Sno, Cno),); 元组上的约束可以在元组层面上限制不同属性之间的取值以及相互约束关系。 123456789CREATE TABLE Student( Sno CHAR(9), Sname CHAR(8) NOT NULL, Ssex CHAR(2), Sage SMALLINT, Sdept CHAR(20), PRIMARY KEY (Sno), CHECK (Ssex='女' OR Sname NOT LIKE 'Ms.%') // 约束了学生性别为男时，其名字不能以 Ms. 开头); 完整性约束命名子句1CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt; &lt;完整性约束条件&gt; 包括 NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK 短语等。 123456789101112CREATE TABLE Student( Sno NUMERIC(6) CONSTRAINT C1 CHECK (Sno BETWEEN 90000 AND 99999), Sname CHAR(20) CONSTRAINT C2 NOT NULL, Sage NUMERIC(3) CONSTRAINT C3 CHECK (Sage &lt; 30), Ssex CHAR(2) CONSTRAINT C4 CHECK (Ssex IN ('男','女')), CONSTRAINT StudentKey PRIMARY KEY(Sno), CONSTRAINT SnameKey FOREIGN KEY(Sname) REFERENCES C(Sname));","link":"/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-chap2-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/"},{"title":"数据库系统笔记 - chap1 - 绪论","text":"数据库发展史人工管理阶段（1950） 文件系统阶段（1950-1960） 数据库系统阶段（1960-） 数据库管理系统（DBMS）的出现，使得数据存储、数据管理和数据应用分离。数据库管理系统采用外模式-模式-内模式的三级模式，外模式/模式和模式/内模式的两级映象结构。 数据模型定义：是数据及其联系在计算机中的表示和组织形式的描述。组成三要素：数据结构，数据操纵，数据完整性约束。经典模型：层次模型（有根树），网状模型（有向图），关系模型。","link":"/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-chap1-%E7%BB%AA%E8%AE%BA/"},{"title":"JavaScript学习笔记","text":"Brief Syntax Introduction JS 是解释型语言。 解释型语言 与 编译型语言： 解释型：一行一行看，容易出错但方便，可以及时方便地找到出错位置以及出错原因，容易跨平台（可以嵌入到其他软件）。编译型：把高级语言预先翻译成机器语言，并把结果保存下来，速度快（编译器优化），不易出错，但不能跨平台（e.g. .exe can’t be run in MacOS)。 行末分号非必需： JS 中的每一行都可以选择使用分号终止，即编译器会自动补全没有用分号的地方。 JS 中的变量是弱类型的，即变量的类型只有在被赋值的时候才得到确认。 数据类型与变量 const 用来申明常量（一旦声明后续值不可更改），let 用来申明变量（一个变量只能申明一次，值以及值的类型可以被多次更改）。 JS 中允许一个变量未被提前申明就使用。此时该变量会被自动被申明为全局变量。若在程序的最开始加上 use strict 语句，则可以避免这支双刃剑带来的弊端。（在 strict 模式下，变量必须要先经过申明，才能被使用，否则会报错） JS 中的基本类型有数字、字符串、布尔值、符号、null 和 undefined。数字中不区分整数和浮点数。 JS 中遇到计算除法时除数为 0 的情况时，不会报错，会根据被除数的值来返回对应的结果。若被除数是正数，则返回 Infinity ；若被除数是负数，则返回 -Infinity；若被除数是 0 ，则返回 NaN (Not a Number)。除以 0 的余数（1 % 0）为 NaN 。 与 python 类似， JS 中一个 * 代表相乘， ** 则代表幂运算。 JS 中 === 表示检查是否相等，!== 表示检查是否不等。 字符串 JS 中的字符串用 '' 或 \"\" 括起来表示。若想表达的字符串中本身含有 ' 或 \"，则需要用到转义字符。e.g. I'm \"OK\"! 的表示是： 1'I\\'m \\\"OK\\\"!'; 在 JS 中输出多行字符串的方式是用反引号。e.g. 1234`No \\nanymore`; 与 python 类似，要把多个字符串连接起来，可以用 + 号连接。也可以通过模版字符串的方式来方便输出过程。（反引号与 ${} 的结合） 12345let name = '小明';let age = 20;let message1 = '你好, ' + name + ', 你今年' + age + '岁了!';let message2 = `你好, ${name}, 你今年${age}岁了!`//message1 = message2 JS 中的字符串是不可变的，即不能通过 s[id] = 'A' 的方式来将 s 中 id 位置的字母改成 A 。 JS 中有很多类似 python 和 C++ STL 中的字符串函数，如 toUpperCase，indexOf（搜索元素在数据结构中出现的位置，未找到则返回 -1），substring 等。 数组 JS 中的数组可以包含任意数据类型，并通过索引来访问/修改每个元素。 123a = [1, 'hello, world', ['a', b, 100]];a[0] = 'qaq';a; // a = ['qaq', 'hello, world', ['a', b, 100]] 在 JS 中允许给数组的 length 赋一个新值。除此之外，假如进行了数组的越界访问，也不会报错。 12345678var arr = [1, 2, 3];arr.length = 6;arr; // arr 变为 [1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2]arr[4] = 'qaq';arr; // arr 变为 [1, 2, undefined, undefined, 'qaq'] 同 python 的切片类似，slice() 可以将一个数组的局部“拿出来”，变成一个新的数组。 12345var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']var aCopy = arr.slice();aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G'] 如果要在数组的头部添加若干元素，可以使用 unshift() ; shift() 则可以用来把数组的第一个元素删除。splice() 则可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素。 12345678var arr = [1, 2, 3, 4];arr.unshift('A', 'B'); // 返回Array新的长度: 6arr; // ['A', 'B', 1, 2, 3, 4]arr.shift(); // 'A'arr; // ['B', 1, 2, 3, 4]// 从索引 1 开始删除 3 个元素,然后再添加 2 个元素:arr.splice(1, 3, 'qaq', 222); // 返回删除的元素 [1, 2, 3]arr; // ['B', 4, 'qaq', 222] 如果要在数组的尾部添加/删除若干元素，可以使用 push() 和 pop()。 123456789var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] 对象在 JS 中，对象是一种无序的集合数据类型，由若干键值对组成。用法与 python 中的 dictionary 很像。但 JS 对象的键必须是字符串，值可以是任意数据类型。这一点和 dictionary 对键和值类型的无限制不同（ JS 中 Map 的引入解决了这个问题）。 12345678var xiaoming = { name: 'Yiling Zhang', birth: 2003, school: 'Xidian University', height: 1.77, weight: 65, score: 100}; 函数函数的定义与调用123456789101112function get_pow(x, y) { var res = 1, i; for (i = 1; i &lt;= y; i++) res = res * x; return res;}var get_pow = function (x, y) { var res = 1, i; for (i = 1; i &lt;= y; i++) res = res * x; return res;};//匿名函数，在 JS 中函数也可以作为变量，通过这个变量就可以调用该函数。 传入函数的多个变量以逗号分隔开。如果传入某个函数的变量的个数，比该函数预先设定的要多，程序仍然会返回正确的结果，且不会报错。如果要少，则不会报错，但是结果可能不正确。 在函数的内部，系统提供了关键字 arguments。该关键字只在函数内部起作用，通过该参数可以访问到传入该函数的所有参数。可以通过访问 arguments.length() 来获取到传入某个函数的参数的个数。 12345678910function abs() { if (arguments.length() == 0) return 0; else { var x = arguments[0]; return x &gt;= 0 ? x : -x; }}abs(); // 0abs(-2, 1); // 2 变量作用域与解构赋值局部作用域、块级作用域若在函数内部用 var 申明变量，则该变量的作用域是该函数内部，即这是一个局部变量。 在 JS 中允许函数的嵌套，即某个函数内可以定义另一个函数。同时允许内函数和外函数中定义重名的变量。 函数在查找变量时从自身函数定义开始，从内向外查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。 123456789use strict;function f() { var x = 1; function g() { var x = 2; x; // x = 2 } x; // x = 1} 在函数内部中用 var 申明一个变量，该变量会在整个函数中都起作用，不具有块级作用域。用 let 来申明则不会有这种问题，新申明的变量会具有块级作用域。 1234567891011function f() { var sum = 0; for (var i = 0; i &lt; 100; i++) sum += i; i++; // 仍然可以使用在上一个循环内定义的i}function f() { var sum = 0; for (let i = 0; i &lt; 100; i++) sum += i; i++; // SyntaxError （与在c++中的逻辑一样）} 请严格遵守在函数内部首先申明所有变量这一规则！否则会出一些奇奇怪怪的错误。 全局作用域不在任何函数内定义的变量就具有全局作用域。 JS 默认有一个全局对象window ，全局作用域的变量（变量、函数等）实际上被绑定到 window 的一个属性。 123var x = 1;alert(x); // 1alert(windows.x); // 1 解构赋值在 JS 中可以使用解构赋值，直接对多个变量同时赋值： 1234let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']];x; // 'hello'y; // 'JavaScript'z; // 'ES6' 12345678910111213var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school'};let {name, passport : id} = person; // 把passport属性赋值给变量id:name; // '小明'id; // 'G-12345678'// 注意: passport不是变量，而是为了让变量id获得passport属性:passport; // Uncaught ReferenceError: passport is not defined 解构赋值在很多时候可以大大简化代码。例如，交换两个变量 和 的值，可以这么写，不再需要临时变量： 12var x = 1, y = 2;[x, y] = [y, x] 快速获取当前页面的域名和路径： 1var {hostname : domain, pathname : path} = location; 如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个 Date 对象： 123456function buildDate({year, month, day, hour = 0, minute = 0, second = 0}) { return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);}buildDate({ year: 2017, month: 1, day: 1 }); // Sun Jan 01 2017 00:00:00 GMT+0800 (CST)// 传入的对象只需要year、month和day这三个属性 方法可以给对象绑定函数。绑定到对象上的函数叫 方法 ，其在内部使用了 this 关键字。 在方法内部， this 始终指向当前对象。 1234567891011var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; }};xiaoming.age; // function xiaoming.age()xiaoming.age(); // 今年调用是25,明年调用就变成26了 若不通过某个对象直接在函数里调用 this ，this 默认指向 windows 。在 strict 模式下，函数的 this 指向的是 undefined ，从而系统会报错提醒你这里的不规范写法。故要保证 this 指向正确，必须用 obj.xxx() 的形式调用，或者可以用一个变量首先捕获 this 。 12345678910111213'use strict';var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; }};var fn = xiaoming.age;fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined 12345678910111213141516'use strict';var xiaoming = { name: '小明', birth: 1990, age: function () { var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() { var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this } return getAgeFromBirth(); }};xiaoming.age(); // 25","link":"/2023/10/19/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Hints When Coding.","text":"Next_Permutation123do { for (int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; (i == n ? \"\\n\" : \" \");} while (next_permutation(a.begin(), a.end())); 是长度为 的序列，上段代码会输出 的字典序之后的所有排列（若想要 个数的全排列，只需要让 ）。 字母构成的字符串也可以使用该函数。 12345678910111213string a; // a = \"ace\"do { cout &lt;&lt; a &lt;&lt; endl;} while (next_permutation(a.begin(), a.end()));/*aceaeccaeceaeaceca*/ 结构体结构体读入： 1234for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x &gt;&gt; y; q.push((node){x, y});} 12345678910111213141516struct node { string name; int age; Up(string s, int x) : name(s), age(x) {} // 构造函数 bool operator &lt; (const node&amp; a) const { return age &lt; a.age; }};int main() { for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; s &gt;&gt; x; q.push(Up(s, x)); }} i == n ? “\\n” : “ “另一种更方便的方式： 1for (int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; \" \\n\"[i == n]; 多组数据输入12345for (cin &gt;&gt; T; T; T--) { /* your code */}","link":"/2023/10/18/Hints-When-Coding/"},{"title":"抽象代数笔记","text":"6.1 代数结构代数系统（代数）：非空集合 和 上的 个一元或二元运算 组成的系统。记作 。 6.1.1 代数运算设 是非空集合， 是从 到 的一个映射，则称 为集合 到 的一个 元代数运算。（其中 称作该运算的阶）。 等这些符号加上 普通 的前缀，才代表的是其原来的运算。 运算的封闭性设 为集合 到 的一个 元运算。若 ,则称 在集合 上是封闭的。e.g. 普通减运算在 上不封闭。 若称一个运算是某个集合上的运算，则该运算必须满足在这个集合上具有封闭性。 1. 运算性质 - 交换律设 为 上的二元运算，若 都有： x \\ast y = y \\ast x则称运算 在 上可交换。若已知该运算的运算表，则可通过判断该表是否满足沿主对角线对称，来判断是否满足交换律。 2. 运算性质 - 结合律设 为 上的二元运算，若 都有: (x \\ast y) \\ast z = x \\ast (y \\ast z)则称运算 在 上可结合。判断该运算是否满足结合律，不能通过运算表直观的看出来。 3. 运算性质 - 分配律设 为 上的二元运算，若 都有： x \\ast (y \\circ z) = (x \\ast y) \\circ (x \\ast z), \\quad 称 \\ast 对 \\circ 左可分配 \\\\ (y \\circ z) \\ast x = (y \\ast x) \\circ (z \\ast x), \\quad 称 \\circ 对 \\ast 右可分配则称 对 可分配。 4. 运算性质 - 吸收律设 为 上的二元运算，若 都有： x \\ast (x \\circ y) = x, \\quad 称 \\ast 对 \\circ 左可吸收 \\\\ (x \\circ y) \\ast x = x, \\quad 称 \\circ 对 \\ast 右可吸收则称 对 可吸收。若 满足交换律，则只需证明一边满足吸收律即可。e.g. 集合中的 运算对 运算可吸收。因为 （右可吸收同理）。 5. 运算性质 - 等幂律设 为 上的二元运算，若 都有: x \\ast x = x则称运算 在 上满足等幂律。 6. 运算性质 - 消去律设 为 上的二元运算，某个元素 ，若 都有： a \\ast x = a \\ast y \\ \\Rightarrow x = y, \\quad 称a是左可消去的 \\\\ x \\ast a = y \\ast a \\ \\Rightarrow x = y, \\quad 称a是右可消去的则称 关于 运算 是可消去的。若 中所有的元素都满足消去律，则可说明 满足消去律。 叫做永真蕴含式。箭头左边的式子叫做前件，右边的叫做后件。永真蕴含式表明，若前件成立，则后件一定成立。永真蕴含式的逆否形式也成立。 可消去性可以从运算表中观察到。若 满足消去律，则运算表中每一行每一列中都没有相同的元素。 6.1.2 代数常元该代数系统中与运算相关的特殊元素称作代数常元。 1. 幺元设 是定义在 上的二元运算，若存在元素 (或 ) 使得 都有： e_l \\ast x = x \\quad （或 \\ x \\ast e_r = x）则称 (或 ) 是 中关于 运算的左（右）幺元。若 既是左幺元又是右幺元，则称 是 中关于 运算的幺元。且 是 上关于 的唯一的幺元。 2. 零元设 是定义在 上的二元运算，若存在元素 (或 ) 使得 都有： \\theta_l \\ast x = \\theta_l \\quad （或 \\ x \\ast \\theta_r = \\theta_r）则称 (或 ) 是 中关于 运算的左（右）零元。若 既是左零元又是右零元，则称 是 中关于 运算的零元。且 是 上关于 的唯一的零元。 3. 逆元设 是定义在 上的二元运算， 是 中关于 运算的幺元。对于 , 如果存在 （或 ）使得： y_l \\ast x = e \\quad （或 \\ x \\ast y_r = e）则称 (或 ) 是 的左（右）逆元。若 既是左逆元又是右逆元，则称 是 的逆元。 若 运算是可结合的，且对于 存在 ，则 是 的唯一的逆元, 。 6.2 子代数6.2.1 子代数的定义设 是一个代数系统， 分别是载体 上的二元运算和一元运算， 是代数常元。若： A' \\subseteq A \\\\ A' 对 \\ast 和 \\varDelta 均封闭 \\\\ k \\subseteq A'则称 是 的子代数系统。若 ， 被称为 的最大的子代数。若 ， 被称为 的最小的子代数。最大和最小子代数被称为 的平凡子代数。其余的子代数（）被称为 的真子代数。 6.3 同态6.3.1 同态的定义设 两个具有相同构成的代数系统， 是从 到 的一个映射， 且对 满足（先运算再映射 = 先映射再运算）： f(a\\ast b) = f(a) \\ast'f(b) \\\\ f(\\varDelta a) = \\varDelta'f(a) \\\\ f(k) = k'则称 为由 到 的一个同态映射， 简称同态， 记作 。 6.3.2 同态象设 是从 到 的同态映射，称 为 在映射 下的同态象。 6.3.3 同态的分类设 是从 到 的一个映射。 满射：若 中每个值都能在 中找到其原象，则称 是一个满射。 单射：若 ，都有 。则称 是一个单射。 双射：既是满射又是双射的映射。 设 是从 到 的一个同态映射。 若 是满射的，则称 是一个满同态。 若 是单射的，则称 是一个单一同态。 若 是双射的，则称 是一个同构映射，简称同构，记作 。 若 ，则称 为 上的自同态。 若 且 是双射的，则称 为 上的自同构。 6.3.4 同态的性质设 是从 到 的一个同态映射。那么 的同态象 。 是 的子代数。 若 在 中可交换（可结合），则 在 中也可交换（可结合）。 若在 中 对 可分配，则在 中 对 也可分配。 若 是 中关于运算 的幺元，则 也是 中关于运算 的幺元。 若 是 中关于运算 的零元，则 也是 中关于运算 的零元。 , 对运算 存在逆元 ；则在 中， 也有关于运算 的逆元 。 6.4 同余6.4.1 同余的定义设代数系统 ， 是载体 上的等价关系。 ： 当 时，若 ，则说明等价关系在一元运算 下是可保持的，称 是关于运算 的同余关系。 当 时，若 ，则说明等价关系在二元运算 下是可保持的，称 是关于运算 的同余关系。 若 在 上的所有运算下都是可保持的，则称 是代数系统 上的同余关系。 等价关系具有对称性、自反性、传递性。 6.4.2 与同态有关的定理设 是从 到 的一个同态映射。若在 上定义等价关系 ： \\langle a, b \\rangle \\in R, \\quad iff: g(a) = g(b)则 是 上的一个同余关系。 6.5 商代数6.5.1 商代数的定义与性质设代数系统 ， 是 上的同余关系。则称 关于 的商代数 。其中 。 是集合的集合，即等价类的集合。该集合是 的一个划分，即该集合中任意两元素（集合）的交集是空集（因为等价具有传递性）。 是集合间的运算， 是代数常元的集合。 小结：由等价关系 可以得到代数系统 的载体的一个划分，以这个划分为新的载体，按照原运算的规则建立等价类之间新的运算，这样得到的代数系统是原代数系统的商代数。 6.6 半群与独异点6.6.1 半群与子半群半群：对于一个代数系统 ， 是 上的二元运算，若运算 是可结合的，则称 为半群。子半群：设 是一个半群， 且 在 上是封闭的，那么 是 的子代数。 也是一个半群，称为 的子半群（因为结合律在子代数上可继承）。 6.6.2 独异点与子独异点独异点：含有幺元的半群（含幺半群）。子独异点：满足是原代数系统的子代数，本身是独异点，且在相同运算下与原代数系统有相同幺元，那么称为是原独异点的子独异点。 6.6.3 半群与独异点的等幂元性质设 是一个半群，若 是一个有限集，则必存在 ，使得 。证明：结合鸽巢原理。 6.6.4 交换半群与循环独异点交换半群（独异点）：在半群（独异点）中，若运算是可交换的，则称此半群（独异点）为交换半群（独异点）。 循环独异点：设 是一个独异点，若 ，则 使得 （ 是 个 做运算的意思），则称此独异点为循环独异点。 （存在一个数能把其他所有数都表示出来） 称为该循环独异点的生成元，一个循环独异点的生成元个数可以不唯一。 6.7 群6.7.1 群的定义群：设 是一个代数系统。若 运算是可结合的（是半群），并且存在幺元（是独异点），并且 ，都存在其唯一的逆元 ，则称 是一个群。 群的阶数：群的元素个数，记作 。根据 可以将群分为有限群和无限群。 6.7.2 群的性质 群中无零元。 （因为零元不可逆，故群中一定不含零元。） 群中每个元素的逆元唯一。 设 是一个群，对于 ，必存在唯一的 ，使得 。 （即群中任何两个元素都能通过运算相互表示。） 设 是一个群， ，若有 或者 ，则必有 （消去律）。 （因为没有零元，所以可以直接消去。） 设 是一个群，除幺元 外，不可能有任何别的等幂元。 （幺元是唯一的等幂元。） 群 的运算表的每一行/每一列都是 中所有元素的一个置换。 （ 中每一个元素都会在运算表中的每一行/每一列出现，并且只出现一次。） 6.7.3 群中元素的阶设 是一个群， 是幺元， 。若存在唯一且最小的正整数 使得 ，则称 为元素 的阶（或周期）；否则称元素 的阶是无限的。 定理1若群 的元素 拥有一个有限阶 ，则 当且仅当 是 的倍数。 定理2群中任何一个元素 与它的逆元 都具有相同的阶。 定理3有限群 中任何一个元素的阶最多是 。 6.7.4 阿贝尔群与循环群阿贝尔群：若群 中 运算是可交换的，则称该群为阿贝尔群（Abel 群）或交换群。 循环群：设 是群，若 ，则称 为循环群。 是循环群 的一个生成元。一个循环群的生成元个数可以不唯一。与循环独异点不同的是，循环群中 中的 可以取负整数。在这里理解成对 先求逆，再进行 次的运算。 任何一个循环群必定是阿贝尔群。（证明：将元素写成生成元的幂的形式，再证明 的可交换性，其中用到了加法是可交换的。） 6.7.5 循环群的性质设 是循环群，它的生成元是 ，，则： 是使 的最小正整数。 。 定理：循环群的子群必是循环群。 6.7.6 子群和群同态设 是群， 是 的非空子集。若： —— 在 上封闭。 —— 中所有元素可逆。 ， 其中 是 的幺元 —— 包含和 中一样的幺元。 则称 是 的子群。 和 称作 的平凡子群。（联想到子代数和平凡子代数的概念） 子群的判定1设 是群， 是 的非空子集。若运算 在 上封闭，并且 ，则称 是 的子群。 子群的判定2设 是群， 是 的非空子集。若 是有限集，并且 在 上封闭，则称 是 的子群。 子群的判定3设 是群， 是 的非空子集。若 ，则称 是 的子群。 群同态设 和 是两个群， 是 到 的映射。若 ，都有 ，则称 是 到 的群同态， 称作 的同态象。（本质与之前的同态概念相同，先运算再映射 = 先映射再运算） 之前的同态是针对普通代数系统的，群同态的概念只是在代数系统是群的条件上产生的。 群同态的定理群 的同态象 是群 的子群。（证明：最朴素的子群证法） 同态核设 是从群 到 的一个同态映射， 是 中的幺元。定义： Ker(h) = \\{ x | x \\in G \\wedge h(x) = e_{H}\\}称 为群同态映射 的核，简称 的同态核。 是 的子群。 循环群同态性质设 是一个循环群，其生成元为 。 若 是无限集，则 与 同构。 若 是有限集且其阶为 , 则 与 同构。 6.7.7 陪集设 是群 的一个子群。 左陪集：，集合 ，称为由 确定的 在 中的左陪集。元素 称为左陪集 的代表元素。 陪集的性质 设 是群 的一个子群， 和 是其任意两个左陪集。 或 。 。 设 是群 的一个子群，， 是由 确定的 在 中的左陪集。则 当且仅当 。 6.7.8 拉格朗日定理设 是群 的一个子群，则： 是 中的等价关系，且有 。 若 是有限群，，，则 。 拉格朗日定理的推论 任何质数阶的群没有非平凡子群。 设 是 阶有限群，则 ， 的阶数必定是 的因子，且 。 一个质数阶的群必定是循环群，且任何与幺元不同的元素均可作为生成元。 6.8 环和域6.8.1 环若代数系统 满足： 是阿贝尔群（ 是群且 在 上可交换）。 是半群（ 在 上可结合）。 乘法 和加法 是可分配的。即 ，有： a \\cdot (b + c) = a \\cdot b + a \\cdot c \\\\ (b + c) \\cdot a = b \\cdot a + b \\cdot c 则称 是环。 环的定理设 是环， 是 的幺元。则 ，有： （ 同时也是 的零元） 是 的加法逆元，将 记作 。 特殊的环设 是环: 交换环：若运算 是可交换的。 含幺环：若 含有幺元。 含零因子环： 是 的幺元，若 ，使得 ，则称 是零因子，称 是含零因子环。 整环： 是可交换独异点且无零因子。 整环的定理设 是环， 是 的幺元。 无零因子当且仅当 满足可约律（即 ，若 ，必有 ）。 6.8.2 域在代数系统 中， 是 的幺元，若： 是阿贝尔群。 也是阿贝尔群。 乘法 和加法 是可分配的。 则称 是域。 域的定理域一定是整环。可以通过整环的概念来定义域：设 是整环，，且 是群，则 是域。 有限整环一定是域。","link":"/2023/10/18/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/"},{"title":"CSP认证复建记录（于2023.09停更）","text":"2021042.邻域均值通过题目限制得出 的范围，二维前缀和统计即可。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int n, L, r, cnt, a[700][700], sum[700][700];double ans, t;int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; L &gt;&gt; r &gt;&gt; t; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { cin &gt;&gt; a[i][j]; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i][j]; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { int ex = min(n, i + r), ey = min(n, j + r), sx = max(1, i - r), sy = max(1, j - r); ans = 1.0 * (sum[ex][ey] - sum[ex][sy - 1] - sum[sx - 1][ey] + sum[sx - 1][sy - 1]) / ((ex - sx + 1) * (ey - sy + 1)); if (ans &lt;= t) cnt++; } } cout &lt;&lt; cnt &lt;&lt; \"\\n\"; return 0;} 2021092.非零段划分提前记录下来每个值出现过的位置。依次增加 的值，每次找到 个数中等于 的值的位置能产生的贡献（和左右两边 的出现情况有关）。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;const int N = 5e5 + 5;const int M = 1e4 + 5;using namespace std;int n, ans, maxx, a[N];vector&lt;int&gt; f[M];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int cnt = 0; for (int i = 1; i &lt;= n; i++) { f[a[i]].push_back(i); if (a[i] == 0) { if (cnt &gt; 0) { ans++; cnt = 0; } } else cnt++; } if (cnt &gt; 0) ans++; maxx = max(maxx, ans); for (int i = 1; i &lt;= M - 5; i++) { for (auto pos : f[i]) { a[pos] = 0; if (pos == 1 &amp;&amp; a[pos + 1] == 0) ans--; else if (pos == n &amp;&amp; a[pos - 1] == 0) ans--; else { if (a[pos - 1] == 0 &amp;&amp; a[pos + 1] == 0) ans--; else if (a[pos - 1] != 0 &amp;&amp; a[pos + 1] != 0) ans++; } } maxx = max(maxx, ans); } cout &lt;&lt; maxx &lt;&lt; endl; return 0;} 2021122.序列查询新解不难发现 每 个增加 ，故可以按段来统计，注意边界情况的讨论。 2022032.出行计划由题意不难得到有效条件的区间，差分即可。注意双边不等式的左边可能会小于 ，可以通过整体平移的方式（或者和 取 max 的方法）。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;const int lim = 2e5 + 5;using namespace std;int n, m, k, t, c, x, d[lim &lt;&lt; 1];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; t &gt;&gt; c; d[(lim - 5) + t - c - k + 1]++; d[(lim - 5) + t - k + 1]--; } for (int i = 0; i &lt;= (lim - 5) &lt;&lt; 1; i++) d[i] += d[i - 1]; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; x; cout &lt;&lt; d[(lim - 5) + x] &lt;&lt; endl; } return 0;} 2022062.寻宝！大冒险！把大地图中每个为 的点记录下来，用相对坐标依次进行比对，统计即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#define mp make_pair#define fi first#define se secondconst int N = 100;using namespace std;int n, L, S, x, y, ans, b[N][N];vector&lt;pair&lt;int, int&gt; &gt; a, dir;map&lt;pair&lt;int, int&gt;, int&gt; mapp;bool check(pair&lt;int, int&gt; u, pair&lt;int, int&gt; v) { int dx = u.fi + S + 1, dy = u.se + S + 1; if (dx &gt; L + 1 || dy &gt; L + 1) return true; int x = u.fi + v.fi, y = u.se + v.se; return b[v.fi][v.se] ^ mapp[mp(x, y)];}int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; L &gt;&gt; S; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x &gt;&gt; y; mapp[mp(x, y)]++; a.push_back(mp(x, y)); } for (int i = 0; i &lt;= S; i++) { for (int j = 0; j &lt;= S; j++) { cin &gt;&gt; b[i][j]; } } for (int j = 0; j &lt;= S; j++) { for (int i = 0; i &lt; S / 2 + 1; i++) swap(b[i][j], b[S - i][j]); } for (int i = 0; i &lt;= S; i++) { for (int j = 0; j &lt;= S; j++) { if (i == 0 &amp;&amp; j == 0) continue; dir.push_back(mp(i, j)); } } for (auto now : a) { bool flag = true; for (auto dxy : dir) { if (check(now, dxy)) { flag = false; break; } } if (flag) ans++; } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 3.角色授权STL 无脑叠 log， 喜提 70pts. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;const int N = 1e5;using namespace std;int n, m, q, x, id, id1, id2, ido, idc, idr;string ch_name, opt, cls, rnm, name, uname, gname, opname, rcls, rname, ss;map&lt;string, int&gt; mapp, oplist, clslist, rnmlist, ulist, glist;map&lt;int, int&gt; spe1, spe2, ch_opt[N], ch_cls[N], ch_rnm[N], uright[N], gright[N];vector&lt;string&gt; ucon[N], gcon[N], ori[N]; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; while (n--) { cin &gt;&gt; ch_name; mapp[ch_name] = ++id; cin &gt;&gt; x; while (x--) { cin &gt;&gt; opt; if (!oplist[opt]) oplist[opt] = ++ido; ch_opt[id][oplist[opt]] = 1; if (opt == \"*\") spe1[id] = 1; } cin &gt;&gt; x; while (x--) { cin &gt;&gt; cls; if (!clslist[cls]) clslist[cls] = ++idc; ch_cls[id][clslist[cls]] = 1; if (cls == \"*\") spe2[id] = 1; } cin &gt;&gt; x; while (x--) { cin &gt;&gt; rnm; if (!rnmlist[rnm]) rnmlist[rnm] = ++idr; ch_rnm[id][rnmlist[rnm]] = 1; } } while (m--) { cin &gt;&gt; ch_name &gt;&gt; x; while (x--) { cin &gt;&gt; ss &gt;&gt; name; if (ss == \"u\") { if (!ulist[name]) ulist[name] = ++id1; uright[mapp[ch_name]][ulist[name]] = 1; ucon[ulist[name]].push_back(ch_name); } else { if (!glist[name]) glist[name] = ++id2; gright[mapp[ch_name]][glist[name]] = 1; gcon[glist[name]].push_back(ch_name); } } } while (q--) { cin &gt;&gt; uname &gt;&gt; x; if (!ulist[uname]) ulist[uname] = ++id1; while (x--) { cin &gt;&gt; gname; if (!glist[gname]) glist[gname] = ++id2; ori[ulist[uname]].push_back(gname); } bool flag = 0; cin &gt;&gt; opname &gt;&gt; rcls &gt;&gt; rname; for (auto ch_name : ucon[ulist[uname]]) { if (uright[mapp[ch_name]][ulist[uname]]) { if (ch_opt[mapp[ch_name]][oplist[opname]] || spe1[mapp[ch_name]]) { if (ch_cls[mapp[ch_name]][clslist[rcls]] || spe2[mapp[ch_name]]) { if (ch_rnm[mapp[ch_name]].empty() || ch_rnm[mapp[ch_name]][rnmlist[rname]]) { flag = 1; } } } } } if (flag == 0) { for (auto gname : ori[ulist[uname]]) { for (auto ch_name : gcon[glist[gname]]) { if (gright[mapp[ch_name]][glist[gname]]) { if (ch_opt[mapp[ch_name]][oplist[opname]] || spe1[mapp[ch_name]]) { if (ch_cls[mapp[ch_name]][clslist[rcls]] || spe2[mapp[ch_name]]) { if (ch_rnm[mapp[ch_name]].empty() || ch_rnm[mapp[ch_name]][rnmlist[rname]]) { flag = 1; } } } } } } } cout &lt;&lt; flag &lt;&lt; endl; ori[ulist[uname]].clear(); } return 0;} 2022092.何以包邮70pts 二进制枚举，100pts 完全背包。 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;const int lim = 3e5 + 5;using namespace std;int n, m, sum, a[50], f[lim];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; f[0] = 1; for (int i = 1; i &lt;= n; i++) { sum += a[i]; for (int j = lim - 5; j &gt;= a[i]; j--) f[j] |= f[j - a[i]]; } for (int i = m; i &lt;= sum; i++) { if (f[i]) { cout &lt;&lt; i &lt;&lt; endl; return 0; } } return 0;} 202212训练计划建正图反图分别跑一遍。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define mp make_pair#define fi first#define se secondconst int N = 5050;using namespace std;bool flag;int n, m, x, maxx, in[N], nin[N], ans[N], a[N];vector&lt;int&gt; g[N], ng[N];queue&lt;pair&lt;int, int&gt; &gt; q;void dfs(int x) { for (auto to : ng[x]) { ans[to] = min(ans[to], ans[x] - a[to]); dfs(to); }}int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; x; if (x) { g[x].push_back(i); in[i]++; ng[i].push_back(x); nin[x]++; } } for (int i = 1; i &lt;= m; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= m; i++) { if (in[i] == 0) q.push(mp(i, 1)); } while (!q.empty()) { auto now = q.front(); q.pop(); int u = now.fi, w = now.se; ans[u] = w; maxx = max(maxx, ans[u]); if (ans[u] + a[u] - 1 &gt; n) flag = 1; for (auto v : g[u]) { if (--in[v] == 0) q.push(mp(v, ans[u] + a[u])); } } for (int i = 1; i &lt;= m; i++) cout &lt;&lt; ans[i] &lt;&lt; (i == m ? \"\\n\" : \" \"); memset(ans, 0x3f, sizeof(ans)); if (!flag) { for (int i = 1; i &lt;= m; i++) { if (nin[i] == 0) q.push(mp(i, n - a[i] + 1)); } while (!q.empty()) { auto now = q.front(); q.pop(); ans[now.fi] = now.se; dfs(now.fi); } for (int i = 1; i &lt;= m; i++) cout &lt;&lt; ans[i] &lt;&lt; (i == m ? \"\\n\" : \" \"); } return 0;} 2023052.矩阵运算通过交换相乘的次序，化简时间复杂度。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;const int N = 10500;const int D = 25;using namespace std;int n, d, w[N], q[N][D], k[N][D], v[N][D], tk[D][N];long long kv[N][N], ans[N][D];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; d; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= d; j++) cin &gt;&gt; q[i][j]; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= d; j++) { cin &gt;&gt; k[i][j]; tk[j][i] = k[i][j]; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= d; j++) cin &gt;&gt; v[i][j]; } for (int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i]; //d * n * n * d for (int k = 1; k &lt;= n; k++) { for (int i = 1; i &lt;= d; i++) { for (int j = 1; j &lt;= d; j++) kv[i][j] += 1ll * tk[i][k] * v[k][j]; } } //n * d * d * d for (int k = 1; k &lt;= d; k++) { for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= d; j++) ans[i][j] += 1ll * q[i][k] * kv[k][j]; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= d; j++) ans[i][j] = 1ll * ans[i][j] * w[i]; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= d; j++) cout &lt;&lt; ans[i][j] &lt;&lt; (j == d ? \"\\n\" : \" \"); } return 0;} 2023092.坐标变换(其二)由于每次操作中的 伸缩倍数一样，即若单独考虑经过所有的伸缩操作后， 变成了 ， 不难得出 。同时发现逆时针旋转的操作的角度可以叠加，故用一个前缀积数组存伸缩操作，一个前缀和数组存旋转操作，最终依次直接计算即可。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define mp make_pair#define fi first#define se secondconst int N = 1e5 + 5;const int INF = 1 &lt;&lt; 30;using namespace std;int n, m, opt, i, j;double x, y, mul[N], sum[N];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; m; mul[0] = 1.0; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; opt &gt;&gt; x; if (opt == 1) { mul[i] = mul[i - 1] * x; sum[i] = sum[i - 1]; } else { mul[i] = mul[i - 1]; sum[i] = sum[i - 1] + x; } } while (m--) { cin &gt;&gt; i &gt;&gt; j &gt;&gt; x &gt;&gt; y; double nowk = mul[j] / mul[i - 1], nowth = sum[j] - sum[i - 1], ncos = cos(nowth), nsin = sin(nowth); printf(\"%lf %lf\\n\", nowk * (x * ncos - y * nsin), nowk * (x * nsin + y * ncos)); } return 0;}","link":"/2023/09/01/CSP%E8%AE%A4%E8%AF%81%E5%A4%8D%E5%BB%BA%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8E2023-09%E5%81%9C%E6%9B%B4%EF%BC%89/"},{"title":"2023寒假acm训练（5）","text":"A.Cleaning the PhoneLinkhttps://codeforces.com/contest/1475/problem/D Statement给定 个物品，每个物品均有两个属性 ，现在需要确定一个序列 ，使得在满足 的前提下 最小。若可以则输出对应的 。 Solution考虑到 的取值只有两种，结合“定一动一”的思想，我们可以将物品按照 分类后，分别按照 的大小倒序排序，枚举选前 个 的物品，二分求得满足前提的最小的需要选择的 的物品的个数，进行统计即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;typedef long long ll;const int INF = 1 &lt;&lt; 30;const int N = 2e5 + 5;using namespace std;int T, n, m, num[3], a[N], b[N], c[3][N];ll sum[3][N];bool check(int p1, int p2) { return sum[1][p1] + sum[2][p2] &gt;= m; }int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { ll tot = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; tot += a[i]; } for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; b[i]; c[b[i]][++num[b[i]]] = a[i]; } if (tot &lt; m) { cout &lt;&lt; \"-1\" &lt;&lt; \"\\n\"; num[1] = num[2] = 0; continue; } for (int i = 1; i &lt;= 2; i++) sort(c[i] + 1, c[i] + num[i] + 1, greater&lt;int&gt;()); for (int i = 1; i &lt;= 2; i++) { for (int j = 1; j &lt;= num[i]; j++) sum[i][j] = sum[i][j - 1] + c[i][j]; } int ans = INF; for (int i = 0; i &lt;= num[1]; i++) { int l = 0, r = num[2], pos = -1; while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if (check(i, mid)) { pos = mid; r = mid - 1; } else l = mid + 1; } if (pos != -1) ans = min(ans, i + 2 * pos); } cout &lt;&lt; ans &lt;&lt; \"\\n\"; num[1] = num[2] = 0; } return 0;} B.Unusual MatrixLinkhttps://codeforces.com/contest/1475/problem/F Statement给定两个 的 01 矩阵 ，定义一种操作：选择矩阵 的第 行或第 列，将这一行/这一列上的所有数字全部与 异或。询问是否在一定次数的操作后，可以使 。 Solution关键性质是：1.异或运算与次序无关2. 只有与 异或奇数次才会改变，故某一行或某一列最多需要使用该操作一次 结合以上两条性质，我们只需先考虑第一行的数字，找出需要异或的列；之后考虑第一列的数字，找出需要异或的行。最后判断 是否等于 即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;const int N = 1050;using namespace std;int T, n, a[N][N], b[N][N], flagi[N], flagj[N];char c[N][N], d[N][N];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { cin &gt;&gt; c[i][j]; a[i][j] = c[i][j] - '0'; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { cin &gt;&gt; d[i][j]; b[i][j] = d[i][j] - '0'; } } for (int j = 1; j &lt;= n; j++) flagj[j] |= (a[1][j] != b[1][j]); for (int i = 2; i &lt;= n; i++) { if (flagj[1]) flagi[i] |= ((a[i][1] ^ 1) != b[i][1]); else flagi[i] |= (a[i][1] != b[i][1]); } bool flag = false; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { a[i][j] = (flagi[i] + flagj[j] == 1) ? (a[i][j] ^ 1) : a[i][j]; if (a[i][j] != b[i][j]) { flag = true; break; } } if (flag) break; } flag ? cout &lt;&lt; \"No\" &lt;&lt; \"\\n\" : cout &lt;&lt; \"Yes\" &lt;&lt; \"\\n\"; memset(flagi, 0, sizeof(flagi)); memset(flagj, 0, sizeof(flagj)); } return 0;} C.SticksLinkhttps://codeforces.com/gym/103652/problem/K Statement给定 根火柴的长度，每根火柴只能使用一次，确定其最大能表示出多少个三角形，并输出方案。 Solution考虑状态压缩以及使用位运算来简化过程。用一个长度为 的二进制串，第 位表示第 根火柴是否被使用。则一个合法的三角形的状态，二进制表示下会有 个 。首先统计出所有可能的三角形的状态，之后判断这些状态是否互相不干扰。考虑枚举，假设两个不相同的三角形状态分别为 ，他们互不干扰的充要条件是 。若他们互不干扰，则可以保证答案至少为 。此时可以查询他们的补集是否出现且合法，若是则答案为 ，直接输出方案即可，同时记录下这个答案为 的方案。若否，考虑构造 的可能方案。枚举 的可能方案时，可以枚举哪 根火柴不用和 组的情况，再判断他们的补集是否出现过（剩下 组）。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;const int lim = 1 &lt;&lt; 14;using namespace std;int T, a[20], pii[lim];vector&lt;int&gt; f;void print(int now) { vector&lt;int&gt; out(5); out.clear(); for (int i = 0; i &lt; 12; i++) { if ((now &gt;&gt; i) &amp; 1) out.push_back(a[i]); } for (int i = 0; i &lt; out.size(); i++) { cout &lt;&lt; out[i]; if (i != out.size() - 1) cout &lt;&lt; \" \"; } cout &lt;&lt; endl;}void solve() { // 12! / (3! 3! 3! 3! 4!) = 15400 int ans = 0, one = 0, two = 0, st = (1 &lt;&lt; 12) - 1; f.clear(); memset(pii, 0, sizeof(pii)); for (int i = 0; i &lt; 12; i++) { for (int j = i + 1; j &lt; 12; j++) { for (int k = j + 1; k &lt; 12; k++) { if (a[i] + a[j] &gt; a[k] &amp;&amp; a[j] + a[k] &gt; a[i] &amp;&amp; a[i] + a[k] &gt; a[j]) { int sta = (1 &lt;&lt; i) | (1 &lt;&lt; j) | (1 &lt;&lt; k); f.push_back(sta); ans = 1; one = sta; } } } } for (auto s : f) { for (auto t : f) { if (!(s &amp; t)) { ans = 2; two = s | t; pii[s | t] = s; int op = st ^ (s | t); if (pii[op]) { cout &lt;&lt; \"4\" &lt;&lt; \"\\n\"; print(s); print(t); print(pii[op]); print(op ^ pii[op]); return ; } } } } for (int i = 0; i &lt; 12; i++) { for (int j = i + 1; j &lt; 12; j++) { for (int k = j + 1; k &lt; 12; k++) { int sta = (1 &lt;&lt; i) | (1 &lt;&lt; j) | (1 &lt;&lt; k); for (auto r : f) { if (r &amp; sta) continue; int tw = st ^ (sta | r); if (pii[tw]) { cout &lt;&lt; \"3\" &lt;&lt; \"\\n\"; print(r); print(pii[tw]); print(tw ^ pii[tw]); return ; } } } } } cout &lt;&lt; ans &lt;&lt; \"\\n\"; if (ans == 0) return ; else if (ans == 1) print(one); else print(pii[two]), print(two ^ pii[two]);}int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; for (int t = 1; t &lt;= T; t++) { for (int i = 0; i &lt; 12; i++) cin &gt;&gt; a[i]; cout &lt;&lt; \"Case #\" &lt;&lt; t &lt;&lt; \": \"; solve(); } return 0;}","link":"/2023/01/18/2023%E5%AF%92%E5%81%87acm%E8%AE%AD%E7%BB%83%EF%BC%885%EF%BC%89/"},{"title":"2023寒假acm训练（4）","text":"A.Factory BallsLinkhttps://codeforces.com/group/sg0CXKHVzz/contest/421181/problem/A Statement给出 个编号为 的点，初始每个点的颜色都为 。有 种装备，每种装备会遮住一些位置（不一定是连续区间）。每一个时刻可以进行如下操作之一：1.选择一种颜色 ，将所有没有被装备遮住的位置染上颜色 。2.选择一个没有装上的装备装上它。3.卸下一个装备。给出每个位置最后的颜色 ，询问是否能达到最终状态（并且没有装任何装备），若可以则输出最少步数。 Solution观察到数据范围后考虑搜索所有的状态，从中求得最小步数。 若枚举每个位置的所有颜色，总状态数将变成 ，过于庞大。不难发现其实不用关注每个区域的具体颜色，只用关心是否染上了最终状态的颜色即可。因此在 bfs 时记录两个二进制串，第一个串长度为 ，其第 位为 表示第 块的颜色是最终颜色，为 表示是其他颜色；第二个串长度为 ，其第 位为 表示第 种装备已被使用，为 表示未被使用。这样被枚举到的状态数则优化到了 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define mp make_pair#define fi first#define se secondconst int lim = 1 &lt;&lt; 12;const int N = 20;using namespace std;int n, k, m, x, t, a[N], f[lim][lim];bool vis[N];vector&lt;int&gt; eq[N];queue&lt;pair&lt;int, int&gt; &gt; q;void bfs(int state) { memset(f, 0x3f, sizeof(f)); f[state][0] = 0; q.push(mp(state, 0)); while (!q.empty()) { auto now = q.front(); q.pop(); int sta1 = now.fi, sta2 = now.se; memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= m; i++) { if ((sta2 &gt;&gt; (i - 1)) &amp; 1) { for (auto j : eq[i]) vis[j] = 1; } } for (int c = 1; c &lt;= k; c++) { int res1 = sta1; for (int p = 1; p &lt;= n; p++) { if (vis[p]) continue; if (a[p] == c) { res1 |= (1 &lt;&lt; (p - 1)); continue; } if ((res1 &gt;&gt; (p - 1)) &amp; 1) res1 ^= (1 &lt;&lt; (p - 1)); } if (f[res1][sta2] &gt; f[sta1][sta2] + 1) { f[res1][sta2] = f[sta1][sta2] + 1; q.push(mp(res1, sta2)); } } for (int i = 1; i &lt;= m; i++) { int res2 = sta2 ^ (1 &lt;&lt; (i - 1)); if (f[sta1][res2] &gt; f[sta1][sta2] + 1) { f[sta1][res2] = f[sta1][sta2] + 1; q.push(mp(sta1, res2)); } } }}int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; t; for (int j = 1; j &lt;= t; j++) { cin &gt;&gt; x; eq[i].push_back(x); } } int state = 0, fina = (1 &lt;&lt; n) - 1; for (int i = 1; i &lt;= n; i++) state |= (a[i] == 1) ? (1 &lt;&lt; (i - 1)) : 0; bfs(state); f[fina][0] == 0x3f3f3f3f ? cout &lt;&lt; \"-1\" &lt;&lt; \"\\n\" : cout &lt;&lt; f[fina][0] &lt;&lt; \"\\n\"; return 0;} B.Triple Sword StrikeLinkhttps://codeforces.com/gym/103855/problem/D Statement二维平面上有一些不重复的点 ，每个点上还有一个权值。每次你可以选择一条平行于 轴或者 轴的直线，选择后你将收获这条线穿过的点的权值的和，这些点在被第一次穿过后也将消失。你现在可以选择 条这样的直线，最大化你收获到的权值和。 Solution点的坐标不大，可以直接作为下标用来统计横坐标为 的点的集合和他们的和（纵坐标为 的同理）。对 条直线分类讨论：三横、三竖、两横一竖、两竖一横。前两种情况直接选择和前三大的即可，后面两种情况可以枚举哪条线上的点被算重，查找删除更新，在 multiset 中维护即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;typedef long long ll;const int N = 3e6 + 5;const int lim = 1e6;using namespace std;multiset&lt;ll, greater&lt;ll&gt; &gt; sx, sy;vector&lt;int&gt; xx[lim + 5], yy[lim + 5];int n, x[N], y[N], v[N];ll val_x[lim + 5], val_y[lim + 5];void solve1(ll &amp;ans) { for (int i = 0; i &lt;= lim; i++) if (val_x[i]) sx.insert(val_x[i]); int num1 = 0; ll res1 = 0; for (auto c : sx) { ++num1; res1 += c; if (num1 == 3) break; } ans = max(ans, res1); for (int i = 0; i &lt;= lim; i++) if (val_y[i]) sy.insert(val_y[i]); int num2 = 0; ll res2 = 0; for (auto c : sy) { ++num2; res2 += c; if (num2 == 3) break; } ans = max(ans, res2);}void solve2(ll &amp;ans) { for (int i = 0; i &lt;= lim; i++) { if (!xx[i].size()) continue; ll sum1 = val_x[i]; for (auto tar : xx[i]) { auto it = sy.find(val_y[y[tar]]); sy.erase(it); val_y[y[tar]] -= v[tar]; sy.insert(val_y[y[tar]]); } int num2 = 0; for (auto c : sy) { ++num2; sum1 += c; if (num2 == 2) break; } ans = max(ans, sum1); for (auto tar : xx[i]) { auto it = sy.find(val_y[y[tar]]); sy.erase(it); val_y[y[tar]] += v[tar]; sy.insert(val_y[y[tar]]); } } for (int i = 0; i &lt;= lim; i++) { if (!yy[i].size()) continue; ll sum2 = val_y[i]; for (auto tar : yy[i]) { auto it = sx.find(val_x[x[tar]]); sx.erase(it); val_x[x[tar]] -= v[tar]; sx.insert(val_x[x[tar]]); } int num1 = 0; for (auto c : sx) { ++num1; sum2 += c; if (num1 == 2) break; } ans = max(ans, sum2); for (auto tar : yy[i]) { auto it = sx.find(val_x[x[tar]]); sx.erase(it); val_x[x[tar]] += v[tar]; sx.insert(val_x[x[tar]]); } }}int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; v[i]; xx[x[i]].push_back(i); val_x[x[i]] += v[i]; yy[y[i]].push_back(i); val_y[y[i]] += v[i]; } ll ans = 0; solve1(ans); solve2(ans); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;} C.Short QuestionLink给定 以及 和 ，计算下式的值： \\sum_{i = 1} ^ {n} \\sum_{j = 1} ^ n min(|p_i - p_j|, |q_i - q_j|)Solution带有min以及max这类的式子难以求值，考虑将其拆开。一个显然且重要的结论是 ，利用该式子可以化简： min(|p_i - p_j|, |q_i - q_j|) = \\\\ |p_i - p_j| + |q_i - q_j| - max(|p_i - p_j|, |q_i - q_j|)若将 看作二维平面上的点的坐标，上式可以等效为求二维平面上所有点对之间的 曼哈顿距离 减去 切比雪夫距离 的和。 曼哈顿距离与切比雪夫距离的转换问题比较常见，不再赘述。常用的 tips 是： —-&gt; ，此时原坐标系中的曼哈顿距离 = 新坐标系中的切比雪夫距离。 —-&gt; ，此时原坐标系中的切比雪夫距离 = 新坐标系中的曼哈顿距离。 因此上式中的切比雪夫距离部分可以也可以转换为求曼哈顿距离中 sigma 绝对值的形式来计算。 考虑如何算 ：由于 独立，可以把 进行升序排序，这样可以省去绝对值的运算。具体而言， 始终大于前 个的 ，贡献为正，且始终小于后 个的 ，贡献为负。因此： \\sum _{i = 1} ^ n \\sum _{j = 1} ^ n |p_i - p_j| = 2 \\cdot \\sum _{i = 1} ^ n ((i - 1) - (n - i)) \\cdot p_i对以上绝对值分别求值后相加即可。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;const int N = 1e6 + 5;using namespace std;int n, p[N], q[N], np[N], nq[N];long long ans1, ans2;int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i]; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; q[i]; for (int i = 1; i &lt;= n; i++) { np[i] = (p[i] + q[i]); nq[i] = (p[i] - q[i]); } sort (p + 1, p + n + 1); sort (q + 1, q + n + 1); sort (np + 1, np + n + 1); sort (nq + 1, nq + n + 1); for (int i = 1; i &lt;= n; i++) ans1 += 1ll * ((i - 1) - (n - i)) * p[i]; for (int i = 1; i &lt;= n; i++) ans1 += 1ll * ((i - 1) - (n - i)) * q[i]; for (int i = 1; i &lt;= n; i++) ans2 += 1ll * ((i - 1) - (n - i)) * np[i]; for (int i = 1; i &lt;= n; i++) ans2 += 1ll * ((i - 1) - (n - i)) * nq[i]; cout &lt;&lt; 2 * ans1 - ans2 &lt;&lt; endl; return 0;}","link":"/2023/01/16/2023%E5%AF%92%E5%81%87acm%E8%AE%AD%E7%BB%83%EF%BC%884%EF%BC%89/"},{"title":"2023寒假acm训练（3）","text":"A.Fill The BagLinkhttps://codeforces.com/contest/1303/problem/D Statement给定一个正整数 和 个数 ，保证所有 都是 的整数次幂。询问是否存在一个长度为 的序列 ，使得： \\sum _ {i = 1} ^ {m} \\frac {a_i}{2 ^ {x_i}} = n且 最小。若存在则输出 。 Solution由于 是 的整数次幂，则 则可以看作是 的二进制表示。原问题可以转化为：是否可以通过已有的一些个 的整数次幂，“凑”出 的二进制表示。 大的数只能往小变，小的数可以拼凑成大的数。且由于要最小化 div次数，我们可以按位从低到高考虑。假设当前即将考虑第 位，我们可以先试着用 位的来凑第 位的。若凑不出来，那就用 后面的有的最小的来凑 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;typedef long long ll;const int N = 1e5 + 5;using namespace std;int T, m, a[N];ll n, cnt[100];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { cin &gt;&gt; n &gt;&gt; m; ll sum = 0; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; a[i]; sum += a[i]; int ex = log2(a[i]); cnt[ex]++; } if (sum &lt; n) cout &lt;&lt; \"-1\" &lt;&lt; endl; else { ll ans = 0; for (int i = 0; i &lt; 60; i++) { if ((n &gt;&gt; i) &amp; 1) { int pos = i; while (!cnt[pos]) ++pos; --cnt[pos]; while (pos &gt; i) { --pos; cnt[pos]++; ++ans; } } cnt[i + 1] += cnt[i] / 2; } cout &lt;&lt; ans &lt;&lt; endl; } memset(cnt, 0, sizeof(cnt)); } return 0;} B.Obtain The StringLinkhttps://codeforces.com/contest/1295/problem/C Statement给定两个字符串 与 ，令 为空串。定义一种操作：每次可以选择 的一个字串 （非连续也可以），并把 加入 的末尾。询问是否能使 ，若可以输出最小的操作次数。 Solution定义 表示 中从 第 位开始的后缀串中字母 出现的最早位置。 从后往前扫一遍即可得到这个 。结合贪心的思想，每一次新的操作从第一位往后跳即可，跳到末尾则进行下一次操作。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;const int INF = 1 &lt;&lt; 30;const int N = 2e5 + 5;using namespace std;int T, g[N][30];char s[N], t[N];set&lt;char&gt; ss;int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { cin &gt;&gt; (s + 1) &gt;&gt; (t + 1); int lens = strlen(s + 1), lent = strlen(t + 1); for (int i = 1; i &lt;= lens; i++) ss.insert(s[i]); bool flag = false; for (int i = 1; i &lt;= lent; i++) { if (!ss.count(t[i])) { flag = true; break; } } ss.clear(); if (flag) cout &lt;&lt; \"-1\" &lt;&lt; endl; else { for (int j = 1; j &lt;= 26; j++) g[lens + 1][j] = INF; for (int i = lens; i &gt;= 1; i--) { for (int j = 1; j &lt;= 26; j++) g[i][j] = g[i + 1][j]; g[i][s[i] - 'a' + 1] = i; } int pos = 1, now = 1, cnt = 0; bool sign = false; while (now &lt;= lent) { if (g[pos][t[now] - 'a' + 1] == INF) { cnt++; pos = 1; sign = false; } else pos = g[pos][t[now] - 'a' + 1] + 1, now++, sign = true; if (pos == lens + 1) { cnt++; pos = 1; sign = false; } } if (sign) cnt++; cout &lt;&lt; cnt &lt;&lt; endl; } } return 0;}","link":"/2023/01/14/2023%E5%AF%92%E5%81%87acm%E8%AE%AD%E7%BB%83%EF%BC%883%EF%BC%89/"},{"title":"2023寒假acm训练（2）","text":"A.Odd DivisorLinkhttps://codeforces.com/contest/1475/problem/A Statement给定一个正整数 ，判断其是否至少有一个大于 的奇因子。 Solution若 为奇数，那 本身就是一个符合条件的奇因子。 考虑偶数的情况：偶数可以由两个偶数相乘得到，也可以通过一奇一偶相乘得到。能被表示成 的 次幂的 只会属于第一种情况，其他则可以表示为第二种。判断 是否为 的 次幂有两种方法：(1) 看 是否为 。（2）不断除 直至最后变成 ，途中不出现奇质因子。 B.Advertising AgencyLinkhttps://codeforces.com/contest/1475/problem/E Statement给定 个数，从中选 个，要求 最大，求方案数。 Solution由于 最大且固定，那么所有方案本质上都是相同的。（反证法：将 按降序排序，若存在 使得方案更优，说明 , 那其必定排在前 大，与已知条件矛盾）。 故答案取决于前 大的数中，最小的那个数 的个数。令 表示 个数中 出现的次数， 表示前 大的数中严格大于 的个数，易得答案为 。 Code12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;const int lim = 1000;const int mod = 1e9 + 7;using namespace std;int T, n, k, a[lim + 5], c[lim + 5][lim + 5];void init() { c[0][0] = 1; for (int i = 1; i &lt;= lim; i++) { c[i][0] = 1; for (int j = 1; j &lt;= i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod; }}int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; init(); while (T--) { cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; sort(a + 1, a + n + 1, greater&lt;int&gt;()); int cnt1 = 0, cnt2 = 0, minn = a[k]; for (int i = 1; i &lt;= n; i++) { cnt1 += (a[i] == minn); cnt2 += (a[i] &gt; minn); } cout &lt;&lt; c[cnt1][k - cnt2] &lt;&lt; \"\\n\"; } return 0;} C.Perfect KeyboardLinkhttps://codeforces.com/contest/1303/problem/C Statement给定一个仅包含小写字母且相邻字母不一样的字符串 ，将 abcdefg...xyz 重排，重排后的字符串为 ，询问是否能使得 中相邻的字母在 中也全部相邻，若可以则输出方案。 Solution将 中相邻的字母进行连边（始终保证由字典序小的连接字典序大的），不难发现若出现度数大于 的节点或有环出现时，则答案不存在。否则可以从度数为 的点出发，对树进行深度优先遍历并记录路径，得到的答案序列则是符合条件的。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;const int N = 50;using namespace std;string s;int T, deg[N];bool vis[N], g[N][N];void dfs(int x, string &amp;ans) { vis[x] = 1; ans += (char)('a' + x - 1); for (int i = 1; i &lt;= 26; i++) { if ((!g[x][i]) || (vis[i])) continue; dfs(i, ans); }}int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { cin &gt;&gt; s; if ((int)s.length() == 1) { cout &lt;&lt; \"YES\" &lt;&lt; endl; for (char c = 'a'; c &lt;= 'z'; c++) cout &lt;&lt; c; cout &lt;&lt; endl; continue; } for (int i = 0; i &lt; (int)s.length() - 1; i++) g[s[i] - 'a' + 1][s[i + 1] - 'a' + 1] = g[s[i + 1] - 'a' + 1][s[i] - 'a' + 1] = 1; for (int i = 1; i &lt;= 26; i++) { for (int j = i + 1; j &lt;= 26; j++) { if (g[i][j]) { deg[i]++; deg[j]++; } } } bool flag = 0; for (int i = 1; i &lt;= 26; i++) flag |= (deg[i] &gt; 2); string ans = \"\"; bool sign = 0; for (int i = 1; i &lt;= 26; i++) { if (deg[i] == 1 &amp;&amp; (!vis[i])) { sign = true; dfs(i, ans); } } if (flag || (!sign)) cout &lt;&lt; \"NO\" &lt;&lt; endl; else { cout &lt;&lt; \"YES\" &lt;&lt; endl; for (char c = 'a'; c &lt;= 'z'; c++) { if (!vis[c - 'a' + 1]) ans += c; } cout &lt;&lt; ans &lt;&lt; endl; } memset(g, 0, sizeof(g)); memset(deg, 0, sizeof(deg)); memset(vis, 0, sizeof(vis)); } return 0;}","link":"/2023/01/14/2023%E5%AF%92%E5%81%87acm%E8%AE%AD%E7%BB%83%EF%BC%882%EF%BC%89/"},{"title":"2023寒假acm训练（1）","text":"A.Yet Another TournamentLinkhttps://codeforces.com/contest/1783/problem/C Statement除了你以外有 个人，编号为 ，每个人有两个权值 和 ，其中 ， 给定。现在你要同这 个人依据 的大小来排名（ 越大排名越靠前，你的排名等于 严格大于你的人的个数）。 你的 的大小等于 ，且需要满足 (在 个人中选 个人，他们的 的和不大于一个给定的数 ，此时的 就作为你的 的值)。 最小化你的最终排名。 Solution假设你最终赢了 个人。不难发现 和 的人，无论你是否选择了他们，他们都不会影响你的最终排名。所以只有 的人会影响你的最终排名。那我们只需先最大化自己赢的人的个数，最终判断能否选第 个人即可。 Code123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int T, n, m;int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n); for (auto &amp;x : a) cin &gt;&gt; x; auto b = a; sort(b.begin(), b.end()); int sum = 0, cnt = 0; for (auto x : b) { if (x + sum &gt; m) break; sum += x; ++cnt; } if (cnt == 0) cout &lt;&lt; n + 1 &lt;&lt; endl; else if (cnt == n) cout &lt;&lt; 1 &lt;&lt; endl; else (sum + a[cnt] - b[cnt - 1] &lt;= m) ? cout &lt;&lt; n - cnt &lt;&lt; endl : cout &lt;&lt; n - cnt + 1 &lt;&lt; endl; } return 0;} B.Consonant FencityLinkhttps://codeforces.com/gym/101612/attachments/download/6287/20172018-acmicpc-neerc-northern-subregional-contest-en.pdf Statement定义以下集合： U = \\{ 'a' \\to 'z' \\} \\\\ S = \\{ 'a', 'e', 'i', 'o', 'u', 'w', 'y' \\} \\\\ T = \\{ c \\ | \\ c \\in U, c \\notin S \\}给定字符串 , 函数 等于「 中相邻字母均是 中的元素且大小写形式互不相同」的相邻对数。现在你可以改变任意字母在 中出现的大小写形式，但 中不同位置的本质相同的字母的形式均要相同，修改过后最终的字符串称作 。最大化 并输出 。 Solution考虑到 ，因此可以用一个二进制串来表示每一位（ 中每一种字母）的大小写形式， 表示大小，.） 提前统计好 中出现过的 “ 元素对” 的个数，按题意统计即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;const int N = 100;const char a[] = {'a', 'e', 'i', 'o', 'u', 'w', 'y'};const char b[] = {'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'x', 'z'};using namespace std;string s;bool con[N], vis[N];int num[N][N];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"consonant.in\", \"r\", stdin); freopen(\"consonant.out\", \"w\", stdout); cin &gt;&gt; s; for (int i = 0; i &lt; 7; i++) con[a[i] - 'a'] = true; for (int i = 0; i &lt; s.length() - 1; i++) { if (!(con[s[i] - 'a'] &amp; con[s[i + 1] - 'a'])) { num[s[i] - 'a'][s[i + 1] - 'a']++; num[s[i + 1] - 'a'][s[i] - 'a']++; } } int ans = 0, maxx = 0; for (int sta = 0; sta &lt; (1 &lt;&lt; 19); sta++) { int res = 0; for (int i = 0; i &lt; 19; i++) { if ((sta &gt;&gt; i) &amp; 1) { for (int j = 0; j &lt; 19; j++) { if (!((sta &gt;&gt; j) &amp; 1)) res += num[b[i] - 'a'][b[j] - 'a']; } } } if (res &gt; maxx) { maxx = res; ans = sta; } } for (int i = 0; i &lt; 19; i++) vis[b[i] - 'a'] = ((ans &gt;&gt; i) &amp; 1); for (int i = 0; i &lt; s.length(); i++) vis[s[i] - 'a'] ? cout &lt;&lt; (char)toupper(s[i]) : cout &lt;&lt; s[i]; return 0;} C.Intelligence in PerpendiculariaLinkhttps://codeforces.com/gym/101612/attachments/download/6287/20172018-acmicpc-neerc-northern-subregional-contest-en.pdf Statement在一个平面直角坐标系中 描绘一个封闭图形，该图形的每条边均与 轴或 轴平行，现在沿 轴正、负方向， 轴正、负方向（四个方向）“发射阳光”，问“照不到阳光”的线段的总长度。 上图中答案为 6。 Solution由于坐标的范围不大，因此可以使用坐标的值当作下标，记录每个 或 经过的次数，不难发现只有经过次数大于 的线段才“照不到阳光”，且可以随着经过次数的增大被重复统计。 整个过程用差分的思想即可，即分别对 和 进行差分，最终统计累加即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;const int lim = 1e6 + 1;typedef long long ll;using namespace std;int n, x[lim + 5], y[lim + 5];ll dx[2 * lim + 5], dy[2 * lim + 5];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"intel.in\", \"r\", stdin); freopen(\"intel.out\", \"w\", stdout); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x[i] &gt;&gt; y[i]; x[i] += lim; y[i] += lim; } x[n + 1] = x[1], y[n + 1] = y[1]; for (int i = 2; i &lt;= n + 1; i++) { if (x[i] == x[i - 1]) { int sy = min(y[i], y[i - 1]), ey = max(y[i], y[i - 1]); dy[sy]++; dy[ey]--; } else { int sx = min(x[i], x[i - 1]), ex = max(x[i], x[i - 1]); dx[sx]++; dx[ex]--; } } ll ans = 0; for (int i = 1; i &lt;= lim * 2 - 1; i++) { dx[i] += dx[i - 1]; dy[i] += dy[i - 1]; ans += max(0ll, dx[i] - 2); ans += max(0ll, dy[i] - 2); } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2023/01/10/2023%E5%AF%92%E5%81%87acm%E8%AE%AD%E7%BB%83%EF%BC%881%EF%BC%89/"},{"title":"Atcoder Beginner Contest 284","text":"A.Happy New Year 2023Linkhttps://atcoder.jp/contests/abc284/tasks/abc284_d Statement将给定的 分解成 的形式，其中 为两个不相同的质数 。 Solution由于 很大，可以使用时间复杂度较优的 Pollard’s rho 算法。 也可以观察到，是 级别的。因此我们可以枚举这个值 ，判断它是否可以作为 或 。 可以作为 的条件是 ，可以作为 的条件是 且 是完全平方数。 Code1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int T;ll n;bool issquare(ll x) { return (ll)sqrt(x) == sqrt(x); }int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { cin &gt;&gt; n; for (ll i = 2; i * i * i &lt;= n; i++) { if (n % i == 0 &amp;&amp; issquare(n / i)) { cout &lt;&lt; (ll)sqrt(n / i) &lt;&lt; \" \" &lt;&lt; i &lt;&lt; endl; break; } if (n % (i * i) == 0) { cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; n / i / i &lt;&lt; endl; break; } } } return 0;} B.Count Simple PathsLinkhttps://atcoder.jp/contests/abc284/tasks/abc284_e Statement给定一个 个点 条边的无向图，保证每个点的度数在 以内，求出从 号节点为起点的所有简单路径的个数。（若个数大于 则输出 ）。 Solution朴素想法是直接对图进行dfs遍历。关键点是题目中对于度数的限制。有了这个限制，可以保证“在搜索的过程中不会因为进入一个不优的节点而需要耗费相当多的代价再走回来”。因此时间复杂度是正确的。 C.ABCBACLinkhttps://atcoder.jp/contests/abc284/tasks/abc284_f Statement对于一个长度为 的字符串 ，通过 构造出一个长度为 的字符串 。 ： 的前 个字母 + 的倒序字符串 + 的后 个字母。 现给出 和 ，询问是否能得到一组可行的 和 。有解则输出方案。 Solution枚举 ，同时结合字符串双哈希即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define fi first#define se second#define mp make_pairconst int N = 2e6 + 5;typedef long long ll;using namespace std;int n;string t;//Double Hash Modeltypedef pair&lt;int, int&gt; Hash;const ll mod1 = 1e9 + 7;const ll mod2 = 1e9 + 9;Hash operator + (Hash a, Hash b) { int c1 = a.fi + b.fi, c2 = a.se + b.se; if (c1 &gt;= mod1) c1 -= mod1; if (c2 &gt;= mod2) c2 -= mod2; return mp(c1, c2);}Hash operator - (Hash a, Hash b) { int c1 = a.fi - b.fi, c2 = a.se - b.se; if (c1 &lt; 0) c1 += mod1; if (c2 &lt; 0) c2 += mod2; return mp(c1, c2);}Hash operator * (Hash a, Hash b) { int c1 = 1ll * a.fi * b.fi % mod1, c2 = 1ll * a.se * b.se % mod2; return mp(c1, c2);}Hash pw[N], pre[N], suf[N];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; t; n *= 2; Hash base = mp(13331, 23333); pw[0] = mp(1, 1); for (int i = 1; i &lt;= n; i++) { pw[i] = pw[i - 1] * base; pre[i] = pre[i - 1] * base + mp(t[i - 1], t[i - 1]); } for (int i = n; i &gt;= 1; i--) suf[i] = suf[i + 1] * base + mp(t[i - 1], t[i - 1]); for (int i = 0; i &lt;= n / 2; i++) { Hash res1 = (pre[i] * pw[n / 2 - i]) + (pre[n] - pre[i + n / 2] * pw[n / 2 - i]); Hash res2 = suf[i + 1] - suf[i + 1 + n / 2] * pw[n / 2]; if (res1 == res2) { cout &lt;&lt; t.substr(0, i) + t.substr(i + n / 2, n - i) &lt;&lt; endl; cout &lt;&lt; i &lt;&lt; endl; return 0; } } cout &lt;&lt; \"-1\" &lt;&lt; endl; return 0;}","link":"/2023/01/08/Atcoder%20Beginner%20Contest%20284/"},{"title":"Codeforces Round 842(Div.2)","text":"A.Greatest ConvexLinkhttps://codeforces.com/contest/1768/problem/A Description求出最大的 ，使得 是 的倍数。 Solution x! + (x - 1)! = (x + 1) \\cdot (x - 1)!当 时，，该值始终为 的倍数。故输出 即可。 Codehttps://codeforces.com/contest/1768/submission/188069238 B.Quick SortLinkhttps://codeforces.com/contest/1768/problem/B Description定义一种操作：对一个长度为 的排列，每次可以从排列中任意选出 个数（将这些数从原排列中删除），将他们按升序排列后加到原排列末尾。最小化使得这个长度为 的排列整体升序的操作次数。 Solution需要发现，以 为开头的、连续的上升序列，这些数字是不用选中的，其余的都需要选。直接计算 即可。 Code12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;const int N = 2e5 + 5;using namespace std;int T, n, m, a[N];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { int cnt = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int now = 1; for (int i = 1; i &lt;= n; i++) { if (a[i] == now) now++; } cout &lt;&lt; (n - now + 1 + m - 1) / m &lt;&lt; endl; } return 0;} C. Elemental DecompressLinkhttps://codeforces.com/contest/1768/problem/C Description给定一个序列 ，询问是否存在两个长度为 的排列 ，使得 。若存在，需输出方案。 Solution出现以下任意一种情况都是无解的：中未出现过、中的出现次数大于、中任意一个数字的出现次数大于。 确定有解后，先把那些一定要填的数字填好，剩余数字结合贪心思路，每次能往大里填（结合_即可）。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;const int N = 2e5 + 5;using namespace std;int T, n, cnt[N], a[N], ans1[N], ans2[N];bool vis1[N], vis2[N];vector&lt;int&gt; fi, se;int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { bool flag = false; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cnt[i] = 0; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; cnt[a[i]]++; if (cnt[a[i]] &gt; 2) flag = true; } flag |= (cnt[1] == 2); flag |= (!cnt[n]); if (flag) cout &lt;&lt; \"NO\" &lt;&lt; endl; else { fi.clear(); se.clear(); for (int i = 1; i &lt;= n; i++) { vis1[i] = vis2[i] = false; ans1[i] = ans2[i] = 0; } for (int i = 1; i &lt;= n; i++) { if (!vis1[a[i]]) { vis1[a[i]] = true; ans1[i] = a[i]; } else { ans2[i] = a[i]; vis2[a[i]] = true; } if (a[i] == 1) { vis1[1] = vis2[1] = true; ans1[i] = ans2[i] = 1; } } for (int i = n; i &gt;= 1; i--) { if (!vis1[i]) se.push_back(i); if (!vis2[i]) fi.push_back(i); } for (int i = 1; i &lt;= n; i++) { if (!ans1[i]) { auto it = lower_bound(se.begin(), se.end(), ans2[i], greater&lt;int&gt;()); if (it == se.end()) { flag = true; break; } ans1[i] = se[it - se.begin()]; se.erase(it); } } for (int i = 1; i &lt;= n; i++) { if (!ans2[i]) { auto it = lower_bound(fi.begin(), fi.end(), ans1[i], greater&lt;int&gt;()); if (it == fi.end()) { flag = true; break; } ans2[i] = fi[it - fi.begin()]; fi.erase(it); } } if (flag) cout &lt;&lt; \"NO\" &lt;&lt; endl; else { cout &lt;&lt; \"YES\" &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; ans1[i]; i == n ? cout &lt;&lt; endl : cout &lt;&lt; \" \"; } for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; ans2[i]; i == n ? cout &lt;&lt; endl : cout &lt;&lt; \" \"; } } } } return 0;} D.Lucky PermutationLinkhttps://codeforces.com/contest/1768/problem/D Description定义一种操作：对一个长度为 的排列 ，每次可以从排列中选出 和 ，交换 与 。最小化使得最终的 有且仅有一个逆序对的操作次数。 Solution对于每个 ，若考虑从 到 连一条有向边，根据排列的性质（每个点的入度和出度都为 ），则会生成 个环 。 不难发现，最终状态一定是「一个升序排列，且选择一对相邻的数交换后」的形式。若按之前的图的形式表示，则可以表示为 个自环 + 个长度为 的环（且这个长度为 的环，是由两个相邻的数字构成的）。 对于原排列表示出的 个环，自环可以不管，大环则需要被拆解成小环和自环。当交换两个数有效时，可以等效为「大环变小，且新增自环」。若存在一个大环其中包含两个相邻的数，那么意味着在拆解的过程中，可以把他们俩留下，其他变为自环。否则在所有大环拆成自环后，还需要选择两个相邻的自环，将他们变成长度为 的环。 利用并查集可以找出环的个数后，再在每个环中判断，是否存在相邻元素。若存在则答案 ，不存在则答案 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;const int N = 2e5 + 5;using namespace std;int T, n, x, fa[N];set&lt;int&gt; s, son[N];int get_fa(int x) { return x == fa[x] ? x : fa[x] = get_fa(fa[x]); }int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { bool flag = false; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) fa[i] = i; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x; int fx = get_fa(i), fy = get_fa(x); fa[fy] = fx; } for (int i = 1; i &lt;= n; i++) { int x = fa[i]; while (x != fa[x]) x = fa[x]; s.insert(x); son[x].insert(i); } for (int i = 1; i &lt;= n; i++) { int last = -1; for (auto x : son[i]) { if (last != -1 &amp;&amp; x - last == 1) { flag = true; break; } last = x; } if (flag) break; } cout &lt;&lt; n - (int)s.size() + (!flag ? 1 : -1) &lt;&lt; endl; s.clear(); for (int i = 1; i &lt;= n; i++) son[i].clear(); } return 0;}","link":"/2023/01/07/Codeforces%20Round%20842(Div.2)/"},{"title":"Codeforces Round 833 (div.2)","text":"B.Diverse SubstringsstatementFind the number of substrings of consists of only that satisfies max{alpha occurrences} s.size( ). solutionThe most significant point is the length of s will not exceed 10*10 = 100. So it’s available to let be the start position and check answer in next numbers and break when the condition fails to satisfy. code linkhttps://codeforces.com/contest/1748/submission/180703499 C.Zero-Sum PrefixesstatementGiven an array consists of integers in range of , in every operation you can choose a position that , and change to an arbitrary integer. Maxizize the number of that satisfies: (\\sum_{j = 1}^{x}a_j) = 0solutionNotice that every two is independent, which means every time you’re going to change the value of , you only need to consider how the new value will influence the number who’s index is between . So in every operation you only need to maximize present answer, thus we take strategy like finding out the most occurances prefix sum between , and add it to the final result. code linkhttps://codeforces.com/contest/1748/submission/180705816 D.ConstructORstatementGiven integer , find any possible that satisfies: d \\mod a | x = 0 \\\\ d \\mod b | x = 0solutionGiven the features of bitwise OR operation, we can simplify the description of the question as find a x which not only is a multiple of d but also x mod a|b = 0.In other words, is constructed by in binary and the binary form of is a subset of .So we can try to construct the in binary form from low position to high position. When the - value is in , we can add a multiple using ‘&lt;&lt;’ operation that can guarantee the value in current position is same as .","link":"/2022/11/18/Codeforces%20Round%20833(div.2)/"},{"title":"无论怎样，2021，再见了","text":"去年也大抵是这个时候，我说：“几个月没更新博客了，好久没一个人坐下来写点东西了。” 不知不觉，一年过去了，我好像还是没有养成经常写点东西的习惯。若问我原因，我可能还是会以“太忙了”、“变化总比计划快”来搪塞过去。 若我未来每年都会继续写年终总结的话，我可能每次都会和上一年一样，说“这一年是不平凡的一年”。随着时间的推移，老旧的记忆带给人的各方面的影响程度会慢慢褪色，每一年经历的事、遇见的人都不一样，然后人就会将一些有一定触动程度的事情定义为“不平凡”。 说2021的话，首先不得不提的事是高考。我不是很想去回忆备考的那几个月，不想试图从里面找到些什么值得感慨的。回忆那几个月，会让我不可避免的把这件事的结果与过程中的期望做对比，会不可避免的让我去想“如果怎么怎么样就怎么怎么样”之类的无意义的东西。“走好眼前的路，欣赏沿途的风景，不在意结果”是我从高考里面学到的。结果出来的那天，我承认我是悲伤的，不甘的，心想“去你*的功不唐捐”。但“时间会冲淡一切”这句话总是适用的。我现在在这座我填志愿之前完全不知道的学校充实地生活着，感觉没什么不好的。当时那些遗憾什么的，我早已抛到脑后了。 这一年里充满了告别。其中让我意难平的是，我告别了会让我“shed 10,000 tears”的晚霞，告别了好哥们，告别了曾经喜欢的人。 这一年里也充满了遇见。我遇见了井越，一个在短短一年里在各许多方面都影响了我的人，一个过着我想要的生活的人。我被他vlog中亮度与色调都舒适自然的画面，精心设计渐入的小众音乐以及他兼具哲理与幽默感的谈吐所触动。我还遇见了更随和、心态更好、思想更成熟的我。当然不是所有遇见都是那么高兴的。我也遇见过心动选手，但在经历了一些事情后，经过冷静的思考和漫长的自我劝说，我已经说了拜。 新的一年。既往不恋，当事不杂，未来不迎。 继续健身，继续读书，继续热爱生活，继续珍惜身边人，继续心态良好待人随和。 无论怎样，2021，再见了。","link":"/2021/12/20/%E6%97%A0%E8%AE%BA%E6%80%8E%E6%A0%B7%EF%BC%8C2021%EF%BC%8C%E5%86%8D%E8%A7%81%E4%BA%86/"},{"title":"Codeforces Round 739 (Div. 3)","text":"链接：https://codeforces.com/contest/1560 总体评价：区分度不错，比之前的div3要难一些。 A预处理出前个，直接输出即可。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;const int N = 100050;const int INF = 1 &lt;&lt; 30;typedef long long ll;using namespace std;int n, x, num, ans[N];int main() { cin &gt;&gt; n; for(int i = 1; num &lt;= 1000; i++) { if(i % 10 == 3 || i % 3 == 0) continue; ans[++num] = i; } for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; x; cout &lt;&lt; ans[x] &lt;&lt; endl; } return 0;} B简简单单画出前几个的情况可以找到规律，加入一些特判的点即可。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;const int N = 100050;const int INF = 1 &lt;&lt; 30;typedef long long ll;using namespace std;int t, a, b, c, d;int main() { cin &gt;&gt; t; while(t--) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; d = abs(a - b); if(abs(a - b) == 1 || min(a, b) &gt; abs(a - b) || c &gt; 2 * d) { cout &lt;&lt; \"-1\" &lt;&lt; endl; continue; } c &lt;= d ? cout &lt;&lt; c + d &lt;&lt; endl : cout &lt;&lt; c - d &lt;&lt; endl; } return 0;} C也是找规律题。以左上角的为中心，向外画圈，看成{1}，{2，3，4}，{5，6，7，8，9}……这样分组。 看第列，。看第一行，。看左上到右下的那条对角线，。 首先初步判定是在第几组（环），，时间复杂度是可以接受的。 然后再判断得到时是行不变还是列不变，输出即可。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;const int N = 100050;const int INF = 1 &lt;&lt; 30;typedef long long ll;using namespace std;int t, x, n;int main() { cin &gt;&gt; t; while(t--) { cin &gt;&gt; x; for(int i = 1; i &lt;= 32000; i++) { if(i * i &gt;= x) { n = i; break; } } if(x &lt;= n * n - n + 1) cout &lt;&lt; x - (n - 1) * (n - 1) &lt;&lt; \" \" &lt;&lt; n &lt;&lt; endl; else cout &lt;&lt; n &lt;&lt; \" \" &lt;&lt; n - (x - (n * n - n + 1)) &lt;&lt; endl; } return 0;} D题意根据题中的规则进行操作，求将给定数变为一个的任意次幂的最少操作数。 思路看数据范围，可以知道我们最多只需预处理到，在这个上限以内符合条件的数在个左右，我们是可以接受的。 所以可以进行枚举，找到最小的答案。 答案怎么算？其实就是一个双指针的操作。遇到相同的统计一下，一起移动指针，否则只移动题中所给的字符串的指针，直到遍历完其中一个字符串。操作次数也就很好算了，等效为把原字符串中与答案不同的先删掉答案有但原字符串没有的。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;const int N = 100;const int INF = 1 &lt;&lt; 30;typedef long long ll;using namespace std;int k, ans;ll bin[N];string s;int calc(ll x) { string t = \"\"; while(x) { t += (x % 10) + '0'; x /= 10; } reverse(t.begin(), t.end()); int cnt = 0, j = 0, l = 0; while(j &lt; s.length() &amp;&amp; l &lt; t.length()){ if(s[j] == t[l]) { ++cnt; j++; l++; } else j++; } return s.length() + t.length() - cnt * 2;}int main() { ios::sync_with_stdio(false); cin &gt;&gt; k; bin[0] = 1; for(int i = 1; i &lt;= 62; i++) bin[i] = bin[i - 1] * 2; while(k--) { ans = INF; cin &gt;&gt; s; for(int i = 0; i &lt;= 62; i++) ans = min(ans, calc(bin[i])); cout &lt;&lt; ans &lt;&lt; endl; } return 0;} F1题意给定数，找到最小的，使得并且保证的十进制表示中最多出现种数字。 思路这题要想分类讨论还是太难了…… 若，则可以通过枚举找到答案。 若，我们可以枚举确定答案是由哪两个数字组成，同时按贪心思路构造出较小的答案，进行统计。很难想。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;int t, k;set&lt;char&gt; o;string s;string calc(char x) { string y = \"\"; for(int i = 0; i &lt; s.length(); i++) y += x; return y;}void solve1() { for(char i = '0'; i &lt;= '9'; i++) { string t = calc(i); if(t &gt; s) { cout &lt;&lt; t &lt;&lt; endl; return ; } }}void solve2() { string t = calc('9'); for(char i = '0'; i &lt;= '9'; i++) { for(char j = i + 1; j &lt;= '9'; j++) { for(int l = 0; l &lt; s.length(); l++) { if(s[l] &lt; j) { string g = s; g[l] &lt; i ? g[l] = i : g[l] = j; for(int p = l + 1; p &lt; g.length(); p++) g[p] = i; if(t &gt; g) t = g; } if(s[l] != i &amp;&amp; s[l] != j) break; } } } cout &lt;&lt; t &lt;&lt; endl;}int main() { ios::sync_with_stdio(false); cin &gt;&gt; t; while(t--) { o.clear(); cin &gt;&gt; s &gt;&gt; k; for(int i = 0; i &lt; s.length(); i++) o.insert(s[i]); if(o.size() &lt;= k) { cout &lt;&lt; s &lt;&lt; endl; continue; } k == 1 ? solve1() : solve2(); } return 0;} 还有个超时的做法，就是时用来做，也贴在这里吧…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;int t, k;set&lt;char&gt; o;string s;string calc(char x) { string y = \"\"; for(int i = 0; i &lt; s.length(); i++) y += x; return y;}void solve1() { for(char i = '0'; i &lt;= '9'; i++) { string t = calc(i); if(t &gt; s) { cout &lt;&lt; t &lt;&lt; endl; return ; } }}void dfs(int step, char t1, char t2, string &amp;t, string p) { //cout &lt;&lt; t &lt;&lt; \" \" &lt;&lt; p &lt;&lt; endl; if(step == 2 &amp;&amp; p == \"0\") return ; if(step != 1 &amp;&amp; p[0] &lt; s[0]) return ; if(step == s.length() + 1) { if(p &lt; t &amp;&amp; p &gt; s) { t = p; return ; } return ; } string last = p; dfs(step + 1, t1, t2, t, p + t1); p = last; dfs(step + 1, t1, t2, t, p + t2); p = last;}void solve2() { string t = \"\", p = \"\"; t = calc('9'); for(char i = '0'; i &lt;= '9'; i++) { for(char j = '0'; j &lt;= '9'; j++) { if(i == j) continue; // cout &lt;&lt; *it1 &lt;&lt; \" \" &lt;&lt; *it2 &lt;&lt; endl; dfs(1, i, j, t, p); } } cout &lt;&lt; t &lt;&lt; endl;}int main() { ios::sync_with_stdio(false); cin &gt;&gt; t; while(t--) { o.clear(); cin &gt;&gt; s &gt;&gt; k; for(int i = 0; i &lt; s.length(); i++) o.insert(s[i]); if(o.size() &lt;= k) { cout &lt;&lt; s &lt;&lt; endl; continue; } k == 1 ? solve1() : solve2(); } return 0;}","link":"/2021/08/21/Codeforces%20Round%20739%20(Div.%203)/"},{"title":"Codeforces Round 738 (Div.2)","text":"比赛链接：https://codeforces.com/contest/1559 总体评价：Chinese Round，前四道题目较为简单，后两道貌似难度剧增…… 题意基本上是自己写的，也算练练英语吧……如果有语法错误还请海涵。 A题意Select an arbitrary interval and for all values , replace with &amp; at the same time.This operation can be performed any number of times. Minimize the maximum value in the sequence. 思路将一个数用二进制表示后，每一位非即。 根据与运算的性质，两个数相与，对于二进制下都为的某一位没有影响。然而如果存在第位，一个数为，另一个为，那么结果必然会变小。 由于题目未限制与运算的次数，那么只需要让赋上的值，让依次与之后的每一个数相与即可得到答案。 1234567891011121314151617#include &lt;cstdio&gt;#include &lt;iostream&gt;const int N = 150;using namespace std;int t, n, ans, a[N];int main() { ios::sync_with_stdio(false); cin &gt;&gt; t; while(t--) { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; ans = a[1]; for(int i = 2; i &lt;= n; i++) ans = ans &amp; a[i]; cout &lt;&lt; ans &lt;&lt; endl; } return 0;} B题意Given a string containing ‘B’, ‘R’, or ‘?’，you need to replace the ‘?’ with ‘B’ or ‘R’ to get a new string. At the same time, you should minimize the number of the ”BB“ and “RR”. 思路找到每个有字母的位置，利用贪心思想向前依次填字母。 需要特殊处理只有一个字母的情况，否则该字母后的”?”无法填上字母。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;const int INF = 1 &lt;&lt; 30;const int N = 150;typedef long long ll;using namespace std;struct node { int x, y;}b[N];int t, n, cnt, num, a[N];char c;int main() { cin &gt;&gt; t; while(t--) { num = cnt = 0; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; c; if(c == '?') { a[i] = -1; ++cnt; } else { a[i] = (c == 'B') ? 1 : 2; b[++num] = (node){i, cnt}; cnt = 0; } } for(int i = 1; i &lt;= num; i++) { for(int j = b[i].x - 1; j &gt;= b[i].x - b[i].y; j--) { a[j] = (a[j + 1] == 1) ? 2 : 1; } } for(int i = 1; i &lt;= n; i++) { if(a[i] == 1 || a[i] == 2) a[i] == 1 ? cout &lt;&lt; \"B\" : cout &lt;&lt; \"R\" ; else a[i - 1] == 1 ? (a[i] = 2, cout &lt;&lt; \"R\") : (a[i] = 1, cout &lt;&lt; \"B\"); } cout &lt;&lt; endl; } return 0;} C题意Follow the rules to add edges, then find a way which goes through every point exactly once. 思路简简单单的建图、。 或者也可以找规律来完成此题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;const int N = 10050;using namespace std;int t, n, num, a[N], ans[N];bool flag, vis[N];vector&lt;int&gt; g[N];void dfs(int x, int step) { if(step == n &amp;&amp; num - 1 == step) { flag = 1; for(int i = 1; i &lt;= num; i++) cout &lt;&lt; ans[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return ; } for(int i = 0; i &lt; g[x].size() &amp;&amp; !flag; i++) { int to = g[x][i]; if(vis[to]) continue; vis[to] = 1; ans[++num] = to; dfs(to, step + 1); num--; vis[to] = 0; }}int main() { cin &gt;&gt; t; while(t--) { cin &gt;&gt; n; for(int i = 1; i &lt;= n - 1; i++) g[i].push_back(i + 1); for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; a[i] ? g[n + 1].push_back(i) : g[i].push_back(n + 1); } for(int i = 1; i &lt;= n + 1; i++) { if(flag) break; memset(vis, 0, sizeof(vis)); vis[i] = 1; num = 1; ans[num] = i; dfs(i, 0); } if(!flag) cout &lt;&lt; \"-1\" &lt;&lt; endl; for(int i = 1; i &lt;= n + 1; i++) g[i].clear(); memset(vis, 0, sizeof(vis)); flag = 0; } return 0;} D1题意Given two forests(A forest is an undirected graph without cycles (not necessarily connected).), you can add an edge between and in two forests at the same time.Maximum the number of edges they can add, and which edges to add. 思路考虑到数据范围，一种很暴力的思路就是邻接矩阵存图，枚举边，每次判环，然后愉快的Time limit exceeded on pretest 6。 正确做法是不用建图，只需要使用并查集即可，加上路径压缩的并查集可以节省很多时间。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;const int N = 1050;using namespace std;int n, m1, m2, u, v, fa[2][N];struct node { int x, y;};vector&lt;node&gt; ans;int get_fa(bool tp, int x) { return x == fa[tp][x] ? x : fa[tp][x] = get_fa(tp, fa[tp][x]); }int main() { ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2; for(int i = 1; i &lt;= n; i++) fa[0][i] = fa[1][i] = i; for(int i = 1; i &lt;= m1; i++) { cin &gt;&gt; u &gt;&gt; v; fa[0][get_fa(0, v)] = get_fa(0, u); } for(int i = 1; i &lt;= m2; i++) { cin &gt;&gt; u &gt;&gt; v; fa[1][get_fa(1, v)] = get_fa(1, u); } for(int i = 1; i &lt;= n; i++) { for(int j = i + 1; j &lt;= n; j++) { if((get_fa(0, i) != get_fa(0, j)) &amp;&amp; (get_fa(1, i) != get_fa(1, j))) { fa[0][get_fa(0, j)] = get_fa(0, i); fa[1][get_fa(1, j)] = get_fa(1, i); ans.push_back((node){i, j}); } } } cout &lt;&lt; ans.size() &lt;&lt; endl; for(int i = 0; i &lt; ans.size(); i++) cout &lt;&lt; ans[i].x &lt;&lt; \" \" &lt;&lt; ans[i].y &lt;&lt; endl; return 0;}","link":"/2021/08/17/Codeforces%20Round%20738%20(Div.2)/"},{"title":"Goodbye 2020 Hello 2021","text":"几个月没更新博客了，好久没一个人坐下来写点东西了。 适逢年末，写点东西，来纪念一下2020吧。 似乎每个人都认为2020是个不平凡的一年。澳洲山火，新冠疫情，东京奥运会推迟，科比、黑豹、马拉多纳的永别，安倍辞职，拜登胜选……太多太多有着很大冲击力的事情接踵而至，让人心情起伏不定。 对我个人而言，也是对大多数人而言，影响最大的应该就是突如其来的疫情吧。第一次有了被强制不让出门的经历，第一次体验网课生活，第一次连着1个月看到大街上空无一人…… 老沈说：“疫情让我们学会与孤独共处。” 确实，疫情初期的生活可谓煎熬。每天自己局促一室以内，做着千篇一律的事情，未免会感到非常孤独。那段时间真的想找人聊聊天，来缓解心中之无聊。之后，才渐渐熟悉了这样的生活。每天早上在家里上上课，写写作业；下午看看书，写写作业，刷刷知乎，锻会炼；晚上看看权游，了解了解今天新闻，和朋友聊聊天……一天就这么过去了。到后面解封的那天，当脚迈出单元门，踩到大地的那一刻，我竟有一种既熟悉又陌生的感觉。 高二下学期，下决心彻底不想竞赛，全心全意投入到文化课上，便选择了住宿。第一次体验住宿生活，从最初3天的失眠、不熟悉到之后的渐渐习惯，我渐渐感受到了住宿生活的好处：时间的节省、人际关系的拓展、有节奏的生活……高二下学期3次考试的排名相比与高一的时候好了很多，自己终于离梦想更近了一步。 暑假到来，自己定了一个跑步锻炼计划，但不久又被疫情打破。之后不知道为什么，心情一直都很浮躁。在家一轮复习的网课的状态一直都不是很好。开学，高三来了。班里的气氛真的和高二的时候大相径庭，每个人都在抓紧每一分每一秒学习。墙上的倒计时数字悄无声息的一天天减少，快的让人觉得不可思议。感觉开学后自己的状态，时好时坏吧。几次考试的成绩和高二下学期相比，又有所退步。总感觉是自己心态的问题。经常因为自己考试总是失误而失望，失望后又“及时奋发精神”……最近一直都在调整心态，希望自己真的能做到“胜不妄喜，败不惶馁，胸有激雷而面如平湖”。感觉自己还是如初中班主任老白言：“少点静气。” 感觉最近几周过的真的太快太快了。拼命想抓住流年，但无果。那就活在当下，不辜负每分每秒吧。 值得高兴的是，在我每逢跌入低谷，总会遇到温暖的人在旁倾听，为我排忧解难。我不胜感激。 新年将至，愿家人和朋友们平安喜乐，万事胜意，诸事顺遂。 愿我们，都能成为心中所向吧。","link":"/2020/12/19/Goodbye-2020-Hello-2021/"},{"title":"浅谈高中生物”碱基对确定，求DNA最多种数”问题","text":"前言这个问题在高中生物中，并不会研究的那么深刻。 所以正式做题时还是应该按照老师的教导，避开这个“雷区”。 1.问题发现在高中生物-遗传与进化-基因的本质学习中，有一个十分经典的问题。 即：给定碱基对数n，不限定每种碱基(A,C,G,T)的个数，求出最多的DNA种数。 在所有的教材，辅导书，以及老师的授课过程中，对于这个问题的答案，一般都是或者。 对于的思路，即每个位置有种碱基对可能，一共有组，根据乘法原理，故为。 对于的思路，即在上一种思路的基础上，考虑到有重复的情况，便除了个2​。 但是，@thorn,@opethrax以及本人的对于这些答案深感怀疑，于是我们便手算了当碱基对数为时的所有情况。 利用计算机程序进行打表，以及查询有关的资料后，最终我们确定当n=2时，结果理应为10​。 这个答案都不能用上面的公式解答，于是我们继续思考探索。 2.深入探究通过@opethrax同学辛苦的打表，观察，他发现存在一些情况被忽略。 原先我们认为，一个分子拥有与段，代表三号碳，代表五号碳。 如下图，从两条链的端分别扫描，一种序列最多被统计到次。 一个是AGCTA​，另一种是TAGCT。 但是，存在一种分子，从其两条链的端分别扫描，结果相同。 如下图： 都为TCGATCGA。 所以这种情况下，具有这种性质的会被少统计一次。 且我们不难发现，满足这种性质当且仅当链的长度为偶数（如图一，若为奇数，会出现不对称的情况，即不满足这种性质）。 那么我们分类讨论，之前那个的公式，可以在n​为奇数时使用。 对于n​为偶数的情况，我们要在原公式的基础上，加上少统计的个数。 现在的问题，即是寻找拥有这种特殊性质的链的个数。 不难发现，一条链的端的号碱基到该链的第号碱基，如果和另一条链的端的号碱基到该链的第号碱基相同，剩下的部分通过碱基互补配对原则，可以保证相同。 下图黑的部分是我们自己确定的一条排列，红色部分是根据碱基互补配对原则形成的。 我们可以把这个理解为一种中心对称。 所以我们只需要构造出一条链中一半的排列，然后按照中心对称放到另一条链的端，剩下那条按照碱基互补配对原则填充即可满足这种性质。 所以我们不难得出，这种情况下，会有条链会被少统计一次。 至此，我们可以得出公式： a_n=\\begin{cases}\\frac{4^n}{2}\\ \\ \\ \\ \\ \\ \\ \\ n=2k+1\\\\\\frac{4^n+4^{\\frac{n}{2}}}{2}\\ n=2k\\ \\ (k\\in N^*)\\end{cases}这个式子经过打表以及oeis.org的确认，结果正确。 3.声明与感谢其实的结构远比人类脑海中想象的要复杂的多，这里我们只是讨论了理论下的情况。 感谢您的阅读。若您存在任何疑问，或觉得我们有些地方存在纰漏，欢迎您联系我们，我们十分乐意与您探讨。 再次感谢两位同学@thorn,@opethrax深夜的探讨与陪伴，若没有他们的帮助，我们很难单独进行下去。 thorn有关这篇文章的链接：https://www.cnblogs.com/thornblog/p/12381381.html opethrax有关这篇文章的链接：https://home.cnblogs.com/u/opethrax/ 他们两位有关这个内容的博客写的都非常优秀，建议您去访问他们的博客以进行更多的了解。 除非另有说明，本网站上的内容均采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，请您在转载时注明来源及博客链接。 4.深夜随想造物主强大的力量是人们无法想象到的。人类很难走到没有任何疑惑的那一天。 每一个个体脑中冒出的新奇想法，或提出的一个问题，都有可能成为筑起人类从无知到有知的桥梁下的一粒石子。 对科学的探索，不是浅尝辄止，而是无穷无尽。 献上一首不错的音乐： “生于此处却不知此处 日光倾城，万物生长，又是为何 若没有大地的拥抱，我们早已消失于茫茫宇宙之中 若没有原子之稳定，我们亦不复存在 无人问天地变换，斗转星移，是为何故 宇宙又是源于何处 它是否无始无终 时间若愿意倒流，我们的认知是否还会有局限 世间最渺小之物又是什么 滚滚长江，却只留有过去，不知未来 浩淼宇宙，为何我们在此相遇” ——《Moonlight》","link":"/2020/02/29/%E6%B5%85%E8%B0%88%E9%AB%98%E4%B8%AD%E7%94%9F%E7%89%A9%E2%80%9D%E7%A2%B1%E5%9F%BA%E5%AF%B9%E7%A1%AE%E5%AE%9A%EF%BC%8C%E6%B1%82DNA%E6%9C%80%E5%A4%9A%E7%A7%8D%E6%95%B0%E2%80%9D%E9%97%AE%E9%A2%98/"},{"title":"浅谈Cauchy不等式","text":"形式 \\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2 \\geq \\sum_{i=1}^{n}a_i^{2}b_i^2等号成立的条件： iff:b_i=0 || \\exists k \\in \\mathbb {R},a_i=k \\cdot b_i(i \\in \\mathbb{N^+})证明法一：参数配方思路：巧妙的把常数与方程结合起来，利用性质即可。 证明：构造函数: f(t)=\\sum_{i=1}^{n}b_i^2\\cdot t^2-2\\sum_{i=1}^{n}a_ib_it+\\sum_{i=1}^{n}a_i^2化简函数： f(t)=\\sum_{i=1}^{n}b_i^2\\cdot t^2-2\\sum_{i=1}^{n}a_ib_it+\\sum_{i=1}^{n}a_i^2 =\\sum_{i=1}^{n}(b_i^2t^2-2a_ib_it+a_i^2) =\\sum_{i=1}^{n}(b_i^2t^2+a_i^2-2a_ib_it) =\\sum_{i=1}^{n}(b_it-a_i)^2所以： f(t) \\geq 0 \\Delta t=b^2-4ac =4\\sum_{i=1}^{n}a_i^2b_i^2-4\\times \\sum_{i=1}^{n}b_i^2 \\times \\sum_{i=1}^{n}a_i^2 \\leq 0所以： 4\\sum_{i=1}^{n}a_i^2b_i^2 \\leq 4\\times \\sum_{i=1}^{n}b_i^2 \\times \\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}a_i^2 \\times \\sum_{i=1}^{n}b_i^2 \\geq \\sum_{i=1}^{n}a_i^2b_i^2证毕。 因为： f(t)=\\sum_{i=1}^{n}(b_it-a_i)^2令，即 a_i=b_it此时： f(t)_{min}=0​即： \\Delta t \\leq 0故等号可取的一个充分条件即为： \\exists k \\in \\mathbb {R},a_i=k \\cdot b_i(i \\in \\mathbb{N^+}）法二：均值不等式证明思路：运用分析法将原式子化简，使用绝对值三角不等式与均值不等式进行证明。 引用到的均值不等式（证明略）： ab \\leq \\frac{a^2+b^2}{2}适用条件： a,b \\in \\mathbb {R^+}等号成立条件： iff:a=b证明：要证： \\sum_{i=1}^{n}a_i^2\\sum_{i=1}^{n}b_i^2 \\geq \\sum_{i=1}^{n}a_i^{2}b_i^2只需证： \\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2} \\geq |\\sum_{i=1}^{n}a_ib_i|即： |\\sum_{i=1}^{n}a_ib_i| \\leq \\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2} \\frac{|\\sum_{i=1}^{n}a_ib_i|}{\\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2}}\\leq 1由绝对值三角不等式： |a_1+a_2+a_3+\\cdots+a_n| \\leq |a_1|+|a_2|+|a_3|+ \\cdots + |a_n|可得： |\\sum_{i=1}^{n}a_ib_i| \\leq \\sum_{i=1}^{n}|a_ib_i|所以： \\frac{|\\sum_{i=1}^{n}a_ib_i|}{\\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2}} \\leq \\frac{\\sum_{i=1}^{n}|a_ib_i|}{\\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2}}又因为： \\frac{\\sum_{i=1}^{n}|a_ib_i|}{\\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2}} =\\sum_{i=1}^{n}\\frac{|a_i|}{\\sqrt{\\sum_{i=1}^{n}a_i^2}}\\cdot \\frac{|b_i|}{\\sqrt{\\sum_{i=1}^{n}b_i^2}}由均值不等式： ab \\leq \\frac{a^2+b^2}{2}可得： \\sum_{i=1}^{n}\\frac{|a_i|}{\\sqrt{\\sum_{i=1}^{n}a_i^2}}\\cdot \\frac{|b_i|}{\\sqrt{\\sum_{i=1}^{n}b_i^2}} \\leq \\frac{1}{2}\\cdot \\sum_{i=1}^{n}(\\frac{a_i^2}{\\sum_{i=1}^{n}a_i^2}+ \\frac{b_i^2}{\\sum_{i=1}^{n}b_i^2}) \\leq \\frac{1}{2}\\cdot (\\frac{\\sum_{i=1}^{n}a_i^2}{\\sum_{i=1}^{n}a_i^2}+ \\frac{\\sum_{i=1}^{n}b_i^2}{\\sum_{i=1}^{n}b_i^2}) \\leq \\frac{1}{2} \\times 2 = 1即： \\frac{|\\sum_{i=1}^{n}a_ib_i|}{\\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2}}\\leq 1上述结论成立，证毕。 法三：n维向量证法因为： |\\vec a \\cdot \\vec b| = |\\vec a|\\cdot |\\vec b| \\cdot cos \\theta所以： |\\vec a \\cdot \\vec b| \\leq |\\vec a|\\cdot |\\vec b| |\\vec a \\cdot \\vec b|^2 \\leq |\\vec a|^2\\cdot |\\vec b|^2为维向量时，用坐标的形式展开即可证明。 当，即，共线时，等号成立。 申明与感谢 内容采用“知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议”进行许可。请您在转载时注明来源及链接。 感谢@thorn的审稿。","link":"/2020/01/17/%E6%B5%85%E8%B0%88Cauchy%E4%B8%8D%E7%AD%89%E5%BC%8F/"},{"title":"终于结束的起点——CSP-S 2019 第二轮游记","text":"Day -3在教练和自己的劝说下，终于还是选择最后几天停课，专心复习，全力以赴。 Day -2上午一直在复习数论知识，中午睡了个午觉，起来后身体就很难受了。 晚上就直接请假回家睡觉。感觉发烧了，一测，39度左右。感觉药丸。 Day -1早上去医院检查，细菌性感染，开了一些奇奇怪怪的药，整个一天都处于头疼炸裂的状态。 一天都没有复习任何知识。周五中午的活动也参加不了了。 病来如山倒。 自认倒霉。在这个紧要关头，居然生了大病。 Day 0起床后感觉身体状态海星。希望今天别太难受了。 中午去了趟机房，拿了点东西，获得了许多人的关心QAQ 互相祝福后，便直接回家了 中午睡完觉后又开始发烧了，抗生素所带来的不良反应也越来越重，怎么办啊版子还没看完QAQ 算了不管了，放平心态，不管结果了。 Day 1昨天晚上在奇怪的梦中醒来两次，又是因为腹泻。 6：50，早上一出门，发现雪下了好厚一层。 深夜的一中，没有灯光，雪地上只有一些人走过的脚印痕迹。 到了校车上，想休息一会，根本睡不着。 感觉自己已经释怀了，没有什么追求了，心中很平静，但还是睡不着。 到了考场，开考5分钟左右才发题。 看到T1，先找了找规律，把可能有联系的东西都写在了纸上，但是越看越乱，最终交了个50分的暴力。 然后感觉T3的题意较T2好理解，于是想去写T3的部分分。 写了好久，发现有一些小细节，最终没调出来，先去写T2吧。 看到T2链的情况挺好写的，快快的写了个35分就去调T3。 最终没调出来。 出考场，基本上许多人都写出来了T1，发现我的想法已经很接近了，但是考场上还是放弃了。 应该没有什么奇迹了吧。 文化课，你好。 Day 2状态还不错。 考试过程还是不说了。 至于结果，还是不尽人意。 自己一个人打了出租车，心中很平静。 “四年OI一场空”，确实，没有什么奖杯奖牌，没有什么纪念品。 但有时候，过程，难道不就是最可贵的吗。 在OI中，我经历了许多，也学习了许多。 知晓了许多学习方法，明白了许多其他人不知道的知识。 在OI中，我失去了许多，也收获了许多。 失去了大量的文化课时光，失去了高一的寒暑假，以及各种节假日。 但收获了许多朋友，一起一同为了某个目标奋斗的知音者。 终于结束的起点终于写下句点终于我们告别终于我们又回到原点一个个 OIer 的竞赛生涯总是从一场 NOIp 开始，大多也在一场 NOIp 中结束，好似一次次轮回在不断上演。如果这次 NOIp 是你的起点，那么祝你的 OI 生涯如同夏花般绚烂。如果这次 NOIp 是你的终点，那么祝你的 OI 回忆宛若繁星般璀璨。 —-Luogu P4994 终于结束的起点 结束了，一切都结束了。 开始了，新的征程要开始了。 取得好成绩的各位，在收获了硕果后也不应该沾沾自喜，争取拼搏出更美好的未来。 没有得到理想成绩的后辈，应该总结经验教训，不要气馁，积水至成渊之时，静待蛟龙诞生之日。 祝进省队的同学，在接下来的WC,CTS,APIO,NOI取得优异的成绩。 朋友，无论你从哪条路走来，希望你能忆起自己挥洒过汗水的日子。OI 也好，其他也罢，至少你曾有过热爱的事情。你曾付出的所有心血，都值得被自己永久记得。 无论你现在的处境如何，顺利继续前进或是刚刚历经一次转折，希望你微笑着拥抱现实。请向前看，前方路还长，还有很多很多值得你热爱的事情。也许是延续旧的热爱，也许是如旧般热爱。爱在心里，爱过，也将爱着。 无论你将走在哪条路上，无论你的下一站在何方，请一如既往地全力以赴。路可能分支，拼搏却永远不变。前路也许不同，但一定精彩纷呈。愿你将过往路上的拼搏精神，继续用于前路。如此看来，过往将以这样的方式，伴你左右至永远。岔路口请你带着梦前进，走向值得期待的未来。 过去如是，现在如是，未来——亦如是。 —-Capella AFO.文化课你好！","link":"/2019/11/15/%E7%BB%88%E4%BA%8E%E7%BB%93%E6%9D%9F%E7%9A%84%E8%B5%B7%E7%82%B9%E2%80%94%E2%80%94CSP-S-2019-%E7%AC%AC%E4%BA%8C%E8%BD%AE%E6%B8%B8%E8%AE%B0-BeyondLimits/"},{"title":"CSP-S 2019 第一轮 游记","text":"Day -1早上学校有两节英语两节语文，就翘掉了。 在家里把的开放试卷做完了，，成绩不算很好。 听说这次参赛的水军都没了，复赛可能会很难进，感觉自己心态还可以。 下午围观了有趣的四川选手名单，被四川的操作震惊，看来我们还是太了… 还做了的试题，题挺难的，写完后心态大崩 Day 0又请了前三节课的假，把初赛篇的基本知识全过了一遍，感觉还不错。 还把的题的题解全看了一遍（upd：事实证明这是正确的做法，因为在真正考试中见到了不少原题） 晚上在机房和一起又把初赛的基础知识全过了一遍，膜拜的数学能力 还和研究了许久的主定理（upd：第二天居然没有考…） 很早就睡了，也没有考前欢乐。 Day 1好冷啊。 早上8：50就到了，科协的人居然还没有布置考场（太咕了，昨天晚上科协的人忙着印卷子居然让我们自己去准备考场相关事宜，贴条子）。 遇见了许久不见的，还有其他原来认识的人。 9：20进考场，惊奇的发现居然就做我左边，座位还是挨着的，但今年是卷，所以不担心答案。 但最后我们还是被分开了。。。 再一次吐槽科协的奇妙操作： 1.监考老师说：你们要是没有草稿纸，可以向周围人借。 （啥？去年不是还考过选择题说不能带草稿纸吗？） 2.监考老师说：分赛区填新疆。 （啥？那省份填全国吗？） 3.监考老师说：不能提前交卷。 （啥？这又是什么规定？提前阿克的人不能离场吗？（这里指的不是我）） 最后全部打脸。 看到卷子，感觉题量挺大。 看选择题，做起来都不是很难，居然还有原题。 遇见了一些有趣的数学题，便先放下然后去想后面的题去了。 阅读程序，前两道题都是属于看一眼就知道在干嘛的题，但是判断题当时做起来有点懵。 第三题没怎么看懂，自己造了两组数据模拟了一下，成功解决了判断题，最后两道选择题就蒙了起来。 完善程序，第一题比较简单。 第二题耗了我将近的时间，一直没看懂，到最后也是。 交完卷子后便去上物理课去了。 中午回到机房，答案出来了，便开始对。 选择错一道，是那道车牌数学题。 阅读程序第一题判断有个错了。 第二题错了一道选择一道判断，是真的坑题。 当我看到算法复杂度时，我就直接选择了，但是完全没有注意到，这并查集居然没有路径压缩（这什么辣鸡啊 还有第四道判断题，当点与所在连通块相同时，那么他们相乘后的结果显然会。 第三题据说不能读空子串，就很生草。 完善程序最后一道就对了个。。。 最后估分77分，在机房人里面排中等吧。 晚上和yyy还有jmh点了三个小菜，在水房边吃边聊，聊一些往昔与来者。 总结： 自己的功底还是不行，对于状压这种东西，还是得多钻研啊。不能知难而退。 平时心态方面也要放好一点啊。 复赛应该能进，剩下的时光，就留给月考和复赛的训练了吧。 乾坤未定，谁都是匹黑马。 各位加油鸭！ （ps：%yyy %jmh","link":"/2019/10/19/CSP-S-2019-%E7%AC%AC%E4%B8%80%E8%BD%AE-%E6%B8%B8%E8%AE%B0/"},{"title":"初等数论整理","text":"1.gcd与exgcd欧几里得算法： 1int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); } 扩展欧几里得算法： 若, 可把符号转移到中，令。 令，对于一组不定方程，有解当且仅当。 对于这组不定方程，我们可以先求出，得到一组解，同时乘上，即得到一组原方程的解。函数返回的值，是。 123456789101112int exgcd(int a, int b, int &amp;x, int &amp;y) { if(b == 0) { x = 1; y = 0; return a; } int gcd = exgcd(b, a % b, x, y), t; t = x; x = y; y = t - a / b * y; return gcd;} 对于这组不定方程的通解，可以表示为： 其中的取值在整数集合里。 2.欧拉函数及欧拉定理欧拉函数欧拉函数：表示中与互质的整数的个数。 一些定理 若为质数，则. 证明：显然。若为一个质数的幂次方，表示为，则. 证明：小于等于的正整数一共有个，对于那些可以被整除的数可以表示为，其中,共有个数。所以不能被整除的数的个数，即 若互质，则. 证明：根据的通项公式易证。 若，则. 证明：根据的通项公式易证。 欧拉函数的通项公式设为的质数幂乘积，则 证明：各质数幂之间显然互质，根据上面的定理，即可表示出： ​ ​ ​ 欧拉定理若与互质，则 一些定理若互质，则 证明：由欧拉定理，则：","link":"/2019/08/12/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E6%95%B4%E7%90%86/"},{"title":"tarjan 学习笔记","text":"求强连通分量思想：在的过程中，把强连通分量中的点入栈，当找到一个强连通分量的最起始的点，就将其所在强连通分量中的点出栈。 缩点把强连通分量中的点缩成一个点，进行重新建图，从而解决一些问题。 割点若将这个点在图中所连的边删去，图变得不连通，则称这个点为一个割点。 考虑两种情况： 若节点为根节点，则它若联结着两颗及以上数量的子树，则为割点。 ，设的其中一个儿子为，若出现，则为割点。 习题luogu 3388 【模板】割点（割顶）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;const int MAXN = 20050;const int MAXM = 100050;using namespace std;struct node { int to, nextt;}edge[MAXM &lt;&lt; 1];int n, m, u, v, num, cnt, low[MAXN], dfn[MAXN], head[MAXN];set&lt;int&gt; s;void addedge(int u, int v) { edge[++num].to = v; edge[num].nextt = head[u]; head[u] = num;}void tarjan(int x, int fa) { dfn[x] = low[x] = ++cnt; int child = 0; for(int i = head[x]; i; i = edge[i].nextt) { int to = edge[i].to; if(!dfn[to]) { if(x == fa) child++; tarjan(to, x); low[x] = min(low[x], low[to]); if(x != fa &amp;&amp; low[to] &gt;= dfn[x]) s.insert(x); } low[x] = min(low[x], dfn[to]); } if(x == fa &amp;&amp; child &gt;= 2) s.insert(x);}int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) { cin &gt;&gt; u &gt;&gt; v; addedge(u, v); addedge(v, u); } for(int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i, i); } cout &lt;&lt; (int)s.size() &lt;&lt; endl; for(set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \"; cout &lt;&lt; endl; return 0;} Luogu 2921 Trick or Treat on the Farm第一种做法是进行，对于所在强连通分量里个数大于的点，答案即为当前强连通分量的大小；由于数据的特殊性，另一种情况即为到强连通分量的距离加上那个强连通分量的大小。 第二种做法是三遍递归。第一遍把所有不在环内的点打上标记，第二遍求出未被标记的点所在环的大小，第三遍累加到环的距离。总体想法与第一种是一样的。 代码(#2)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;const int MAXN = 100050;using namespace std;int n, x, nextt[MAXN], ans[MAXN], in[MAXN];bool vis[MAXN];void dfs1(int x) { vis[x] = true; if(!--in[nextt[x]]) dfs1(nextt[x]);}int dfs2(int x, int num) { vis[x] = true; ans[x] = num; if(ans[nextt[x]]) return num; return ans[x] = dfs2(nextt[x], num + 1);}int dfs3(int x) { if(ans[x]) return ans[x]; return ans[x] = dfs3(nextt[x]) + 1;}int main() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; nextt[i]; ++in[nextt[i]]; } for(int i = 1; i &lt;= n; i++) { if(!vis[i] &amp;&amp; !in[i]) dfs1(i); } for(int i = 1; i &lt;= n; i++) { if(!ans[i] &amp;&amp; in[i]) x = dfs2(i, 1); } for(int i = 1; i &lt;= n; i++) { if(!ans[i] &amp;&amp; !in[i]) x = dfs3(i); } for(int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; endl; return 0;} Luogu 1726 上白泽慧音显然答案即为最大的强连通分量的个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;const int MAXN = 5050;const int MAXM = 50050;const int INF = 1 &lt;&lt; 30;using namespace std;stack&lt;int&gt; s;struct Edge { int to , nextt;}edge[MAXM &lt;&lt; 1];int n, m, u, v, ty, num, cnt, cnt1, Max, pos, ss[MAXN], head[MAXN], low[MAXN], dfn[MAXN], sccno[MAXN];void addedge(int u, int v) { edge[++num].to = v; edge[num].nextt = head[u]; head[u] = num;}void tarjan(int x) { dfn[x] = low[x] = ++cnt; s.push(x); for(int i = head[x]; i; i = edge[i].nextt) { int to = edge[i].to; if(!dfn[to]) { tarjan(to); low[x] = min(low[x], low[to]); } else if(!sccno[to]) low[x] = min(low[x], dfn[to]); } if(dfn[x] == low[x]) { int now, cnt2 = 0; ++cnt1; while(true) { now = s.top(); s.pop(); ++cnt2; sccno[now] = cnt1; ss[now] = cnt1; if(now == x) break; } if(cnt2 &gt; Max) { Max = cnt2; pos = cnt1; } }}int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; ty; addedge(u, v); if(ty == 2) addedge(v, u); } for(int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i); } cout &lt;&lt; Max &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) { if(ss[i] == pos) { for(int j = i; j &lt;= n; j++) { if(ss[j] == pos) cout &lt;&lt; j &lt;&lt; \" \"; } return 0; } } return 0;} Luogu 3387 【模板】缩点先进行缩点，后作类似拓扑的操作，即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;const int MAXN = 10050;const int MAXM = 100050;using namespace std;stack&lt;int&gt; ss;queue&lt;int&gt; q;struct Edge1 { int u, to, nextt;}edge1[MAXM];struct Edge2 { int u, to, nextt;}edge2[MAXN];int n, m, u, v, ans, num1, num2, cnt, cnt1, head1[MAXN], head2[MAXN], dfn[MAXN], low[MAXN], sccno[MAXN], sd[MAXN], in[MAXN], val[MAXN], dis[MAXN];void addedge1(int u, int v) { edge1[++num1].u = u; edge1[num1].to = v; edge1[num1].nextt = head1[u]; head1[u] = num1;}void addedge2(int u, int v) { edge2[++num2].u = u; edge2[num2].to = v; edge2[num2].nextt = head2[u]; head2[u] = num2;}void tarjan(int x) { dfn[x] = low[x] = ++cnt; ss.push(x); for(int i = head1[x]; i; i = edge1[i].nextt) { int to = edge1[i].to; if(!dfn[to]) { tarjan(to); low[x] = min(low[x], low[to]); } else if(!sccno[to]) low[x] = min(low[x], dfn[to]); } if(dfn[x] == low[x]) { ++cnt1; while(true) { int now = ss.top(); ss.pop(); sccno[now] = cnt1; sd[now] = x; if(now == x) break; val[x] += val[now]; } }}void topo() { for(int i = 1; i &lt;= n; i++) { if(!in[i] &amp;&amp; sd[i] == i) { q.push(i); dis[i] = val[i]; } } while(!q.empty()) { int now = q.front(); q.pop(); for(int i = head2[now]; i; i = edge2[i].nextt) { int to = edge2[i].to; dis[to] = max(dis[to], dis[now] + val[to]); if(!--in[to]) q.push(to); } } for(int i = 1; i &lt;= n; i++) ans = max(ans, dis[i]);}int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; val[i]; for(int i = 1; i &lt;= m; i++) { cin &gt;&gt; u &gt;&gt; v; addedge1(u, v); } for(int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i); } for(int i = 1; i &lt;= m; i++) { int u = sd[edge1[i].u], v = sd[edge1[i].to]; if(u == v) continue; addedge2(u, v); in[v] ++; } topo(); cout &lt;&lt; ans &lt;&lt; endl; return 0;} Luogu 3627 抢掠计划先缩点，后跑一遍（最长路）即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;const int MAXN = 500050;const int INF = 1 &lt;&lt; 30;using namespace std;struct Edge1 { int u, to, nextt;}edge1[MAXN];struct Edge2 { int u, to, val, nextt;}edge2[MAXN];stack&lt;int&gt; d;queue&lt;int&gt; q;int n, m, u, v, w, x, num1, num2, cnt, cnt1, s, p, ans, sd[MAXN], head1[MAXN], head2[MAXN], low[MAXN], dfn[MAXN], vall[MAXN], dis[MAXN], sccno[MAXN];bool vis[MAXN];int read() { int x = 0; bool sign = false; char alpha = 0; while(!isdigit(alpha)) { sign |= alpha == '-'; alpha = getchar(); } while(isdigit(alpha)) { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (alpha ^ 48); alpha = getchar(); } return sign ? -x : x;}void addedge1(int u, int v) { edge1[++num1].u = u; edge1[num1].to = v; edge1[num1].nextt = head1[u]; head1[u] = num1;}void addedge2(int u, int v, int w) { edge2[++num2].u = u; edge2[num2].to = v; edge2[num2].val = w; edge2[num2].nextt = head2[u]; head2[u] = num2;}void tarjan(int x) { dfn[x] = low[x] = ++cnt; d.push(x); for(int i = head1[x]; i; i = edge1[i].nextt) { int to = edge1[i].to; if(!dfn[to]) { tarjan(to); low[x] = min(low[x], low[to]); } else if(!sccno[to]) low[x] = min(low[x], dfn[to]); } if(dfn[x] == low[x]) { ++cnt1; while(true) { int now = d.top(); d.pop(); sccno[now] = cnt1; sd[now] = x; if(x == now) break; vall[x] += vall[now]; } }}void spfa() { dis[sd[s]] = vall[sd[s]]; q.push(sd[s]); while(!q.empty()) { int now = q.front(); q.pop(); vis[now] = false; for(int i = head2[now]; i; i = edge2[i].nextt) { int to = edge2[i].to, val = edge2[i].val; if(dis[to] &lt; dis[now] + val) { dis[to] = dis[now] + val; if(!vis[to]) { vis[to] = true; q.push(to); } } } } }int main() { n = read(); m = read(); for(int i = 1; i &lt;= m; i++) { u = read(); v = read(); addedge1(u, v); } for(int i = 1; i &lt;= n; i++) vall[i] = read(); for(int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i); } for(int i = 1; i &lt;= m; i++) { u = sd[edge1[i].u]; v = sd[edge1[i].to]; w = vall[v]; if(u == v) continue; addedge2(u, v, w); } s = read(); p = read(); spfa(); for(int i = 1; i &lt;= p; i++) { x = read(); ans = max(ans, dis[sd[x]]); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} Luogu 2002 消息扩散答案显然是缩点后入度为的点的个数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;const int MAXN = 100050;const int MAXM = 500500;using namespace std;stack&lt;int&gt; ss;int n, m, u, v, pos, num, num1, num2, cnt, cnt1, in[MAXN], head1[MAXN], head2[MAXN], low[MAXN], dfn[MAXN], sd[MAXN], sccno[MAXN];bool vis[5050][5050];struct Edge1 { int u, to, nextt;}edge1[MAXM];struct Edge2 { int u, to, nextt;}edge2[MAXM];int read() { int x = 0; bool sign = false; char alpha = 0; while(!isdigit(alpha)) { sign |= alpha == '-'; alpha = getchar(); } while(isdigit(alpha)) { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (alpha ^ 48); alpha = getchar(); } return sign ? -x : x;}void addedge1(int u, int v) { edge1[++num1].u = u; edge1[num1].to = v; edge1[num1].nextt = head1[u]; head1[u] = num1;}void addedge2(int u, int v) { edge2[++num2].u = u; edge2[num2].to = v; edge2[num2].nextt = head2[u]; head2[u] = num2;}void tarjan(int x) { dfn[x] = low[x] = ++cnt; ss.push(x); for(int i = head1[x]; i; i = edge1[i].nextt) { int to = edge1[i].to; if(!dfn[to]) { tarjan(to); low[x] = min(low[x], low[to]); } else if(!sccno[to]) low[x] = min(low[x], dfn[to]); } if(dfn[x] == low[x]) { ++cnt1; while(true) { int now = ss.top(); ss.pop(); sccno[now] = cnt1; sd[now] = cnt1; if(now == x) break; } }}int main() { n = read(); m = read(); for(int i = 1; i &lt;= m; i++) { u = read(); v = read(); if(u == v) continue; addedge1(u, v); } for(int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i); } for(int i = 1; i &lt;= num1; i++) { u = sd[edge1[i].u]; v = sd[edge1[i].to]; if(u == v) continue; in[v]++; addedge2(u, v); } for(int i = 1; i &lt;= cnt1; i++) { if(!in[i]) num++; } cout &lt;&lt; num &lt;&lt; endl; return 0;} Luogu 2746 Network of Schools第一问的答案显然是缩点后入度为的点的个数。 对于第二问，若存在出度为的点或者入度为的点则不满足条件。若把一个出度为的点与一个入度为的点连一条边，问题便迎刃而解。 考虑到两种点的个数不一定相同，选取其中的最大值即可。 记得判断是一个大环的情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;const int MAXN = 250000;using namespace std;struct Edge1 { int u, to, nextt;}edge1[MAXN &lt;&lt; 1];struct Edge2 { int u, to, nextt;}edge2[MAXN &lt;&lt; 1];stack&lt;int&gt; s;int n, u ,v, cnt, cnt1, ans1, num, num1, num2, head1[MAXN], head2[MAXN], dfn[MAXN], low[MAXN], sccno[MAXN], sd[MAXN], in[MAXN], out[MAXN];void addedge1(int u, int v) { edge1[++num1].u = u; edge1[num1].to = v; edge1[num1].nextt = head1[u]; head1[u] = num1;}void addedge2(int u, int v) { edge2[++num2].u = u; edge2[num2].to = v; edge2[num2].nextt = head2[u]; head2[u] = num2;}void tarjan(int x) { dfn[x] = low[x] = ++cnt; s.push(x); for(int i = head1[x]; i; i = edge1[i].nextt) { int to = edge1[i].to; if(!dfn[to]) { tarjan(to); low[x] = min(low[x], low[to]); } else if(!sccno[to]) low[x] = min(low[x], dfn[to]); } if(low[x] == dfn[x]) { ++cnt1; while(true) { int now = s.top(); s.pop(); sd[now] = cnt1; sccno[now] = cnt1; if(now == x) break; } }}int main() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { while(scanf(\"%d\", &amp;v) == 1) { if(v == 0) break; addedge1(i, v); } } for(int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i); } for(int i = 1; i &lt;= num1; i++) { u = sd[edge1[i].u]; v = sd[edge1[i].to]; if(u == v) continue; addedge2(u, v); in[v]++; out[u]++; } for(int i = 1; i &lt;= cnt1; i++) { if(in[i] == 0) ans1++; if(out[i] == 0) num++; } cout &lt;&lt; ans1 &lt;&lt; endl; if(cnt1 == 1) { cout &lt;&lt; \"0\" &lt;&lt; endl; return 0; } cout &lt;&lt; max(num, ans1) &lt;&lt; endl; return 0;} Luogu 2341 受欢迎的牛若出现个数 的出度为的强连通分量，则无解。 答案即为出度为的强连通分量的大小。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;const int MAXN = 10050;const int MAXM = 50050;using namespace std;stack&lt;int&gt; ss;int n, m, u, v, pos, num, num1, num2, cnt, cnt1, head1[MAXN], head2[MAXN], low[MAXN], dfn[MAXN], sd[MAXN], f[MAXN], sccno[MAXN];struct Edge1 { int u, to, nextt;}edge1[MAXM];struct Edge2 { int u, to, nextt;}edge2[MAXM];int read() { int x = 0; bool sign = false; char alpha = 0; while(!isdigit(alpha)) { sign |= alpha == '-'; alpha = getchar(); } while(isdigit(alpha)) { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (alpha ^ 48); alpha = getchar(); } return sign ? -x : x;}void addedge1(int u, int v) { edge1[++num1].u = u; edge1[num1].to = v; edge1[num1].nextt = head1[u]; head1[u] = num1;}void addedge2(int u, int v) { edge2[++num2].u = u; edge2[num2].to = v; edge2[num2].nextt = head2[u]; head2[u] = num2;}void tarjan(int x) { dfn[x] = low[x] = ++cnt; ss.push(x); for(int i = head1[x]; i; i = edge1[i].nextt) { int to = edge1[i].to; if(!dfn[to]) { tarjan(to); low[x] = min(low[x], low[to]); } else if(!sccno[to]) low[x] = min(low[x], dfn[to]); } if(dfn[x] == low[x]) { ++cnt1; while(true) { int now = ss.top(); ss.pop(); sccno[now] = cnt1; sd[now] = cnt1; f[cnt1] ++; if(now == x) break; } }}int main() { n = read(); m = read(); for(int i = 1; i &lt;= m; i++) { u = read(); v = read(); addedge1(u, v); } for(int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i); } for(int i = 1; i &lt;= m; i++) { u = sd[edge1[i].u]; v = sd[edge1[i].to]; if(u == v) continue; addedge2(u, v); } for(int i = 1; i &lt;= cnt1; i++) { if(!head2[i]) { pos = i; num++; } if(num == 2) { cout &lt;&lt; \"0\" &lt;&lt; endl; return 0; } } cout &lt;&lt; f[pos] &lt;&lt; endl; return 0;} Luogu 1262 间谍网络考虑无解的情况。若存在一个点既不能被贿赂，也没有入度，则不存在答案。 先缩点。对于现在没有入度且原先在强连通分量中的点，代价即为这些点中花费最小的值，累加即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;const int MAXN = 100050;const int INF = 1 &lt;&lt; 30;int n, m, u, v, p, num1, num2, cnt, cnt1, ans, in[MAXN], dfn[MAXN], low[MAXN], head1[MAXN], head2[MAXN], sccno[MAXN], val[MAXN], vall[MAXN], sd[MAXN];using namespace std;stack&lt;int&gt; s;struct Edge1 { int u, to, nextt;}edge1[MAXN];int read() { int x = 0; bool sign = false; char alpha = 0; while(!isdigit(alpha)) { sign |= alpha == '-'; alpha = getchar(); } while(isdigit(alpha)) { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (alpha ^ 48); alpha = getchar(); } return sign ? -x : x;}void addedge1(int u, int v) { edge1[++num1].u = u; edge1[num1].to = v; edge1[num1].nextt = head1[u]; head1[u] = num1;}void tarjan(int x) { dfn[x] = low[x] = ++cnt; s.push(x); for(int i = head1[x]; i; i = edge1[i].nextt) { int to = edge1[i].to; if(!dfn[to]) { tarjan(to); low[x] = min(low[x], low[to]); } else if(!sccno[to]) low[x] = min(low[x], dfn[to]); } if(dfn[x] == low[x]) { ++cnt1; while(true) { int now = s.top(); s.pop(); sd[now] = cnt1; sccno[now] = cnt1; vall[cnt1] = min(vall[cnt1], val[now]); if(now == x) break; } }}int main() { n = read(); p = read(); for(int i = 1; i &lt;= n; i++) val[i] = vall[i] = INF; for(int i = 1; i &lt;= p; i++) { u = read(); val[u] = read(); } m = read(); for(int i = 1; i &lt;= m; i++) { u = read(); v = read(); in[v]++; addedge1(u, v); } for(int i = 1; i &lt;= n; i++) { if(val[i] == INF &amp;&amp; in[i] == 0) { cout &lt;&lt; \"NO\" &lt;&lt; endl &lt;&lt; i &lt;&lt; endl; return 0; } } for(int i = 1; i &lt;= n; i++) { if(!dfn[i] &amp;&amp; val[i] != INF) tarjan(i); } for(int i = 1; i &lt;= n; i++) in[i] = 0; for(int i = 1; i &lt;= num1; i++) { u = sd[edge1[i].u]; v = sd[edge1[i].to]; if(u == v) continue; in[v]++; } for(int i = 1; i &lt;= cnt1; i++) { if(in[i] == 0) ans += vall[i]; } cout &lt;&lt; \"YES\" &lt;&lt; endl &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/07/26/tarjan%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-BeyondLimits/"},{"title":"2019THU创客营游记","text":"Day 0昨天刚刚经历了第一次月考，上午经历了惨痛的试卷讲评，内心压抑QAQ… 通知的中午在一中后门集合，于是上午上了4节课后就跑回家拿行李箱去了…还好没迟到… 做着一辆超载的别克商务车，前往地窝堡国际机场。 在车上认识了一些高二的学长，聊的还挺开心。 到机场后终于看到了许多熟悉的小伙伴，总算不是那么的孤独尴尬了… 候机中： 因为去的时候没有坐在靠窗户的位置，因此没有拍照。 许久没有做过飞机了，这种久违的感觉很奇妙。 飞机餐是牛肉米饭，挺烫的，味道不错。 4个小时，看了一部不错的电影，写了一会代码，读了一会书，就这样度过了。 飞机下降时，感到自己的眉骨附近疼的要命，难受万分。下飞机后查了一下说是什么航空性鼻窦炎…因为自己之前也一直在感冒，后面不疼了也就没管了。 Arrived. 到了北京，感觉温度和这边其实差距不大，晚上吹着微风，还挺舒服。 做了1个小时的大巴，写了一个小时的代码，度过了这无聊的时间。 夜宵+早餐： 双人间，和我住一起的刚好是我在去机场路上认识的一个高二的，至少没那么尴尬啦。 当时没什么食欲，没吃什么东西就准备睡了，结果室友和他的朋友点了麦当劳的外卖，顿时饿了… Day 1清晨的北京： 很早就起床，前往清华大学。 昨晚没睡好，在车上一直睡… 街景： 到达李兆基科技大楼 然后就是抽签分组，签名墙留名。 会场： 之前看到好多妹子，想着我们这一组应该…男女比例正常… 结果…四个男的… 还有一些奇葩的：szy他们组只有他一个男的等等 果然抽签的方式…哎… 开营仪式：","link":"/2019/04/27/2019THU%E5%88%9B%E5%AE%A2%E8%90%A5%E6%B8%B8%E8%AE%B0-updating-BeyondLimits/"}],"tags":[{"name":"差分","slug":"差分","link":"/tags/%E5%B7%AE%E5%88%86/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二进制枚举","slug":"二进制枚举","link":"/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/"},{"name":"构造","slug":"构造","link":"/tags/%E6%9E%84%E9%80%A0/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"状态压缩","slug":"状态压缩","link":"/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"思维","slug":"思维","link":"/tags/%E6%80%9D%E7%BB%B4/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"哈希","slug":"哈希","link":"/tags/%E5%93%88%E5%B8%8C/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"CSP 认证","slug":"CSP-认证","link":"/tags/CSP-%E8%AE%A4%E8%AF%81/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"加缪手记","slug":"加缪手记","link":"/tags/%E5%8A%A0%E7%BC%AA%E6%89%8B%E8%AE%B0/"},{"name":"摘抄","slug":"摘抄","link":"/tags/%E6%91%98%E6%8A%84/"},{"name":"微机原理","slug":"微机原理","link":"/tags/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"},{"name":"汇编语言","slug":"汇编语言","link":"/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"抽象代数","slug":"抽象代数","link":"/tags/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/"},{"name":"群论","slug":"群论","link":"/tags/%E7%BE%A4%E8%AE%BA/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"关系数据库","slug":"关系数据库","link":"/tags/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"生物学","slug":"生物学","link":"/tags/%E7%94%9F%E7%89%A9%E5%AD%A6/"},{"name":"算法实验","slug":"算法实验","link":"/tags/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"计算机安全","slug":"计算机安全","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8/"},{"name":"密码学","slug":"密码学","link":"/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"计组","slug":"计组","link":"/tags/%E8%AE%A1%E7%BB%84/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"网络安全","slug":"网络安全","link":"/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"软件安全","slug":"软件安全","link":"/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/"},{"name":"计算机病毒","slug":"计算机病毒","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92/"},{"name":"总线","slug":"总线","link":"/tags/%E6%80%BB%E7%BA%BF/"},{"name":"Web安全","slug":"Web安全","link":"/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"线性代数","slug":"线性代数","link":"/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"CSAPP","slug":"CSAPP","link":"/tags/CSAPP/"},{"name":"分布式计算","slug":"分布式计算","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"},{"name":"Go","slug":"Go","link":"/tags/Go/"}],"categories":[{"name":"算法竞赛","slug":"算法竞赛","link":"/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"编程学习","slug":"编程学习","link":"/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"专业知识","slug":"专业知识","link":"/categories/%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/"},{"name":"计算机安全","slug":"计算机安全","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"网络安全","slug":"网络安全","link":"/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"}],"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}]}