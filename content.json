{"posts":[{"title":"About me","text":"原博客链接：https://www.cnblogs.com/BeyondLimits/Hello, Hexo!今年大三，西安电子科技大学-计算机科学与技术专业在读。这个博客主要是用于记录自己学习生涯中的笔记、平时阅读到好书好句时的一些摘抄、以及一些随笔。后期可能会上传一些自己的摄影作品。希望自己能做一个万物学徒，一个一直在思考的人。","link":"/2023/10/19/About%20me/"},{"title":"抽象代数笔记","text":"6.1 代数结构代数系统（代数）：非空集合 和 上的 个一元或二元运算 组成的系统。记作 。 6.1.1 代数运算设 是非空集合， 是从 到 的一个映射，则称 为集合 到 的一个 元代数运算。（其中 称作该运算的阶）。 等这些符号加上 普通 的前缀，才代表的是其原来的运算。 运算的封闭性设 为集合 到 的一个 元运算。若 ,则称 在集合 上是封闭的。e.g. 普通减运算在 上不封闭。 若称一个运算是某个集合上的运算，则该运算必须满足在这个集合上具有封闭性。 1. 运算性质 - 交换律设 为 上的二元运算，若 都有： x \\ast y = y \\ast x则称运算 在 上可交换。若已知该运算的运算表，则可通过判断该表是否满足沿主对角线对称，来判断是否满足交换律。 2. 运算性质 - 结合律设 为 上的二元运算，若 都有: (x \\ast y) \\ast z = x \\ast (y \\ast z)则称运算 在 上可结合。判断该运算是否满足结合律，不能通过运算表直观的看出来。 3. 运算性质 - 分配律设 为 上的二元运算，若 都有： x \\ast (y \\circ z) = (x \\ast y) \\circ (x \\ast z), \\quad 称 \\ast 对 \\circ 左可分配 \\\\ (y \\circ z) \\ast x = (y \\ast x) \\circ (z \\ast x), \\quad 称 \\circ 对 \\ast 右可分配则称 对 可分配。 4. 运算性质 - 吸收律设 为 上的二元运算，若 都有： x \\ast (x \\circ y) = x, \\quad 称 \\ast 对 \\circ 左可吸收 \\\\ (x \\circ y) \\ast x = x, \\quad 称 \\circ 对 \\ast 右可吸收则称 对 可吸收。若 满足交换律，则只需证明一边满足吸收律即可。e.g. 集合中的 运算对 运算可吸收。因为 （右可吸收同理）。 5. 运算性质 - 等幂律设 为 上的二元运算，若 都有: x \\ast x = x则称运算 在 上满足等幂律。 6. 运算性质 - 消去律设 为 上的二元运算，某个元素 ，若 都有： a \\ast x = a \\ast y \\ \\Rightarrow x = y, \\quad 称a是左可消去的 \\\\ x \\ast a = y \\ast a \\ \\Rightarrow x = y, \\quad 称a是右可消去的则称 关于 运算 是可消去的。若 中所有的元素都满足消去律，则可说明 满足消去律。 叫做永真蕴含式。箭头左边的式子叫做前件，右边的叫做后件。永真蕴含式表明，若前件成立，则后件一定成立。永真蕴含式的逆否形式也成立。 可消去性可以从运算表中观察到。若 满足消去律，则运算表中每一行每一列中都没有相同的元素。 6.1.2 代数常元该代数系统中与运算相关的特殊元素称作代数常元。 1. 幺元设 是定义在 上的二元运算，若存在元素 (或 ) 使得 都有： e_l \\ast x = x \\quad （或 \\ x \\ast e_r = x）则称 (或 ) 是 中关于 运算的左（右）幺元。若 既是左幺元又是右幺元，则称 是 中关于 运算的幺元。且 是 上关于 的唯一的幺元。 2. 零元设 是定义在 上的二元运算，若存在元素 (或 ) 使得 都有： \\theta_l \\ast x = \\theta_l \\quad （或 \\ x \\ast \\theta_r = \\theta_r）则称 (或 ) 是 中关于 运算的左（右）零元。若 既是左零元又是右零元，则称 是 中关于 运算的零元。且 是 上关于 的唯一的零元。 3. 逆元设 是定义在 上的二元运算， 是 中关于 运算的幺元。对于 , 如果存在 （或 ）使得： y_l \\ast x = e \\quad （或 \\ x \\ast y_r = e）则称 (或 ) 是 的左（右）逆元。若 既是左逆元又是右逆元，则称 是 的逆元。 若 运算是可结合的，且对于 存在 ，则 是 的唯一的逆元, 。 6.2 子代数6.2.1 子代数的定义设 是一个代数系统， 分别是载体 上的二元运算和一元运算， 是代数常元。若： A' \\subseteq A \\\\ A' 对 \\ast 和 \\varDelta 均封闭 \\\\ k \\subseteq A'则称 是 的子代数系统。若 ， 被称为 的最大的子代数。若 ， 被称为 的最小的子代数。最大和最小子代数被称为 的平凡子代数。其余的子代数（）被称为 的真子代数。 6.3 同态6.3.1 同态的定义设 两个具有相同构成的代数系统， 是从 到 的一个映射， 且对 满足（先运算再映射 = 先映射再运算）： f(a\\ast b) = f(a) \\ast'f(b) \\\\ f(\\varDelta a) = \\varDelta'f(a) \\\\ f(k) = k'则称 为由 到 的一个同态映射， 简称同态， 记作 。 6.3.2 同态象设 是从 到 的同态映射，称 为 在映射 下的同态象。 6.3.3 同态的分类设 是从 到 的一个映射。 满射：若 中每个值都能在 中找到其原象，则称 是一个满射。 单射：若 ，都有 。则称 是一个单射。 双射：既是满射又是双射的映射。 设 是从 到 的一个同态映射。 若 是满射的，则称 是一个满同态。 若 是单射的，则称 是一个单一同态。 若 是双射的，则称 是一个同构映射，简称同构，记作 。 若 ，则称 为 上的自同态。 若 且 是双射的，则称 为 上的自同构。 6.3.4 同态的性质设 是从 到 的一个同态映射。那么 的同态象 。 是 的子代数。 若 在 中可交换（可结合），则 在 中也可交换（可结合）。 若在 中 对 可分配，则在 中 对 也可分配。 若 是 中关于运算 的幺元，则 也是 中关于运算 的幺元。 若 是 中关于运算 的零元，则 也是 中关于运算 的零元。 , 对运算 存在逆元 ；则在 中， 也有关于运算 的逆元 。 6.4 同余6.4.1 同余的定义设代数系统 ， 是载体 上的等价关系。 ： 当 时，若 ，则说明等价关系在一元运算 下是可保持的，称 是关于运算 的同余关系。 当 时，若 ，则说明等价关系在二元运算 下是可保持的，称 是关于运算 的同余关系。 若 在 上的所有运算下都是可保持的，则称 是代数系统 上的同余关系。 等价关系具有对称性、自反性、传递性。 6.4.2 与同态有关的定理设 是从 到 的一个同态映射。若在 上定义等价关系 ： \\langle a, b \\rangle \\in R, \\quad iff: g(a) = g(b)则 是 上的一个同余关系。 6.5 商代数6.5.1 商代数的定义与性质设代数系统 ， 是 上的同余关系。则称 关于 的商代数 。其中 。 是集合的集合，即等价类的集合。该集合是 的一个划分，即该集合中任意两元素（集合）的交集是空集（因为等价具有传递性）。 是集合间的运算， 是代数常元的集合。 小结：由等价关系 可以得到代数系统 的载体的一个划分，以这个划分为新的载体，按照原运算的规则建立等价类之间新的运算，这样得到的代数系统是原代数系统的商代数。 6.6 半群与独异点6.6.1 半群与子半群半群：对于一个代数系统 ， 是 上的二元运算，若运算 是可结合的，则称 为半群。子半群：设 是一个半群， 且 在 上是封闭的，那么 是 的子代数。 也是一个半群，称为 的子半群（因为结合律在子代数上可继承）。 6.6.2 独异点与子独异点独异点：含有幺元的半群（含幺半群）。子独异点：满足是原代数系统的子代数，本身是独异点，且在相同运算下与原代数系统有相同幺元，那么称为是原独异点的子独异点。 6.6.3 半群与独异点的等幂元性质设 是一个半群，若 是一个有限集，则必存在 ，使得 。证明：结合鸽巢原理。 6.6.4 交换半群与循环独异点交换半群（独异点）：在半群（独异点）中，若运算是可交换的，则称此半群（独异点）为交换半群（独异点）。 循环独异点：设 是一个独异点，若 ，则 使得 （ 是 个 做运算的意思），则称此独异点为循环独异点。 （存在一个数能把其他所有数都表示出来） 称为该循环独异点的生成元，一个循环独异点的生成元个数可以不唯一。 6.7 群6.7.1 群的定义群：设 是一个代数系统。若 运算是可结合的（是半群），并且存在幺元（是独异点），并且 ，都存在其唯一的逆元 ，则称 是一个群。 群的阶数：群的元素个数，记作 。根据 可以将群分为有限群和无限群。 6.7.2 群的性质 群中无零元。 （因为零元不可逆，故群中一定不含零元。） 群中每个元素的逆元唯一。 设 是一个群，对于 ，必存在唯一的 ，使得 。 （即群中任何两个元素都能通过运算相互表示。） 设 是一个群， ，若有 或者 ，则必有 （消去律）。 （因为没有零元，所以可以直接消去。） 设 是一个群，除幺元 外，不可能有任何别的等幂元。 （幺元是唯一的等幂元。） 群 的运算表的每一行/每一列都是 中所有元素的一个置换。 （ 中每一个元素都会在运算表中的每一行/每一列出现，并且只出现一次。） 6.7.3 群中元素的阶设 是一个群， 是幺元， 。若存在唯一且最小的正整数 使得 ，则称 为元素 的阶（或周期）；否则称元素 的阶是无限的。 定理1若群 的元素 拥有一个有限阶 ，则 当且仅当 是 的倍数。 定理2群中任何一个元素 与它的逆元 都具有相同的阶。 定理3有限群 中任何一个元素的阶最多是 。 6.7.4 阿贝尔群与循环群阿贝尔群：若群 中 运算是可交换的，则称该群为阿贝尔群（Abel 群）或交换群。 循环群：设 是群，若 ，则称 为循环群。 是循环群 的一个生成元。一个循环群的生成元个数可以不唯一。与循环独异点不同的是，循环群中 中的 可以取负整数。在这里理解成对 先求逆，再进行 次的运算。 任何一个循环群必定是阿贝尔群。（证明：将元素写成生成元的幂的形式，再证明 的可交换性，其中用到了加法是可交换的。） 6.7.5 循环群的性质设 是循环群，它的生成元是 ，，则： 是使 的最小正整数。 。 6.7.6 子群和群同态设 是群， 是 的非空子集，并满足： ， 其中 是 的幺元。 则称 是 的子群。 和 称作 的平凡子群。（联想到子代数和平凡子代数的概念。）","link":"/2023/10/18/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/"},{"title":"「加缪手记」摘抄","text":"10.15序：写下生命中对思考创作有意义的当下片段，本质上即是赋予无形体验以有形的存在和表现形式。 8月的雷雨天。热风和乌云。但东方却透出一抹晴蓝，轻盈而剔透。叫人无法直视。这样的蓝，对眼睛和灵魂来说都是一种折磨。因为美会让人受不了。美会让人万念俱灰，因为我们是多想要让这种刹那的永恒一直持续下去。 年轻时，我会向众生索要他们能力范围之外的：友谊长存，热情不灭。如今，我明白只能要求对方能力范围之内的：做伴就好，不用说话。而他们的情感、友谊和操守，在我眼中仍完全是一种奇迹，是恩惠的完全表现。 时间会过得这么快，是因为我们没办法在里面做什么记号。类似月亮是在天顶还是在地平线之上类的。这就是为什么那些青春岁月如此漫长，因为太丰盛，而年华老去时则光阴似箭，因为一切都已成定局。譬如我就发现几乎不可能盯着一根指针在钟面上绕五分钟，而不会感到漫长和厌烦的。 一阵颇带劲的微风从山上吹下来，翻搅着青草与阳光。令人赞叹之光从天而降。底下是光滑无痕的海面，正露着它的蓝色牙齿在微笑。我站在风里，头顶上的太阳只能晒到一边的脸庞。我凝视着这个独一无二的时刻流逝，不晓得该说些什么。 10.16有时候我也需要写下一些自己也不太明白，但却正好可以证明我有个无法羁束的内在的东西。 他每天都到山上去，又默默地回来，头发上都是草，身上都是一整天下来的刮痕。每一次都是无须勾引就被诱惑了。对这个不友善的地方，他内心的抗拒逐渐在减弱。他终于可以想象自己是棱线上那株孤杉背后的多多白云，是那漫山遍野、有着粉红斑点的柳叶菜、花楸和风铃草。他让自己融入了这个嶙峋的芬芳国度。登上遥不可及的山巅时，眼前豁然一片无际的风光，但他内心初生的爱意并未因此获得舒缓，而是暗自和这个不仁的天地订立某种约定，两张刚强倨傲的脸庞之间的停战协议，像敌人在互相威吓，而非朋友间的全然信赖。 在这个溢满繁星的夜里，他伸出手在夜空静谧无边的脸上比画着。他一只胳膊一挥，就把这颗明星和另外那颗时隐时现的星星分开了，一束束的星辰和一朵朵的云，就随着他的挥洒散落下来。于是天上有一池被他搅乱的水，而围绕着他的那座城市，宛如一顶缀满贝壳的华丽斗篷。 人在马赛，幸福和悲哀——在我内心最深处。我喜爱的繁华都市。但同时这孤独的苦味。 灿烂宣泄的阳光。摩纳哥的夹竹桃和繁花遍地的热那亚。利古里亚海岸线上的蓝色夜晚。我的疲倦和这股想哭的冲动。这种孤单和这份想要爱的渴望。比萨，一个腼腆而敏感的城市。夜里，在无人的街道上，它和我靠得这么近，我在街上漫游，想要流出来的眼泪终于决堤了。我内心那道伤口也开始愈合了。 10.17某些事物、某些生命正在等着我，而我当然也在期待着，用我所有的力量和悲情渴望着。 也许我眼前的景物已经被好几百万只眼睛注视过了，但对我而言，它宛如这世界浮现的第一抹微笑。这个世界很美，一切尽在其中。它耐心地宣扬它的伟大真理：那些所谓的精神和心灵，其实都是虚空。而在这个由骄阳下的发烫石头，晴空下更显高大的柏树所界定出来的、独一无二的天地中，“正确”的意思是“无人的大自然”。它带着我直到尽头。它心平气和地否定了我。而我，心悦诚服地，朝着某种圆融的智慧前进——如果我不要这样热泪盈眶，如果我想要号啕大哭的诗心未曾令我将这世界的真理抛却脑后。 舔舐自己的生命，仿佛那是一颗麦芽糖，塑造它，磨砺它，爱它。 我一定会努力将这场和自己的面对面一直延续到底，让它照见我在今生今世中的每一张脸，即使必须付出难以负担的寂寞代价亦在所不惜。我会竭尽全力去达成某个境界，在那儿和我的所爱会合，接着，我俩将以最大的热情去做那些构成我每日生活意义的事。 脸上交织着泪光和阳光的人生，没有盐巴的人生和热石头，一如我所爱、所渴望的人生，我一面怀想着，觉得似乎我所有绝望和爱的力量都因此集合起来了。 10.18艾尔凯达墓园。阴霾的天，满山的白纹和对面的大海。潮湿的土壤和树木。白色墓碑间的鸽子。一朵孤单的天竺葵，颜色难说是粉红还是红。一股迷茫而沉默的巨大悲伤，让死亡那张美丽纯洁的脸庞变得亲切起来。 他说：“每个人生命中都要有爱，一种大爱，因为这样就可以有借口不用去面对那些令人不堪负荷、说不出缘由的绝望。” 他轻轻咬着她的唇，然后，一连好几分钟，嘴对着嘴，吸吮着这令他心神荡漾的温热，仿佛整个世界都拥进怀里了。至于她，像个溺水的人似的抱着他，在这个被人推下去的黑洞里载沉载浮，那两片唇被推开后又会立刻黏上来，她于是再度坠入一片又冷又黑、宛如一群天使般让她浑身着火的水中。 10.25这个世界的悲惨和伟大：不给我们任何真相，但有许多爱。荒谬当道，爱拯救之。 尼采：“当我们见到美的时候心里想要的是什么呢？希望自己也是美的。我们可以想象有多少快乐都寄托在上面，但这是个错误。”（《人性的，太人性的》） 我们所感受到的情感并不会改造我们，但是会让我们有那种想要改变的念头。所以爱并不能让我们不再自私，却可以令我们对此有所察觉，并让我们开始向往一个没有自私的遥远国度。 艺术家和艺术作品。真正的艺术作品是那种点到为止的。一个艺术家的整体经验和他的想法、人生（就某种意义而言即他的“系统”——除掉这个字的系统性意涵的话）之间，有着某种关联，而作品正是这种经验的反映。如果艺术作品把整个经验都讲出来，还包上一层文艺的流苏，那么此一关联就是恶劣的。但如果艺术作品只是从整个经验中切削下来的一小块，像钻石的一个切面，内蕴的光芒将无穷扩散。第一种是超载的文学。第二种则是沃土般的作品，那些不言而喻的经验正暗示着它丰富的内容。问题在于如何取得这种超出写作技巧的处世之道（不如说是经验谈）。到头来，伟大的艺术家其实就是一个了不起的活人（“活着”在这里亦指思考生命——或说是经验和因而产生的意识之间的那种微妙关系）。 他躺下来，傻笑，两只眼睛闪闪发光。她觉得自己所有的爱都哽在喉头，热泪盈眶。她扑向他的双唇，泪珠都让两人的脸庞挤碎了。泪水也流进了她的嘴里。而他，他咬着这两片咸咸的嘴唇，像是在咀嚼他们爱情里的苦涩。 火车上的小情侣。两个都长得不好看。她拉着他，笑吟吟的，撒娇，撩拨他。而他，两眼无神，因在大庭广众之下被一个他并不引以为傲的女人爱着而感到尴尬。 今天，如果我试着去把这独特的感动说清楚，我可以从中看到很多东西。当然，这样的喜悦首先来自让娜——来自她身上的香水味，她紧紧扣着我手腕的手，一些我可预期的表情。但还有那些突然光芒四射的商店，在一个平常伸手不见五指的城区里，行色匆匆，手上提着大包小包的行人，街上孩子的欢笑声，一切都有助于把人从他的原本的孤独世界里拉出来。那些夹心巧克力的银色包装纸就是一种征兆，意味着一个模糊却嘈杂的黄金时期，正在向一些简单的心灵打开，于是让娜和我又依偎地更紧了。也许当时我们都模模糊糊地感觉到了那种独一无二的、当一个人跟自己的人生终于取得妥协时的幸福。通常是我们在一个爱已无立足之地的世界里，带着那片被我们用爱情施了魔咒的沙漠到处游走。而在那几天里，我们觉得当我们手牵手时，心中升起的那把热情，和在橱窗里、在对儿女牵肠挂肚的工人心里，以及在这12月冰冻而纯净的天空深处闪烁的，是一样的火焰。 天气只好一半：有云也有阳光。和谐的地方。只要一大块天，就能让最紧张的心平静下来。 从圣塔克鲁斯看米尔斯克比尔，给人一种雄伟感。壮观得毫不温柔。","link":"/2023/10/15/%E3%80%8C%E5%8A%A0%E7%BC%AA%E6%89%8B%E8%AE%B0%E3%80%8D%E6%91%98%E6%8A%84/"},{"title":"微机原理笔记 - chap3 - Intel处理器指令系统及汇编语言","text":"汇编语言基础数据定义： 数据传送、算术运算、跳转指令MOV 指令“先目的操作数，再源操作数。” MOV 指令需要遵循的规则： 两个操作数的尺寸必须一致。 两个操作数不能同时为内存操作数。 1234567mov reg, regmov mem, regmov reg, memmov mem, immmov reg, immmov var2, var1 ;不合法，需要用寄存器来实现 目的操作数不能是 CS，EIP 和 IP。 立即数不能直接送至段寄存器。 XCHG 指令用来交换两个操作数的内容。 123xchg reg, regxchg reg, memxchg mem, reg 若要交换两个内存操作数，还是需要利用寄存器，即 MOV 与 XCHG 结合使用。 INC 和 DEC 指令分别实现加 1 与减 1 操作。 12inc reg/memdec reg/mem ADD 和 SUB 指令ADD 将同尺寸的源操作数和目的操作数相加，结果在目的操作数中（不改变源操作数）。 SUB 将源操作数从目的操作数中减掉，结果在目的操作数中（不改变源操作数） 两者都同 MOV 指令一样，先目的操作数，再源操作数。 1234567.datavar1 DWORD 20000hvar2 DWORD 10000h.codemov eax, var1add eax, var2 ;30000hsub eax, var2 ;20000h NEG 指令认为操作数是有符号数，形式是补码。该指令将操作数按位取反、末位加 1。 算术运算影响的标志 零标志位 ZF 12345mov cx, 1sub cx, 1 ; ZF = 1mov ax, 0FFFFh ; 全1理解成补码，真值就是-1inc ax ; ZF = 1inc ax ; ZF = 0 符号标志位 SF 123mov cx,0sub cx,1 ; SF = 1add cx,2 ; SF = 0 进位标志位 CF 1234567891011mov al,0FFhadd al,1 ; CF = 1mov ax,00FFhadd ax,1 ; CF = 0mov ax,0FFFFhadd ax,1 ; CF = 1mov al,1sub al,2 ; CF = 1。最高位向更高位有进位或借位时置1 溢出标识位 OF 其中 是符号位产生的进位，即标志位 CF； 是最高有效位向符号位产生的进位。 1234567891011mov al,+127add al,1 ; OF = 1mov al,-128sub al,1 ; OF = 1mov al,-128 ; AL = 10000000bneg al ; AL = 10000000b, OF = 1mov al,+127 ; AL = 01111111bneg al ; AL = 10000001b, OF = 1 JMP 和 LOOP 指令JMP ：无条件转移 12345top: jmp top ;repeat the endless loop LOOP ：条件转移 1234567mov ax,0mov ecx,5L1: inc axloop L1;循环体的第一条指令必须要给标号。循环体的最后一条指令要用loop，后面跟这个标号 ;循环结束时，AX=5 ECX=0 过程 条件处理AND 指令 与 OR 指令1AND / OR 目的操作数 源操作数 两个操作数可以是8、16 或 32位的，但它们的尺寸必须相同。影响的标志位：总是清除 OF 和 CF，根据结果修改 SF、ZF、PF。 AND 指令应用： OR 指令应用： NOT 指令将操作数所有数据位取反，结果为反码。 12mov al,11110000bnot al ; AL = 00001111b 条件跳转指令 整数算数指令移位指令 乘法和除法指令 字符串和数组基址变址 (base-index) 操作数：将两个寄存器的值相加(称为基址寄存器、变址寄存器)来产生偏移地址。保护模式程序中，可使用任意32位通用寄存器。 宏 使用I/O端口控制硬件x86属于独立编址，要访问接口地址空间只能用 IN 指令 和 OUT 指令。不管是8086还是32位、64位的CPU，接口地址都是16位的，端口地址范围为0~FFFFh。 32/64位处理器扩展指令 —— 多媒体/流媒体SIMD扩展指令集Pentium II：引入 MMX 指令集，实现64位并行处理。Pentium III：引入 SSE 指令集，实现128位并行浮点运算。Pentium 4：引入 SSE2 指令集，实现128位并行定点运算。","link":"/2023/10/19/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0-chap3-Intel%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8F%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"title":"微机原理笔记 - chap2 - Intel单核&#x2F;多核处理器","text":"单核处理器（8086/8088）8086/8088 功能特性第一次将流水线思想引进微处理器：指令级流水。存储器分段管理机制引入处理器，扩大寻址能力。 内存地址分段：寄存器最多存 16 位，故有些寄存器用来当段寄存器，代表着地址的高 16 位（低 4 位默认为 0 ）。再加上段内偏移寄存器的值（低 16 位），就可以实现 1MB 的内存寻址。 接口数量不会很多，所以地址不用分段。 8086/8088 体系结构 地址加法器的意义：避免结构冒险，保证计算地址和计算数据可以并行。 总线接口单元 BIU ：取指令，取数据，送数据。执行单元 EU ：执行指令。BIU 与 EU 相互独立，相互配合。 寄存器 在 14 个寄存器中，只有 A～DX 既可以当作 16 位寄存器，也可以当作 8 位寄存器。 除了当通用寄存器，BX 可以当作指针，用来寄存器间接寻址，即 [BX]。（ [AX], [CX], [DX] 都是不合法的写法） 访问堆栈的时候可以用 BP（基址指针寄存器）来间接寻址，读/写堆栈里面任何位置的数据，同时不会破坏栈的结构（不会影响栈顶当前的位置）。 标志寄存器AF：辅助进位标志位，加法时若 向 有进位， AF 置 1 。CF：进位/借位标志位，若加法时最高位向更高位有进位 或 减法时最高位向更高位有借位， CF 置 1 。PF：奇偶标志位，若运算结果低八位中 1 的个数是偶数，PF 置 1 。SF：符号标志位，反映运算结果的最高位，最高位是什么 SF 就是什么。ZF：零标志位，若运算结果为 0 ， ZF 置 1 。OF：溢出标志位，若运算结果溢出， OF 置 1 。","link":"/2023/10/19/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0-chap2-Intel%E5%8D%95%E6%A0%B8:%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/"},{"title":"微机原理笔记 - chap1 - 绪论","text":"Intel微处理器的发展 1978年：8086/8088微处理器出现，首枚16位微处理器。 微型计算机概述计算机加电以后，首先运行 BIOS(Basic Input Output System) 系统，进行硬件的检查、初始化（加电时寄存器的内容是随机的）、给操作系统提供编程接口等。 通过硬件驱动程序、BIOS / UEFI 提供的编程接口，操作系统可以访问硬件。从而实现两台硬件层面不同的计算机可以安装相同的操作系统.","link":"/2023/10/19/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0-chap1-%E7%BB%AA%E8%AE%BA/"},{"title":"数据库系统笔记 - chap3 - SQL","text":"Introduction to SQLSQL（Structured Query Language），是关系数据库的标准查询语言。 SQL 的特点： 综合统一SQL 集数据定义语言（DDL），数据操纵语言（DML），数据控制语言 （DCL）功能于一体。 高度非过程化 SQL 只要提出“做什么”，而无须指明“怎么做”，因此无须了解存取路径。存取路径的选择以及 SQL 的操作过程由系统自动完成。 面向集合的操作方式SQL 采用集合操作方式，不仅操作对象、查找结果可以是元组的集合，而且一次插入、删除、更新操作的对象也可以是元组的集合。 以同一种语法结构提供多种使用方式 SQL 是独立的语言，能够独立地用于联机交互的使用方式。同时 SQL 也是嵌入式语言，能够嵌入到高级语言（例如 C，C++，Java）程序中，供程序员设计程序时使用。 在两种不同的方式下， SQL 的语法结构基本上是一致的。 支持 SQL 的关系数据库管理系统同样支持关系数据库三级模式结构，如下图所示。其中外模式包含若干视图（view）和部分基本表（base table），模式包括若干基本表，内模式包括若干存储文件（stored file）。 基本表是本身独立存在的表，在关系数据库管理系统中一个关系就对应一个基本表。一个或多个基本表对应一个存储文件，一个表可以带若干索引，索引也存放在存储文件中。 存储文件的逻辑结构组成了关系数据库的内模式。存储文件的物理结构对最终用户是隐蔽的。 视图是从一个或几个基本表导出的表。它本身不独立存储在数据库中，即数据库中只存放视图的定义而不存放视图对应的数据。这些数据仍存放在导出视图的基本表中，因此视图是一个虚表。视图在概念上与基本表等同，用户可以在视图上再定义视图。 数据定义CREATE 创建，DROP 删除，ALTER 修改（只有表和索引有这项）。 模式（SCHEMA）定义模式（CREATE SCHEMA）12CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;;/* 如果没有指定模式名，则模式名隐含为用户名 */ 为用户 CHEN 定义一个学生-课程模式 S-T。 1CREATE SCHEMA \"S-T\" AUTHORIZATION CHEN; 删除模式（DROP SCHEMA）1DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;; /* CASCADE 和 RESTRICT 两者必选其一 */ CASCADE（级联）：删除模式的同时把该模式中所有的数据库对象全部删除。RESTRICT（限制）：如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。仅当该模式中没有任何下属的对象时才能执行。 基本表（TABLE）定义基本表（CREATE TABLE） 建立一个学生信息表 Student。 1234567CREATE TABLE Student ( Sno CHAR(9) PRIMARY KEY, Sname CHAR(20) UNIQUE, Ssex CHAR(2), Sage SMALLINT， Sdept CHAR(20)); 建立一个学生选课表 SC 。 12345678CREATE TABLE SC ( Sno CHAR(9), Cno CHAR(4), Grade SMALLINT, PRIMARY KEY (Sno,Cno), /* 主码由两个属性构成，必须作为表级完整性进行定义 */ FOREIGN KEY (Sno) REFERENCES Student(Sno), /* 表级完整性约束条件 */ FOREIGN KEY (Cno) REFERENCES Course(Cno) /* 表级完整性约束条件 */); 如果完整性约束条件涉及该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级。 删除基本表（DROP TABLE）1DROP TABLE &lt;表名&gt; [RESTRICT | CASCADE]; CASCADE（级联）：删除该表没有限制条件。在删除基本表的同时，相关的依赖对象都将被一起删除。RESTRICT（限制）：删除该表是有限制条件的。欲删除的基本表不能被其他表的约束所引用（如 CHECK ， FOREIGN KEY 等约束），不能有视图、触发器、存储过程或函数等。如果存在依赖该表的对象，则此表不能被删除。 若表上建有视图，选择 RESTRICT 时表不能删除；选择 CASCADE 时可以删除表，视图也自动被删除。 12345678CREATE VIEW IS_StudentASSELECT Sno,Sname,SageFROM StudentWHERE Sdept='IS';DROP TABLE Student CASCADE;/* DROP TABLE Student RESTRICT; 会返回 Error */ 修改基本表（ALTER TABLE）12345678ALTER TABLE &lt;表名&gt;[ADD [COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [完整性约束]] [ADD &lt;表级完整性约束&gt;][DROP [COLUMN] &lt;列名&gt; [CASCADE| RESTRICT]][DROP CONSTRAINT &lt;完整性约束名&gt; [RESTRICT | CASCADE]][ALTER COLUMN &lt;列名&gt; &lt;数据类型&gt;]; ADD 子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件。 DROP COLUMN 子句用于删除表中的列，如果指定了 CASCADE 短语，则自动删除引用了该列的其他对象；如果指定了 RESTRICT 短语，则如果该列被其他对象引用，关系数据库管理系统将拒绝删除该列。 DROP CONSTRAINT 子句用于删除指定的完整性约束条件。 ALTER COLUMN 子句用于修改原有的列定义，包括修改列名和数据类型。 向 Student 表增加“入学时间”列，其数据类型为日期型。 1ALTER TABLE Student ADD S_entrance DATE; 将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数。 1ALTER TABLE Student ALTER COLUMN Sage INT; 增加课程名称必须取唯一值的约束条件。 1ALTER TABLE Course ADD UNIQUE(Cname); 模式与表每一个基本表都属于某一个模式，一个模式包含多个基本表。 定义基本表所属模式的三种方法： 在表名中明显地给出模式名。 1CREATE TABLE \"S-T\".Student(...); /* Student 所属的模式是 S-T */ 在创建模式语句中同时创建表。 12345678910/* 为用户 ZHANG 创建一个模式 TEST，并且在其中定义一个表 TAB1。 */CREATE SCHEMA TEST AUTHORIZATION ZHANGCREATE TABLE TAB1 ( COL1 SMALLINT, COL2 INT, COL3 CHAR(20), COL4 NUMERIC(10,3), COL5 DECIMAL(5,2)); 设置所属的模式，这样在创建表时表名中不必给出模式名。 索引（INDEX） WAITING TO BE UPDATED. 建立索引（CREATE INDEX）删除索引（DROP INDEX）修改索引（ALTER INDEX）数据查询单表查询只涉及一个表的查询叫做单表查询。 选择表中的若干列查询某个表的全部列： 1SELECT * FROM STUDENT; 查询某个表的部分列，列显示的具体顺序可以自定义： 1SELECT Sname, Sno FROM Student; 目标列表达式 不仅可以是算术表达式，还可以是字符串常量、函数等： 1SELECT Sname, 2021 - Sage FROM Student; 选择表中的若干元组消除取值重复的行：DISTINCT： 1SELECT DISTINCT Sno FROM SC; 查询满足条件的元组：WHERE 子句： 查询所有年龄在 20 岁以下的学生姓名及其年龄。 1SELECT Sname, Sage FROM Student WHERE Sage &lt; 20; 查询年龄不在 20~23 岁之间的学生姓名、系别和年龄。 1SELECT Sname, Sdept, Sage FROM Student WHERE Sage NOT BETWEEN 20 AND 23; 查询不是计算机科学系、数学系和信息系学生的姓名和性别。 1SELECT Sname, Ssex FROM Student WHERE Sdept NOT IN ('CS', 'MA', 'IS'); 查询所有有成绩的学生学号和课程号。 1SELECT Sno, Cno FROM SC WHERE Grade IS NOT NULL; /* `is NULL` 不能用 `= NULL` 代替 */ 查询计算机科学系年龄在 20 岁以下的学生姓名。 1SELECT Sname FROM Student WHERE Sdept = 'CS' AND Sage &lt; 20; /* AND 优先级比 OR 高，可用括号来改变优先级 */ 字符匹配 1[NOT] LIKE '&lt;匹配串&gt;' [ESCAPE '&lt;换码字符&gt;'] 其含义是查找指定的属性列值与 &lt;匹配串&gt; 相匹配的元组。&lt;匹配串&gt; 可以是一个完整的字符串，也可以含有通配符 % 和 _。 % 代表任意长度（长度可以为 0 ）的字符串。 e.g. a%b 表示以 a 开头，以 b 结尾的任意长度的字符串。 _ 代表任意单个字符。 e.g. a_b 表示以 a 开头，以 b 结尾的长度为 3 的任意字符串。 查询所有姓刘的学生的姓名、学号和性别。 1SELECT Sname, Sno, Ssex FROM Student WHERE Sname LIKE '刘%'; 查询姓 欧阳 且全名为三个汉字的学生的姓名。 1SELECT Sname FROM Student WHERE Sname LIKE '欧阳_'; 如果用户要查询的字符串本身就含有通配符 % 或 _ ，这时就要使用 ESCAPE &lt;换码字符&gt; 短语对通配符进行转义。 查询 DB_Design 课程的课程号和学分。 1SELECT Cno, Ccredit FROM Course WHERE Cname LIKE 'DB\\_Design' ESCAPE '\\'; ORDER BY 子句ORDER BY 子句可以对查询结果按照一个或多个属性列的升序(ASC)或降序(DESC)排列，默认值为升序。空值按最大值来参与排序。 查询选修了 3 号课程的学生的学号及其成绩，查询结果按分数的降序排列： 1SELECT Sno, Grade FROM SC WHERE Cno = '3' ORDER BY Grade DESC; 聚集函数为了进一步方便用户，增强检索功能，SQL 提供了许多聚集函数。 统计元组个数： COUNT(*) 统计一列中值的个数： COUNT([DISTINCT | ALL] &lt;列名&gt;) 计算一列值的总和（此列必须为数值型）： SUM([DISTINCT | ALL] &lt;列名&gt;) 计算一列值的平均值（此列必须为数值型）： AVG([DISTINCT | ALL] &lt;列名&gt;) 求一列中的最大值和最小值： MAX([DISTINCT | ALL] &lt;列名&gt;), MIN([DISTINCT | ALL] &lt;列名&gt;) 聚集函数只能用于 SELECT 子句和 GROUP BY 中的 HAVING 子句。 查询学生总人数。 1SELECT COUNT(*) FROM Student; 查询选修了课程的学生人数。 1SELECT COUNT(DISTINCT Sno) FROM SC; 计算选修 1 号课程的学生平均成绩。 1SELECT AVG(Grade) FROM SC WHERE Cno = '1'; 查询选修 1 号课程的学生最高分数。 1SELECT MAX(Grade) FROM SC WHERE Cno='1'; 查询学生 201215012 选修课程的总学分数。 1SELECT SUM(Ccredit) FROM SC, Course WHERE Sno = '201215012' AND SC.Cno = Course.Cno; GROUP BY 子句GROUP BY 子句将查询结果按某一列或多列的值分组，值相等的为一组。 将查询结果分组的目的是细化聚集函数的作用对象。如果未对查询结果分组，聚集函数将作用于整个查询结果。对查询结果分组后，聚集函数将分别作用于每个组，即每一组都有一个函数值。 查询平均成绩大于等于 90 分的学生学号和平均成绩。 1SELECT Sno, AVG(Grade) FROM SC GROUP BY Sno HAVING AVG(Grade) &gt;= 90; 连接查询若一个查询同时涉及两个以上的表，称为连接查询。连接查询是关系数据库中最主要的查询。 等值与非等值连接查询1[&lt;表名1&gt;.]&lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;.]&lt;列名2&gt; 查询每个学生及其选修课程的情况。 123SELECT Student.*, SC.*FROM Student, SCWHERE Student.Sno = SC.Sno; /* 将 Student 与 SC 中同一学生的元组连接起来 */ 自身连接一个表与其自己进行连接，称为表的自身连接。需要给表起别名以示区别。且由于所有属性名都是同名属性，因此必须使用别名前缀。 查询每一门课的间接先修课（即先修课的先修课）。 123SELECT FIRST.Cno, SECOND.CpnoFROM Course FIRST, Course SECONDWHERE FIRST.Cpno = SECOND.Cno; 外连接普通连接操作只输出满足连接条件的元组，而外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出。左外连接列出左边关系中所有的元组，右外连接列出右边关系中所有的元组。 使用外连接查询每个学生及其选修课程的情况。 12SELECT Student.Sno, Sname, Ssex, Sage, Sdept, Cno, GradeFROM Student LEFT OUTER JOIN SC ON (Student.Sno = SC.Sno); 多表连接两个以上的表进行连接称为多表连接。 查询每个学生的学号、姓名、选修的课程名及成绩。 123SELECT Student.Sno,Sname,Cname,Grade FROM Student,SC,CourseWHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno 关系数据库管理系统在执行多表连接时，通常是先进行两个表的连接操作，再将其连接结果与第三个表进行连接。 嵌套查询一个 SELECT-FROM-WHERE 语句称为一个查询块。嵌套查询是指将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中的查询。 123456SELECT Sname /* 外层查询或父查询 */FROM StudentWHERE Sno IN ( SELECT Sno /* 内层查询或子查询 */ FROM SC WHERE Cno='2') 子查询的 SELECT 语句不能使用 ORDER BY 子句，ORDER BY 子句只能对最终查询结果排序。 不相关子查询：子查询的查询条件不依赖于父查询，即由里向外逐层处理。相关子查询：子查询的查询条件依赖于父查询。 带有 IN 谓词的子查询在嵌套查询中，子查询的结果往往是一个集合，所以谓词 IN 是嵌套查询中最经常使用的谓词。 查询与 刘晨 在同一个系学习的学生。 1234567SELECT Sno, Sname, SdeptFROM StudentWHERE Sdept IN ( SELECT Sdept FROM Student WHERE Sname='刘晨') 也可以用自身连接来完成： 123SELECT S1.Sno, S1.Sname, S1.SdeptFROM Student S1, Student S2WHERE S1.Sdept = S2.Sdept AND S2.Sname = '刘晨'; 带有比较运算符的子查询 找出每个学生超过他自己选修课程平均成绩的课程号。 1234567SELECT Sno, CnoFROM SC x /* x 是表SC的别名，又称为元组变量，可以用来表示SC的一个元组 */WHERE Grade &gt;= ( SELECT AVG(Grade) FROM SC y WHERE y.Sno = x.Sno); 带有 ANY（SOME）或 ALL 谓词的子查询","link":"/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-chap3-SQL/"},{"title":"数据库系统笔记 - chap2 - 关系模型","text":"关系数据结构 关系代数A set of fundamental operations to retrieve and manipulate tuples in a relation. These operations take one or some relations as inputs, and outputs a new relation. 并、交、差、笛卡尔积与集合运算相似。 选择（Select）行视角，选择出符合条件的若干元祖集合。 符号: 举例: SQL写法: SELECT * FROM R WHERE Name = 'qaq' 投影（Projection）列视角，选择出若干属性列组成新的关系。 符号: 举例: SQL写法: SELECT Name, id FROM R WHERE Name = 'qaq' 投影运算会把新关系中的重复行删去（集合的不可重原则）。 连接（Join） 符号: 其中 是 与 上的度数相等且可比较的属性组， 是比较运算符。SQL: SELECT * FROM R JOIN S USING (ATTRIBUTE1, ATTRIBUTE2, ...) 若 为 ，则叫做等值连接。自然连接是一种特殊的等值连接，只不过是在等值连接的基础上去掉结果中重复的属性列。 关系的完整性关系的完整性约束是对关系正确性的限定。关系的完整性分为实体完整性、参照完整性和用户定义完整性。 实体完整性由于主码 Primary Key 是区分实体的唯一性标识，所以关系 的主码不能取空值 NULL （若主码由多个属性构成，则所有这些属性都不能取空值）。 12345678910111213141516171819CREATE TABLE Student ( Sno CHAR(9) PRIMARY KEY, // 列级 Sname CHAR(8), Ssex CHAR(2) CHECK(Ssex IN ('男', '女')),);CREATE TABLE Student ( Sno CHAR(9), Sname CHAR(8), Ssex CHAR(2) CHECK(Ssex IN ('男', '女')), PRIMARY KEY (Sno) // 表级);CREATE TABLE SC ( Sno CHAR(5), Cno CHAR(3), Grade int, PRIMARY KEY (Sno, Cno) // 表级，且只能是表级); 参照完整性参照完整性定义了外码 Foreign Key 与主码之间的引用规则，即外码的取值要么是 NULL （若外码包含多个属性，则这些属性的值均取 NULL ；但假如外码中的属性是主属性，则不能取 NULL ），要么是被参照关系中某元组在该属性的取值。（“你从别人那里引用到的任何值，别人得有才能给你引用”） 12345678CREATE TABLE SC ( Sno CHAR(5), Cno CHAR(3), Grade int, PRIMARY KEY (Sno, Cno), // 表级定义实体完整性 FOREIGN KEY (Sno) REFERENCES S(Sno), //表级定义参照完整性 FOREIGN KEY (Cno) REFERENCES C(Cno) //表级定义参照完整性); 用户定义完整性用户规定数据必须满足的一系列要求，包括属性上的约束与元组上的约束。 属性上的约束123456CREATE TABLE SC ( Sno CHAR(5) NOT NULL // 约束 Sno 非空 Cno CHAR(9) UNIQUE NOT NULL, // 约束 Cno 唯一且非空 Age SMALLINT CHECK (Age &gt;= 18 AND Age &lt;= 23), // 约束 Age 的范围在 [18, 23] 之间 PRIMARY KEY (Sno, Cno),); 元组上的约束可以在元组层面上限制不同属性之间的取值以及相互约束关系。 123456789CREATE TABLE Student( Sno CHAR(9), Sname CHAR(8) NOT NULL, Ssex CHAR(2), Sage SMALLINT, Sdept CHAR(20), PRIMARY KEY (Sno), CHECK (Ssex='女' OR Sname NOT LIKE 'Ms.%') // 约束了学生性别为男时，其名字不能以 Ms. 开头); 完整性约束命名子句1CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt; &lt;完整性约束条件&gt; 包括 NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK 短语等。 123456789101112CREATE TABLE Student( Sno NUMERIC(6) CONSTRAINT C1 CHECK (Sno BETWEEN 90000 AND 99999), Sname CHAR(20) CONSTRAINT C2 NOT NULL, Sage NUMERIC(3) CONSTRAINT C3 CHECK (Sage &lt; 30), Ssex CHAR(2) CONSTRAINT C4 CHECK (Ssex IN ('男','女')), CONSTRAINT StudentKey PRIMARY KEY(Sno), CONSTRAINT SnameKey FOREIGN KEY(Sname) REFERENCES C(Sname));","link":"/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-chap2-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/"},{"title":"数据库系统笔记 - chap1 - 绪论","text":"数据库发展史人工管理阶段（1950） 文件系统阶段（1950-1960） 数据库系统阶段（1960-） 数据库管理系统（DBMS）的出现，使得数据存储、数据管理和数据应用分离。数据库管理系统采用外模式-模式-内模式的三级模式，外模式/模式和模式/内模式的两级映象结构。 数据模型定义：是数据及其联系在计算机中的表示和组织形式的描述。组成三要素：数据结构，数据操纵，数据完整性约束。经典模型：层次模型（有根树），网状模型（有向图），关系模型。","link":"/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-chap1-%E7%BB%AA%E8%AE%BA/"},{"title":"JavaScript学习笔记","text":"Brief Syntax Introduction JS 是解释型语言。 解释型语言 与 编译型语言： 解释型：一行一行看，容易出错但方便，可以及时方便地找到出错位置以及出错原因，容易跨平台（可以嵌入到其他软件）。编译型：把高级语言预先翻译成机器语言，并把结果保存下来，速度快（编译器优化），不易出错，但不能跨平台（e.g. .exe can’t be run in MacOS)。 行末分号非必需： JS 中的每一行都可以选择使用分号终止，即编译器会自动补全没有用分号的地方。 JS 中的变量是弱类型的，即变量的类型只有在被赋值的时候才得到确认。 数据类型与变量 const 用来申明常量（一旦声明后续值不可更改），let 用来申明变量（一个变量只能申明一次，值以及值的类型可以被多次更改）。 JS 中允许一个变量未被提前申明就使用。此时该变量会被自动被申明为全局变量。若在程序的最开始加上 use strict 语句，则可以避免这支双刃剑带来的弊端。（在 strict 模式下，变量必须要先经过申明，才能被使用，否则会报错） JS 中的基本类型有数字、字符串、布尔值、符号、null 和 undefined。数字中不区分整数和浮点数。 JS 中遇到计算除法时除数为 0 的情况时，不会报错，会根据被除数的值来返回对应的结果。若被除数是正数，则返回 Infinity ；若被除数是负数，则返回 -Infinity；若被除数是 0 ，则返回 NaN (Not a Number)。除以 0 的余数（1 % 0）为 NaN 。 与 python 类似， JS 中一个 * 代表相乘， ** 则代表幂运算。 JS 中 === 表示检查是否相等，!== 表示检查是否不等。 字符串 JS 中的字符串用 '' 或 \"\" 括起来表示。若想表达的字符串中本身含有 ' 或 \"，则需要用到转义字符。e.g. I'm \"OK\"! 的表示是： 1'I\\'m \\\"OK\\\"!'; 在 JS 中输出多行字符串的方式是用反引号。e.g. 1234`No \\nanymore`; 与 python 类似，要把多个字符串连接起来，可以用 + 号连接。也可以通过模版字符串的方式来方便输出过程。（反引号与 ${} 的结合） 12345let name = '小明';let age = 20;let message1 = '你好, ' + name + ', 你今年' + age + '岁了!';let message2 = `你好, ${name}, 你今年${age}岁了!`//message1 = message2 JS 中的字符串是不可变的，即不能通过 s[id] = 'A' 的方式来将 s 中 id 位置的字母改成 A 。 JS 中有很多类似 python 和 C++ STL 中的字符串函数，如 toUpperCase，indexOf（搜索元素在数据结构中出现的位置，未找到则返回 -1），substring 等。 数组 JS 中的数组可以包含任意数据类型，并通过索引来访问/修改每个元素。 123a = [1, 'hello, world', ['a', b, 100]];a[0] = 'qaq';a; // a = ['qaq', 'hello, world', ['a', b, 100]] 在 JS 中允许给数组的 length 赋一个新值。除此之外，假如进行了数组的越界访问，也不会报错。 12345678var arr = [1, 2, 3];arr.length = 6;arr; // arr 变为 [1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2]arr[4] = 'qaq';arr; // arr 变为 [1, 2, undefined, undefined, 'qaq'] 同 python 的切片类似，slice() 可以将一个数组的局部“拿出来”，变成一个新的数组。 12345var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']var aCopy = arr.slice();aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G'] 如果要在数组的头部添加若干元素，可以使用 unshift() ; shift() 则可以用来把数组的第一个元素删除。splice() 则可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素。 12345678var arr = [1, 2, 3, 4];arr.unshift('A', 'B'); // 返回Array新的长度: 6arr; // ['A', 'B', 1, 2, 3, 4]arr.shift(); // 'A'arr; // ['B', 1, 2, 3, 4]// 从索引 1 开始删除 3 个元素,然后再添加 2 个元素:arr.splice(1, 3, 'qaq', 222); // 返回删除的元素 [1, 2, 3]arr; // ['B', 4, 'qaq', 222] 如果要在数组的尾部添加/删除若干元素，可以使用 push() 和 pop()。 123456789var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] 对象在 JS 中，对象是一种无序的集合数据类型，由若干键值对组成。用法与 python 中的 dictionary 很像。但 JS 对象的键必须是字符串，值可以是任意数据类型。这一点和 dictionary 对键和值类型的无限制不同（ JS 中 Map 的引入解决了这个问题）。 12345678var xiaoming = { name: 'Yiling Zhang', birth: 2003, school: 'Xidian University', height: 1.77, weight: 65, score: 100}; 函数函数的定义与调用123456789101112function get_pow(x, y) { var res = 1, i; for (i = 1; i &lt;= y; i++) res = res * x; return res;}var get_pow = function (x, y) { var res = 1, i; for (i = 1; i &lt;= y; i++) res = res * x; return res;};//匿名函数，在 JS 中函数也可以作为变量，通过这个变量就可以调用该函数。 传入函数的多个变量以逗号分隔开。如果传入某个函数的变量的个数，比该函数预先设定的要多，程序仍然会返回正确的结果，且不会报错。如果要少，则不会报错，但是结果可能不正确。 在函数的内部，系统提供了关键字 arguments。该关键字只在函数内部起作用，通过该参数可以访问到传入该函数的所有参数。可以通过访问 arguments.length() 来获取到传入某个函数的参数的个数。 12345678910function abs() { if (arguments.length() == 0) return 0; else { var x = arguments[0]; return x &gt;= 0 ? x : -x; }}abs(); // 0abs(-2, 1); // 2 变量作用域与解构赋值局部作用域、块级作用域若在函数内部用 var 申明变量，则该变量的作用域是该函数内部，即这是一个局部变量。 在 JS 中允许函数的嵌套，即某个函数内可以定义另一个函数。同时允许内函数和外函数中定义重名的变量。 函数在查找变量时从自身函数定义开始，从内向外查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。 123456789use strict;function f() { var x = 1; function g() { var x = 2; x; // x = 2 } x; // x = 1} 在函数内部中用 var 申明一个变量，该变量会在整个函数中都起作用，不具有块级作用域。用 let 来申明则不会有这种问题，新申明的变量会具有块级作用域。 1234567891011function f() { var sum = 0; for (var i = 0; i &lt; 100; i++) sum += i; i++; // 仍然可以使用在上一个循环内定义的i}function f() { var sum = 0; for (let i = 0; i &lt; 100; i++) sum += i; i++; // SyntaxError （与在c++中的逻辑一样）} 请严格遵守在函数内部首先申明所有变量这一规则！否则会出一些奇奇怪怪的错误。 全局作用域不在任何函数内定义的变量就具有全局作用域。 JS 默认有一个全局对象window ，全局作用域的变量（变量、函数等）实际上被绑定到 window 的一个属性。 123var x = 1;alert(x); // 1alert(windows.x); // 1 解构赋值在 JS 中可以使用解构赋值，直接对多个变量同时赋值： 1234let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']];x; // 'hello'y; // 'JavaScript'z; // 'ES6' 12345678910111213var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school'};let {name, passport : id} = person; // 把passport属性赋值给变量id:name; // '小明'id; // 'G-12345678'// 注意: passport不是变量，而是为了让变量id获得passport属性:passport; // Uncaught ReferenceError: passport is not defined 解构赋值在很多时候可以大大简化代码。例如，交换两个变量 和 的值，可以这么写，不再需要临时变量： 12var x = 1, y = 2;[x, y] = [y, x] 快速获取当前页面的域名和路径： 1var {hostname : domain, pathname : path} = location; 如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个 Date 对象： 123456function buildDate({year, month, day, hour = 0, minute = 0, second = 0}) { return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);}buildDate({ year: 2017, month: 1, day: 1 }); // Sun Jan 01 2017 00:00:00 GMT+0800 (CST)// 传入的对象只需要year、month和day这三个属性 方法可以给对象绑定函数。绑定到对象上的函数叫 方法 ，其在内部使用了 this 关键字。 在方法内部， this 始终指向当前对象。 1234567891011var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; }};xiaoming.age; // function xiaoming.age()xiaoming.age(); // 今年调用是25,明年调用就变成26了 若不通过某个对象直接在函数里调用 this ，this 默认指向 windows 。在 strict 模式下，函数的 this 指向的是 undefined ，从而系统会报错提醒你这里的不规范写法。故要保证 this 指向正确，必须用 obj.xxx() 的形式调用，或者可以用一个变量首先捕获 this 。 12345678910111213'use strict';var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; }};var fn = xiaoming.age;fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined 12345678910111213141516'use strict';var xiaoming = { name: '小明', birth: 1990, age: function () { var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() { var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this } return getAgeFromBirth(); }};xiaoming.age(); // 25","link":"/2023/10/19/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"CSP认证复建记录（于2023.09停更）","text":"2021042.邻域均值通过题目限制得出 的范围，二维前缀和统计即可。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int n, L, r, cnt, a[700][700], sum[700][700];double ans, t;int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; L &gt;&gt; r &gt;&gt; t; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { cin &gt;&gt; a[i][j]; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i][j]; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { int ex = min(n, i + r), ey = min(n, j + r), sx = max(1, i - r), sy = max(1, j - r); ans = 1.0 * (sum[ex][ey] - sum[ex][sy - 1] - sum[sx - 1][ey] + sum[sx - 1][sy - 1]) / ((ex - sx + 1) * (ey - sy + 1)); if (ans &lt;= t) cnt++; } } cout &lt;&lt; cnt &lt;&lt; \"\\n\"; return 0;} 2021092.非零段划分提前记录下来每个值出现过的位置。依次增加 的值，每次找到 个数中等于 的值的位置能产生的贡献（和左右两边 的出现情况有关）。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;const int N = 5e5 + 5;const int M = 1e4 + 5;using namespace std;int n, ans, maxx, a[N];vector&lt;int&gt; f[M];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int cnt = 0; for (int i = 1; i &lt;= n; i++) { f[a[i]].push_back(i); if (a[i] == 0) { if (cnt &gt; 0) { ans++; cnt = 0; } } else cnt++; } if (cnt &gt; 0) ans++; maxx = max(maxx, ans); for (int i = 1; i &lt;= M - 5; i++) { for (auto pos : f[i]) { a[pos] = 0; if (pos == 1 &amp;&amp; a[pos + 1] == 0) ans--; else if (pos == n &amp;&amp; a[pos - 1] == 0) ans--; else { if (a[pos - 1] == 0 &amp;&amp; a[pos + 1] == 0) ans--; else if (a[pos - 1] != 0 &amp;&amp; a[pos + 1] != 0) ans++; } } maxx = max(maxx, ans); } cout &lt;&lt; maxx &lt;&lt; endl; return 0;} 2021122.序列查询新解不难发现 每 个增加 ，故可以按段来统计，注意边界情况的讨论。 2022032.出行计划由题意不难得到有效条件的区间，差分即可。注意双边不等式的左边可能会小于 ，可以通过整体平移的方式（或者和 取 max 的方法）。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;const int lim = 2e5 + 5;using namespace std;int n, m, k, t, c, x, d[lim &lt;&lt; 1];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; t &gt;&gt; c; d[(lim - 5) + t - c - k + 1]++; d[(lim - 5) + t - k + 1]--; } for (int i = 0; i &lt;= (lim - 5) &lt;&lt; 1; i++) d[i] += d[i - 1]; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; x; cout &lt;&lt; d[(lim - 5) + x] &lt;&lt; endl; } return 0;} 2022062.寻宝！大冒险！把大地图中每个为 的点记录下来，用相对坐标依次进行比对，统计即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#define mp make_pair#define fi first#define se secondconst int N = 100;using namespace std;int n, L, S, x, y, ans, b[N][N];vector&lt;pair&lt;int, int&gt; &gt; a, dir;map&lt;pair&lt;int, int&gt;, int&gt; mapp;bool check(pair&lt;int, int&gt; u, pair&lt;int, int&gt; v) { int dx = u.fi + S + 1, dy = u.se + S + 1; if (dx &gt; L + 1 || dy &gt; L + 1) return true; int x = u.fi + v.fi, y = u.se + v.se; return b[v.fi][v.se] ^ mapp[mp(x, y)];}int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; L &gt;&gt; S; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x &gt;&gt; y; mapp[mp(x, y)]++; a.push_back(mp(x, y)); } for (int i = 0; i &lt;= S; i++) { for (int j = 0; j &lt;= S; j++) { cin &gt;&gt; b[i][j]; } } for (int j = 0; j &lt;= S; j++) { for (int i = 0; i &lt; S / 2 + 1; i++) swap(b[i][j], b[S - i][j]); } for (int i = 0; i &lt;= S; i++) { for (int j = 0; j &lt;= S; j++) { if (i == 0 &amp;&amp; j == 0) continue; dir.push_back(mp(i, j)); } } for (auto now : a) { bool flag = true; for (auto dxy : dir) { if (check(now, dxy)) { flag = false; break; } } if (flag) ans++; } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 3.角色授权STL 无脑叠 log， 喜提 70pts. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;const int N = 1e5;using namespace std;int n, m, q, x, id, id1, id2, ido, idc, idr;string ch_name, opt, cls, rnm, name, uname, gname, opname, rcls, rname, ss;map&lt;string, int&gt; mapp, oplist, clslist, rnmlist, ulist, glist;map&lt;int, int&gt; spe1, spe2, ch_opt[N], ch_cls[N], ch_rnm[N], uright[N], gright[N];vector&lt;string&gt; ucon[N], gcon[N], ori[N]; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; while (n--) { cin &gt;&gt; ch_name; mapp[ch_name] = ++id; cin &gt;&gt; x; while (x--) { cin &gt;&gt; opt; if (!oplist[opt]) oplist[opt] = ++ido; ch_opt[id][oplist[opt]] = 1; if (opt == \"*\") spe1[id] = 1; } cin &gt;&gt; x; while (x--) { cin &gt;&gt; cls; if (!clslist[cls]) clslist[cls] = ++idc; ch_cls[id][clslist[cls]] = 1; if (cls == \"*\") spe2[id] = 1; } cin &gt;&gt; x; while (x--) { cin &gt;&gt; rnm; if (!rnmlist[rnm]) rnmlist[rnm] = ++idr; ch_rnm[id][rnmlist[rnm]] = 1; } } while (m--) { cin &gt;&gt; ch_name &gt;&gt; x; while (x--) { cin &gt;&gt; ss &gt;&gt; name; if (ss == \"u\") { if (!ulist[name]) ulist[name] = ++id1; uright[mapp[ch_name]][ulist[name]] = 1; ucon[ulist[name]].push_back(ch_name); } else { if (!glist[name]) glist[name] = ++id2; gright[mapp[ch_name]][glist[name]] = 1; gcon[glist[name]].push_back(ch_name); } } } while (q--) { cin &gt;&gt; uname &gt;&gt; x; if (!ulist[uname]) ulist[uname] = ++id1; while (x--) { cin &gt;&gt; gname; if (!glist[gname]) glist[gname] = ++id2; ori[ulist[uname]].push_back(gname); } bool flag = 0; cin &gt;&gt; opname &gt;&gt; rcls &gt;&gt; rname; for (auto ch_name : ucon[ulist[uname]]) { if (uright[mapp[ch_name]][ulist[uname]]) { if (ch_opt[mapp[ch_name]][oplist[opname]] || spe1[mapp[ch_name]]) { if (ch_cls[mapp[ch_name]][clslist[rcls]] || spe2[mapp[ch_name]]) { if (ch_rnm[mapp[ch_name]].empty() || ch_rnm[mapp[ch_name]][rnmlist[rname]]) { flag = 1; } } } } } if (flag == 0) { for (auto gname : ori[ulist[uname]]) { for (auto ch_name : gcon[glist[gname]]) { if (gright[mapp[ch_name]][glist[gname]]) { if (ch_opt[mapp[ch_name]][oplist[opname]] || spe1[mapp[ch_name]]) { if (ch_cls[mapp[ch_name]][clslist[rcls]] || spe2[mapp[ch_name]]) { if (ch_rnm[mapp[ch_name]].empty() || ch_rnm[mapp[ch_name]][rnmlist[rname]]) { flag = 1; } } } } } } } cout &lt;&lt; flag &lt;&lt; endl; ori[ulist[uname]].clear(); } return 0;} 2022092.何以包邮70pts 二进制枚举，100pts 完全背包。 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;const int lim = 3e5 + 5;using namespace std;int n, m, sum, a[50], f[lim];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; f[0] = 1; for (int i = 1; i &lt;= n; i++) { sum += a[i]; for (int j = lim - 5; j &gt;= a[i]; j--) f[j] |= f[j - a[i]]; } for (int i = m; i &lt;= sum; i++) { if (f[i]) { cout &lt;&lt; i &lt;&lt; endl; return 0; } } return 0;} 202212训练计划建正图反图分别跑一遍。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define mp make_pair#define fi first#define se secondconst int N = 5050;using namespace std;bool flag;int n, m, x, maxx, in[N], nin[N], ans[N], a[N];vector&lt;int&gt; g[N], ng[N];queue&lt;pair&lt;int, int&gt; &gt; q;void dfs(int x) { for (auto to : ng[x]) { ans[to] = min(ans[to], ans[x] - a[to]); dfs(to); }}int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; x; if (x) { g[x].push_back(i); in[i]++; ng[i].push_back(x); nin[x]++; } } for (int i = 1; i &lt;= m; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= m; i++) { if (in[i] == 0) q.push(mp(i, 1)); } while (!q.empty()) { auto now = q.front(); q.pop(); int u = now.fi, w = now.se; ans[u] = w; maxx = max(maxx, ans[u]); if (ans[u] + a[u] - 1 &gt; n) flag = 1; for (auto v : g[u]) { if (--in[v] == 0) q.push(mp(v, ans[u] + a[u])); } } for (int i = 1; i &lt;= m; i++) cout &lt;&lt; ans[i] &lt;&lt; (i == m ? \"\\n\" : \" \"); memset(ans, 0x3f, sizeof(ans)); if (!flag) { for (int i = 1; i &lt;= m; i++) { if (nin[i] == 0) q.push(mp(i, n - a[i] + 1)); } while (!q.empty()) { auto now = q.front(); q.pop(); ans[now.fi] = now.se; dfs(now.fi); } for (int i = 1; i &lt;= m; i++) cout &lt;&lt; ans[i] &lt;&lt; (i == m ? \"\\n\" : \" \"); } return 0;} 2023052.矩阵运算通过交换相乘的次序，化简时间复杂度。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;const int N = 10500;const int D = 25;using namespace std;int n, d, w[N], q[N][D], k[N][D], v[N][D], tk[D][N];long long kv[N][N], ans[N][D];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; d; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= d; j++) cin &gt;&gt; q[i][j]; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= d; j++) { cin &gt;&gt; k[i][j]; tk[j][i] = k[i][j]; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= d; j++) cin &gt;&gt; v[i][j]; } for (int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i]; //d * n * n * d for (int k = 1; k &lt;= n; k++) { for (int i = 1; i &lt;= d; i++) { for (int j = 1; j &lt;= d; j++) kv[i][j] += 1ll * tk[i][k] * v[k][j]; } } //n * d * d * d for (int k = 1; k &lt;= d; k++) { for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= d; j++) ans[i][j] += 1ll * q[i][k] * kv[k][j]; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= d; j++) ans[i][j] = 1ll * ans[i][j] * w[i]; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= d; j++) cout &lt;&lt; ans[i][j] &lt;&lt; (j == d ? \"\\n\" : \" \"); } return 0;} 2023092.坐标变换(其二)由于每次操作中的 伸缩倍数一样，即若单独考虑经过所有的伸缩操作后， 变成了 ， 不难得出 。同时发现逆时针旋转的操作的角度可以叠加，故用一个前缀积数组存伸缩操作，一个前缀和数组存旋转操作，最终依次直接计算即可。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define mp make_pair#define fi first#define se secondconst int N = 1e5 + 5;const int INF = 1 &lt;&lt; 30;using namespace std;int n, m, opt, i, j;double x, y, mul[N], sum[N];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; m; mul[0] = 1.0; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; opt &gt;&gt; x; if (opt == 1) { mul[i] = mul[i - 1] * x; sum[i] = sum[i - 1]; } else { mul[i] = mul[i - 1]; sum[i] = sum[i - 1] + x; } } while (m--) { cin &gt;&gt; i &gt;&gt; j &gt;&gt; x &gt;&gt; y; double nowk = mul[j] / mul[i - 1], nowth = sum[j] - sum[i - 1], ncos = cos(nowth), nsin = sin(nowth); printf(\"%lf %lf\\n\", nowk * (x * ncos - y * nsin), nowk * (x * nsin + y * ncos)); } return 0;}","link":"/2023/09/01/CSP%E8%AE%A4%E8%AF%81%E5%A4%8D%E5%BB%BA%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8E2023-09%E5%81%9C%E6%9B%B4%EF%BC%89/"},{"title":"2023寒假acm训练（5）","text":"A.Cleaning the PhoneLinkhttps://codeforces.com/contest/1475/problem/D Statement给定 个物品，每个物品均有两个属性 ，现在需要确定一个序列 ，使得在满足 的前提下 最小。若可以则输出对应的 。 Solution考虑到 的取值只有两种，结合“定一动一”的思想，我们可以将物品按照 分类后，分别按照 的大小倒序排序，枚举选前 个 的物品，二分求得满足前提的最小的需要选择的 的物品的个数，进行统计即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;typedef long long ll;const int INF = 1 &lt;&lt; 30;const int N = 2e5 + 5;using namespace std;int T, n, m, num[3], a[N], b[N], c[3][N];ll sum[3][N];bool check(int p1, int p2) { return sum[1][p1] + sum[2][p2] &gt;= m; }int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { ll tot = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; tot += a[i]; } for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; b[i]; c[b[i]][++num[b[i]]] = a[i]; } if (tot &lt; m) { cout &lt;&lt; \"-1\" &lt;&lt; \"\\n\"; num[1] = num[2] = 0; continue; } for (int i = 1; i &lt;= 2; i++) sort(c[i] + 1, c[i] + num[i] + 1, greater&lt;int&gt;()); for (int i = 1; i &lt;= 2; i++) { for (int j = 1; j &lt;= num[i]; j++) sum[i][j] = sum[i][j - 1] + c[i][j]; } int ans = INF; for (int i = 0; i &lt;= num[1]; i++) { int l = 0, r = num[2], pos = -1; while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if (check(i, mid)) { pos = mid; r = mid - 1; } else l = mid + 1; } if (pos != -1) ans = min(ans, i + 2 * pos); } cout &lt;&lt; ans &lt;&lt; \"\\n\"; num[1] = num[2] = 0; } return 0;} B.Unusual MatrixLinkhttps://codeforces.com/contest/1475/problem/F Statement给定两个 的 01 矩阵 ，定义一种操作：选择矩阵 的第 行或第 列，将这一行/这一列上的所有数字全部与 异或。询问是否在一定次数的操作后，可以使 。 Solution关键性质是：1.异或运算与次序无关2. 只有与 异或奇数次才会改变，故某一行或某一列最多需要使用该操作一次 结合以上两条性质，我们只需先考虑第一行的数字，找出需要异或的列；之后考虑第一列的数字，找出需要异或的行。最后判断 是否等于 即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;const int N = 1050;using namespace std;int T, n, a[N][N], b[N][N], flagi[N], flagj[N];char c[N][N], d[N][N];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { cin &gt;&gt; c[i][j]; a[i][j] = c[i][j] - '0'; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { cin &gt;&gt; d[i][j]; b[i][j] = d[i][j] - '0'; } } for (int j = 1; j &lt;= n; j++) flagj[j] |= (a[1][j] != b[1][j]); for (int i = 2; i &lt;= n; i++) { if (flagj[1]) flagi[i] |= ((a[i][1] ^ 1) != b[i][1]); else flagi[i] |= (a[i][1] != b[i][1]); } bool flag = false; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { a[i][j] = (flagi[i] + flagj[j] == 1) ? (a[i][j] ^ 1) : a[i][j]; if (a[i][j] != b[i][j]) { flag = true; break; } } if (flag) break; } flag ? cout &lt;&lt; \"No\" &lt;&lt; \"\\n\" : cout &lt;&lt; \"Yes\" &lt;&lt; \"\\n\"; memset(flagi, 0, sizeof(flagi)); memset(flagj, 0, sizeof(flagj)); } return 0;} C.SticksLinkhttps://codeforces.com/gym/103652/problem/K Statement给定 根火柴的长度，每根火柴只能使用一次，确定其最大能表示出多少个三角形，并输出方案。 Solution考虑状态压缩以及使用位运算来简化过程。用一个长度为 的二进制串，第 位表示第 根火柴是否被使用。则一个合法的三角形的状态，二进制表示下会有 个 。首先统计出所有可能的三角形的状态，之后判断这些状态是否互相不干扰。考虑枚举，假设两个不相同的三角形状态分别为 ，他们互不干扰的充要条件是 。若他们互不干扰，则可以保证答案至少为 。此时可以查询他们的补集是否出现且合法，若是则答案为 ，直接输出方案即可，同时记录下这个答案为 的方案。若否，考虑构造 的可能方案。枚举 的可能方案时，可以枚举哪 根火柴不用和 组的情况，再判断他们的补集是否出现过（剩下 组）。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;const int lim = 1 &lt;&lt; 14;using namespace std;int T, a[20], pii[lim];vector&lt;int&gt; f;void print(int now) { vector&lt;int&gt; out(5); out.clear(); for (int i = 0; i &lt; 12; i++) { if ((now &gt;&gt; i) &amp; 1) out.push_back(a[i]); } for (int i = 0; i &lt; out.size(); i++) { cout &lt;&lt; out[i]; if (i != out.size() - 1) cout &lt;&lt; \" \"; } cout &lt;&lt; endl;}void solve() { // 12! / (3! 3! 3! 3! 4!) = 15400 int ans = 0, one = 0, two = 0, st = (1 &lt;&lt; 12) - 1; f.clear(); memset(pii, 0, sizeof(pii)); for (int i = 0; i &lt; 12; i++) { for (int j = i + 1; j &lt; 12; j++) { for (int k = j + 1; k &lt; 12; k++) { if (a[i] + a[j] &gt; a[k] &amp;&amp; a[j] + a[k] &gt; a[i] &amp;&amp; a[i] + a[k] &gt; a[j]) { int sta = (1 &lt;&lt; i) | (1 &lt;&lt; j) | (1 &lt;&lt; k); f.push_back(sta); ans = 1; one = sta; } } } } for (auto s : f) { for (auto t : f) { if (!(s &amp; t)) { ans = 2; two = s | t; pii[s | t] = s; int op = st ^ (s | t); if (pii[op]) { cout &lt;&lt; \"4\" &lt;&lt; \"\\n\"; print(s); print(t); print(pii[op]); print(op ^ pii[op]); return ; } } } } for (int i = 0; i &lt; 12; i++) { for (int j = i + 1; j &lt; 12; j++) { for (int k = j + 1; k &lt; 12; k++) { int sta = (1 &lt;&lt; i) | (1 &lt;&lt; j) | (1 &lt;&lt; k); for (auto r : f) { if (r &amp; sta) continue; int tw = st ^ (sta | r); if (pii[tw]) { cout &lt;&lt; \"3\" &lt;&lt; \"\\n\"; print(r); print(pii[tw]); print(tw ^ pii[tw]); return ; } } } } } cout &lt;&lt; ans &lt;&lt; \"\\n\"; if (ans == 0) return ; else if (ans == 1) print(one); else print(pii[two]), print(two ^ pii[two]);}int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; for (int t = 1; t &lt;= T; t++) { for (int i = 0; i &lt; 12; i++) cin &gt;&gt; a[i]; cout &lt;&lt; \"Case #\" &lt;&lt; t &lt;&lt; \": \"; solve(); } return 0;}","link":"/2023/01/18/2023%E5%AF%92%E5%81%87acm%E8%AE%AD%E7%BB%83%EF%BC%885%EF%BC%89/"},{"title":"2023寒假acm训练（4）","text":"A.Factory BallsLinkhttps://codeforces.com/group/sg0CXKHVzz/contest/421181/problem/A Statement给出 个编号为 的点，初始每个点的颜色都为 。有 种装备，每种装备会遮住一些位置（不一定是连续区间）。每一个时刻可以进行如下操作之一：1.选择一种颜色 ，将所有没有被装备遮住的位置染上颜色 。2.选择一个没有装上的装备装上它。3.卸下一个装备。给出每个位置最后的颜色 ，询问是否能达到最终状态（并且没有装任何装备），若可以则输出最少步数。 Solution观察到数据范围后考虑搜索所有的状态，从中求得最小步数。 若枚举每个位置的所有颜色，总状态数将变成 ，过于庞大。不难发现其实不用关注每个区域的具体颜色，只用关心是否染上了最终状态的颜色即可。因此在 bfs 时记录两个二进制串，第一个串长度为 ，其第 位为 表示第 块的颜色是最终颜色，为 表示是其他颜色；第二个串长度为 ，其第 位为 表示第 种装备已被使用，为 表示未被使用。这样被枚举到的状态数则优化到了 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define mp make_pair#define fi first#define se secondconst int lim = 1 &lt;&lt; 12;const int N = 20;using namespace std;int n, k, m, x, t, a[N], f[lim][lim];bool vis[N];vector&lt;int&gt; eq[N];queue&lt;pair&lt;int, int&gt; &gt; q;void bfs(int state) { memset(f, 0x3f, sizeof(f)); f[state][0] = 0; q.push(mp(state, 0)); while (!q.empty()) { auto now = q.front(); q.pop(); int sta1 = now.fi, sta2 = now.se; memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= m; i++) { if ((sta2 &gt;&gt; (i - 1)) &amp; 1) { for (auto j : eq[i]) vis[j] = 1; } } for (int c = 1; c &lt;= k; c++) { int res1 = sta1; for (int p = 1; p &lt;= n; p++) { if (vis[p]) continue; if (a[p] == c) { res1 |= (1 &lt;&lt; (p - 1)); continue; } if ((res1 &gt;&gt; (p - 1)) &amp; 1) res1 ^= (1 &lt;&lt; (p - 1)); } if (f[res1][sta2] &gt; f[sta1][sta2] + 1) { f[res1][sta2] = f[sta1][sta2] + 1; q.push(mp(res1, sta2)); } } for (int i = 1; i &lt;= m; i++) { int res2 = sta2 ^ (1 &lt;&lt; (i - 1)); if (f[sta1][res2] &gt; f[sta1][sta2] + 1) { f[sta1][res2] = f[sta1][sta2] + 1; q.push(mp(sta1, res2)); } } }}int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; t; for (int j = 1; j &lt;= t; j++) { cin &gt;&gt; x; eq[i].push_back(x); } } int state = 0, fina = (1 &lt;&lt; n) - 1; for (int i = 1; i &lt;= n; i++) state |= (a[i] == 1) ? (1 &lt;&lt; (i - 1)) : 0; bfs(state); f[fina][0] == 0x3f3f3f3f ? cout &lt;&lt; \"-1\" &lt;&lt; \"\\n\" : cout &lt;&lt; f[fina][0] &lt;&lt; \"\\n\"; return 0;} B.Triple Sword StrikeLinkhttps://codeforces.com/gym/103855/problem/D Statement二维平面上有一些不重复的点 ，每个点上还有一个权值。每次你可以选择一条平行于 轴或者 轴的直线，选择后你将收获这条线穿过的点的权值的和，这些点在被第一次穿过后也将消失。你现在可以选择 条这样的直线，最大化你收获到的权值和。 Solution点的坐标不大，可以直接作为下标用来统计横坐标为 的点的集合和他们的和（纵坐标为 的同理）。对 条直线分类讨论：三横、三竖、两横一竖、两竖一横。前两种情况直接选择和前三大的即可，后面两种情况可以枚举哪条线上的点被算重，查找删除更新，在 multiset 中维护即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;typedef long long ll;const int N = 3e6 + 5;const int lim = 1e6;using namespace std;multiset&lt;ll, greater&lt;ll&gt; &gt; sx, sy;vector&lt;int&gt; xx[lim + 5], yy[lim + 5];int n, x[N], y[N], v[N];ll val_x[lim + 5], val_y[lim + 5];void solve1(ll &amp;ans) { for (int i = 0; i &lt;= lim; i++) if (val_x[i]) sx.insert(val_x[i]); int num1 = 0; ll res1 = 0; for (auto c : sx) { ++num1; res1 += c; if (num1 == 3) break; } ans = max(ans, res1); for (int i = 0; i &lt;= lim; i++) if (val_y[i]) sy.insert(val_y[i]); int num2 = 0; ll res2 = 0; for (auto c : sy) { ++num2; res2 += c; if (num2 == 3) break; } ans = max(ans, res2);}void solve2(ll &amp;ans) { for (int i = 0; i &lt;= lim; i++) { if (!xx[i].size()) continue; ll sum1 = val_x[i]; for (auto tar : xx[i]) { auto it = sy.find(val_y[y[tar]]); sy.erase(it); val_y[y[tar]] -= v[tar]; sy.insert(val_y[y[tar]]); } int num2 = 0; for (auto c : sy) { ++num2; sum1 += c; if (num2 == 2) break; } ans = max(ans, sum1); for (auto tar : xx[i]) { auto it = sy.find(val_y[y[tar]]); sy.erase(it); val_y[y[tar]] += v[tar]; sy.insert(val_y[y[tar]]); } } for (int i = 0; i &lt;= lim; i++) { if (!yy[i].size()) continue; ll sum2 = val_y[i]; for (auto tar : yy[i]) { auto it = sx.find(val_x[x[tar]]); sx.erase(it); val_x[x[tar]] -= v[tar]; sx.insert(val_x[x[tar]]); } int num1 = 0; for (auto c : sx) { ++num1; sum2 += c; if (num1 == 2) break; } ans = max(ans, sum2); for (auto tar : yy[i]) { auto it = sx.find(val_x[x[tar]]); sx.erase(it); val_x[x[tar]] += v[tar]; sx.insert(val_x[x[tar]]); } }}int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; v[i]; xx[x[i]].push_back(i); val_x[x[i]] += v[i]; yy[y[i]].push_back(i); val_y[y[i]] += v[i]; } ll ans = 0; solve1(ans); solve2(ans); cout &lt;&lt; ans &lt;&lt; \"\\n\"; return 0;} C.Short QuestionLink给定 以及 和 ，计算下式的值： \\sum_{i = 1} ^ {n} \\sum_{j = 1} ^ n min(|p_i - p_j|, |q_i - q_j|)Solution带有min以及max这类的式子难以求值，考虑将其拆开。一个显然且重要的结论是 ，利用该式子可以化简： min(|p_i - p_j|, |q_i - q_j|) = \\\\ |p_i - p_j| + |q_i - q_j| - max(|p_i - p_j|, |q_i - q_j|)若将 看作二维平面上的点的坐标，上式可以等效为求二维平面上所有点对之间的 曼哈顿距离 减去 切比雪夫距离 的和。 曼哈顿距离与切比雪夫距离的转换问题比较常见，不再赘述。常用的 tips 是： —-&gt; ，此时原坐标系中的曼哈顿距离 = 新坐标系中的切比雪夫距离。 —-&gt; ，此时原坐标系中的切比雪夫距离 = 新坐标系中的曼哈顿距离。 因此上式中的切比雪夫距离部分可以也可以转换为求曼哈顿距离中 sigma 绝对值的形式来计算。 考虑如何算 ：由于 独立，可以把 进行升序排序，这样可以省去绝对值的运算。具体而言， 始终大于前 个的 ，贡献为正，且始终小于后 个的 ，贡献为负。因此： \\sum _{i = 1} ^ n \\sum _{j = 1} ^ n |p_i - p_j| = 2 \\cdot \\sum _{i = 1} ^ n ((i - 1) - (n - i)) \\cdot p_i对以上绝对值分别求值后相加即可。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;const int N = 1e6 + 5;using namespace std;int n, p[N], q[N], np[N], nq[N];long long ans1, ans2;int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i]; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; q[i]; for (int i = 1; i &lt;= n; i++) { np[i] = (p[i] + q[i]); nq[i] = (p[i] - q[i]); } sort (p + 1, p + n + 1); sort (q + 1, q + n + 1); sort (np + 1, np + n + 1); sort (nq + 1, nq + n + 1); for (int i = 1; i &lt;= n; i++) ans1 += 1ll * ((i - 1) - (n - i)) * p[i]; for (int i = 1; i &lt;= n; i++) ans1 += 1ll * ((i - 1) - (n - i)) * q[i]; for (int i = 1; i &lt;= n; i++) ans2 += 1ll * ((i - 1) - (n - i)) * np[i]; for (int i = 1; i &lt;= n; i++) ans2 += 1ll * ((i - 1) - (n - i)) * nq[i]; cout &lt;&lt; 2 * ans1 - ans2 &lt;&lt; endl; return 0;}","link":"/2023/01/16/2023%E5%AF%92%E5%81%87acm%E8%AE%AD%E7%BB%83%EF%BC%884%EF%BC%89/"},{"title":"2023寒假acm训练（3）","text":"A.Fill The BagLinkhttps://codeforces.com/contest/1303/problem/D Statement给定一个正整数 和 个数 ，保证所有 都是 的整数次幂。询问是否存在一个长度为 的序列 ，使得： \\sum _ {i = 1} ^ {m} \\frac {a_i}{2 ^ {x_i}} = n且 最小。若存在则输出 。 Solution由于 是 的整数次幂，则 则可以看作是 的二进制表示。原问题可以转化为：是否可以通过已有的一些个 的整数次幂，“凑”出 的二进制表示。 大的数只能往小变，小的数可以拼凑成大的数。且由于要最小化 div次数，我们可以按位从低到高考虑。假设当前即将考虑第 位，我们可以先试着用 位的来凑第 位的。若凑不出来，那就用 后面的有的最小的来凑 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;typedef long long ll;const int N = 1e5 + 5;using namespace std;int T, m, a[N];ll n, cnt[100];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { cin &gt;&gt; n &gt;&gt; m; ll sum = 0; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; a[i]; sum += a[i]; int ex = log2(a[i]); cnt[ex]++; } if (sum &lt; n) cout &lt;&lt; \"-1\" &lt;&lt; endl; else { ll ans = 0; for (int i = 0; i &lt; 60; i++) { if ((n &gt;&gt; i) &amp; 1) { int pos = i; while (!cnt[pos]) ++pos; --cnt[pos]; while (pos &gt; i) { --pos; cnt[pos]++; ++ans; } } cnt[i + 1] += cnt[i] / 2; } cout &lt;&lt; ans &lt;&lt; endl; } memset(cnt, 0, sizeof(cnt)); } return 0;} B.Obtain The StringLinkhttps://codeforces.com/contest/1295/problem/C Statement给定两个字符串 与 ，令 为空串。定义一种操作：每次可以选择 的一个字串 （非连续也可以），并把 加入 的末尾。询问是否能使 ，若可以输出最小的操作次数。 Solution定义 表示 中从 第 位开始的后缀串中字母 出现的最早位置。 从后往前扫一遍即可得到这个 。结合贪心的思想，每一次新的操作从第一位往后跳即可，跳到末尾则进行下一次操作。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;const int INF = 1 &lt;&lt; 30;const int N = 2e5 + 5;using namespace std;int T, g[N][30];char s[N], t[N];set&lt;char&gt; ss;int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { cin &gt;&gt; (s + 1) &gt;&gt; (t + 1); int lens = strlen(s + 1), lent = strlen(t + 1); for (int i = 1; i &lt;= lens; i++) ss.insert(s[i]); bool flag = false; for (int i = 1; i &lt;= lent; i++) { if (!ss.count(t[i])) { flag = true; break; } } ss.clear(); if (flag) cout &lt;&lt; \"-1\" &lt;&lt; endl; else { for (int j = 1; j &lt;= 26; j++) g[lens + 1][j] = INF; for (int i = lens; i &gt;= 1; i--) { for (int j = 1; j &lt;= 26; j++) g[i][j] = g[i + 1][j]; g[i][s[i] - 'a' + 1] = i; } int pos = 1, now = 1, cnt = 0; bool sign = false; while (now &lt;= lent) { if (g[pos][t[now] - 'a' + 1] == INF) { cnt++; pos = 1; sign = false; } else pos = g[pos][t[now] - 'a' + 1] + 1, now++, sign = true; if (pos == lens + 1) { cnt++; pos = 1; sign = false; } } if (sign) cnt++; cout &lt;&lt; cnt &lt;&lt; endl; } } return 0;}","link":"/2023/01/14/2023%E5%AF%92%E5%81%87acm%E8%AE%AD%E7%BB%83%EF%BC%883%EF%BC%89/"},{"title":"2023寒假acm训练（2）","text":"A.Odd DivisorLinkhttps://codeforces.com/contest/1475/problem/A Statement给定一个正整数 ，判断其是否至少有一个大于 的奇因子。 Solution若 为奇数，那 本身就是一个符合条件的奇因子。 考虑偶数的情况：偶数可以由两个偶数相乘得到，也可以通过一奇一偶相乘得到。能被表示成 的 次幂的 只会属于第一种情况，其他则可以表示为第二种。判断 是否为 的 次幂有两种方法：(1) 看 是否为 。（2）不断除 直至最后变成 ，途中不出现奇质因子。 B.Advertising AgencyLinkhttps://codeforces.com/contest/1475/problem/E Statement给定 个数，从中选 个，要求 最大，求方案数。 Solution由于 最大且固定，那么所有方案本质上都是相同的。（反证法：将 按降序排序，若存在 使得方案更优，说明 , 那其必定排在前 大，与已知条件矛盾）。 故答案取决于前 大的数中，最小的那个数 的个数。令 表示 个数中 出现的次数， 表示前 大的数中严格大于 的个数，易得答案为 。 Code12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;const int lim = 1000;const int mod = 1e9 + 7;using namespace std;int T, n, k, a[lim + 5], c[lim + 5][lim + 5];void init() { c[0][0] = 1; for (int i = 1; i &lt;= lim; i++) { c[i][0] = 1; for (int j = 1; j &lt;= i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod; }}int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; init(); while (T--) { cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; sort(a + 1, a + n + 1, greater&lt;int&gt;()); int cnt1 = 0, cnt2 = 0, minn = a[k]; for (int i = 1; i &lt;= n; i++) { cnt1 += (a[i] == minn); cnt2 += (a[i] &gt; minn); } cout &lt;&lt; c[cnt1][k - cnt2] &lt;&lt; \"\\n\"; } return 0;} C.Perfect KeyboardLinkhttps://codeforces.com/contest/1303/problem/C Statement给定一个仅包含小写字母且相邻字母不一样的字符串 ，将 abcdefg...xyz 重排，重排后的字符串为 ，询问是否能使得 中相邻的字母在 中也全部相邻，若可以则输出方案。 Solution将 中相邻的字母进行连边（始终保证由字典序小的连接字典序大的），不难发现若出现度数大于 的节点或有环出现时，则答案不存在。否则可以从度数为 的点出发，对树进行深度优先遍历并记录路径，得到的答案序列则是符合条件的。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;const int N = 50;using namespace std;string s;int T, deg[N];bool vis[N], g[N][N];void dfs(int x, string &amp;ans) { vis[x] = 1; ans += (char)('a' + x - 1); for (int i = 1; i &lt;= 26; i++) { if ((!g[x][i]) || (vis[i])) continue; dfs(i, ans); }}int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { cin &gt;&gt; s; if ((int)s.length() == 1) { cout &lt;&lt; \"YES\" &lt;&lt; endl; for (char c = 'a'; c &lt;= 'z'; c++) cout &lt;&lt; c; cout &lt;&lt; endl; continue; } for (int i = 0; i &lt; (int)s.length() - 1; i++) g[s[i] - 'a' + 1][s[i + 1] - 'a' + 1] = g[s[i + 1] - 'a' + 1][s[i] - 'a' + 1] = 1; for (int i = 1; i &lt;= 26; i++) { for (int j = i + 1; j &lt;= 26; j++) { if (g[i][j]) { deg[i]++; deg[j]++; } } } bool flag = 0; for (int i = 1; i &lt;= 26; i++) flag |= (deg[i] &gt; 2); string ans = \"\"; bool sign = 0; for (int i = 1; i &lt;= 26; i++) { if (deg[i] == 1 &amp;&amp; (!vis[i])) { sign = true; dfs(i, ans); } } if (flag || (!sign)) cout &lt;&lt; \"NO\" &lt;&lt; endl; else { cout &lt;&lt; \"YES\" &lt;&lt; endl; for (char c = 'a'; c &lt;= 'z'; c++) { if (!vis[c - 'a' + 1]) ans += c; } cout &lt;&lt; ans &lt;&lt; endl; } memset(g, 0, sizeof(g)); memset(deg, 0, sizeof(deg)); memset(vis, 0, sizeof(vis)); } return 0;}","link":"/2023/01/14/2023%E5%AF%92%E5%81%87acm%E8%AE%AD%E7%BB%83%EF%BC%882%EF%BC%89/"},{"title":"2023寒假acm训练（1）","text":"A.Yet Another TournamentLinkhttps://codeforces.com/contest/1783/problem/C Statement除了你以外有 个人，编号为 ，每个人有两个权值 和 ，其中 ， 给定。现在你要同这 个人依据 的大小来排名（ 越大排名越靠前，你的排名等于 严格大于你的人的个数）。 你的 的大小等于 ，且需要满足 (在 个人中选 个人，他们的 的和不大于一个给定的数 ，此时的 就作为你的 的值)。 最小化你的最终排名。 Solution假设你最终赢了 个人。不难发现 和 的人，无论你是否选择了他们，他们都不会影响你的最终排名。所以只有 的人会影响你的最终排名。那我们只需先最大化自己赢的人的个数，最终判断能否选第 个人即可。 Code123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int T, n, m;int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n); for (auto &amp;x : a) cin &gt;&gt; x; auto b = a; sort(b.begin(), b.end()); int sum = 0, cnt = 0; for (auto x : b) { if (x + sum &gt; m) break; sum += x; ++cnt; } if (cnt == 0) cout &lt;&lt; n + 1 &lt;&lt; endl; else if (cnt == n) cout &lt;&lt; 1 &lt;&lt; endl; else (sum + a[cnt] - b[cnt - 1] &lt;= m) ? cout &lt;&lt; n - cnt &lt;&lt; endl : cout &lt;&lt; n - cnt + 1 &lt;&lt; endl; } return 0;} B.Consonant FencityLinkhttps://codeforces.com/gym/101612/attachments/download/6287/20172018-acmicpc-neerc-northern-subregional-contest-en.pdf Statement定义以下集合： U = \\{ 'a' \\to 'z' \\} \\\\ S = \\{ 'a', 'e', 'i', 'o', 'u', 'w', 'y' \\} \\\\ T = \\{ c \\ | \\ c \\in U, c \\notin S \\}给定字符串 , 函数 等于「 中相邻字母均是 中的元素且大小写形式互不相同」的相邻对数。现在你可以改变任意字母在 中出现的大小写形式，但 中不同位置的本质相同的字母的形式均要相同，修改过后最终的字符串称作 。最大化 并输出 。 Solution考虑到 ，因此可以用一个二进制串来表示每一位（ 中每一种字母）的大小写形式， 表示大小，.） 提前统计好 中出现过的 “ 元素对” 的个数，按题意统计即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;const int N = 100;const char a[] = {'a', 'e', 'i', 'o', 'u', 'w', 'y'};const char b[] = {'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'x', 'z'};using namespace std;string s;bool con[N], vis[N];int num[N][N];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"consonant.in\", \"r\", stdin); freopen(\"consonant.out\", \"w\", stdout); cin &gt;&gt; s; for (int i = 0; i &lt; 7; i++) con[a[i] - 'a'] = true; for (int i = 0; i &lt; s.length() - 1; i++) { if (!(con[s[i] - 'a'] &amp; con[s[i + 1] - 'a'])) { num[s[i] - 'a'][s[i + 1] - 'a']++; num[s[i + 1] - 'a'][s[i] - 'a']++; } } int ans = 0, maxx = 0; for (int sta = 0; sta &lt; (1 &lt;&lt; 19); sta++) { int res = 0; for (int i = 0; i &lt; 19; i++) { if ((sta &gt;&gt; i) &amp; 1) { for (int j = 0; j &lt; 19; j++) { if (!((sta &gt;&gt; j) &amp; 1)) res += num[b[i] - 'a'][b[j] - 'a']; } } } if (res &gt; maxx) { maxx = res; ans = sta; } } for (int i = 0; i &lt; 19; i++) vis[b[i] - 'a'] = ((ans &gt;&gt; i) &amp; 1); for (int i = 0; i &lt; s.length(); i++) vis[s[i] - 'a'] ? cout &lt;&lt; (char)toupper(s[i]) : cout &lt;&lt; s[i]; return 0;} C.Intelligence in PerpendiculariaLinkhttps://codeforces.com/gym/101612/attachments/download/6287/20172018-acmicpc-neerc-northern-subregional-contest-en.pdf Statement在一个平面直角坐标系中 描绘一个封闭图形，该图形的每条边均与 轴或 轴平行，现在沿 轴正、负方向， 轴正、负方向（四个方向）“发射阳光”，问“照不到阳光”的线段的总长度。 上图中答案为 6。 Solution由于坐标的范围不大，因此可以使用坐标的值当作下标，记录每个 或 经过的次数，不难发现只有经过次数大于 的线段才“照不到阳光”，且可以随着经过次数的增大被重复统计。 整个过程用差分的思想即可，即分别对 和 进行差分，最终统计累加即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;const int lim = 1e6 + 1;typedef long long ll;using namespace std;int n, x[lim + 5], y[lim + 5];ll dx[2 * lim + 5], dy[2 * lim + 5];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"intel.in\", \"r\", stdin); freopen(\"intel.out\", \"w\", stdout); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x[i] &gt;&gt; y[i]; x[i] += lim; y[i] += lim; } x[n + 1] = x[1], y[n + 1] = y[1]; for (int i = 2; i &lt;= n + 1; i++) { if (x[i] == x[i - 1]) { int sy = min(y[i], y[i - 1]), ey = max(y[i], y[i - 1]); dy[sy]++; dy[ey]--; } else { int sx = min(x[i], x[i - 1]), ex = max(x[i], x[i - 1]); dx[sx]++; dx[ex]--; } } ll ans = 0; for (int i = 1; i &lt;= lim * 2 - 1; i++) { dx[i] += dx[i - 1]; dy[i] += dy[i - 1]; ans += max(0ll, dx[i] - 2); ans += max(0ll, dy[i] - 2); } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2023/01/10/2023%E5%AF%92%E5%81%87acm%E8%AE%AD%E7%BB%83%EF%BC%881%EF%BC%89/"},{"title":"Atcoder Beginner Contest 284","text":"A.Happy New Year 2023Linkhttps://atcoder.jp/contests/abc284/tasks/abc284_d Statement将给定的 分解成 的形式，其中 为两个不相同的质数 。 Solution由于 很大，可以使用时间复杂度较优的 Pollard’s rho 算法。 也可以观察到，是 级别的。因此我们可以枚举这个值 ，判断它是否可以作为 或 。 可以作为 的条件是 ，可以作为 的条件是 且 是完全平方数。 Code1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int T;ll n;bool issquare(ll x) { return (ll)sqrt(x) == sqrt(x); }int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { cin &gt;&gt; n; for (ll i = 2; i * i * i &lt;= n; i++) { if (n % i == 0 &amp;&amp; issquare(n / i)) { cout &lt;&lt; (ll)sqrt(n / i) &lt;&lt; \" \" &lt;&lt; i &lt;&lt; endl; break; } if (n % (i * i) == 0) { cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; n / i / i &lt;&lt; endl; break; } } } return 0;} B.Count Simple PathsLinkhttps://atcoder.jp/contests/abc284/tasks/abc284_e Statement给定一个 个点 条边的无向图，保证每个点的度数在 以内，求出从 号节点为起点的所有简单路径的个数。（若个数大于 则输出 ）。 Solution朴素想法是直接对图进行dfs遍历。关键点是题目中对于度数的限制。有了这个限制，可以保证“在搜索的过程中不会因为进入一个不优的节点而需要耗费相当多的代价再走回来”。因此时间复杂度是正确的。 C.ABCBACLinkhttps://atcoder.jp/contests/abc284/tasks/abc284_f Statement对于一个长度为 的字符串 ，通过 构造出一个长度为 的字符串 。 ： 的前 个字母 + 的倒序字符串 + 的后 个字母。 现给出 和 ，询问是否能得到一组可行的 和 。有解则输出方案。 Solution枚举 ，同时结合字符串双哈希即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define fi first#define se second#define mp make_pairconst int N = 2e6 + 5;typedef long long ll;using namespace std;int n;string t;//Double Hash Modeltypedef pair&lt;int, int&gt; Hash;const ll mod1 = 1e9 + 7;const ll mod2 = 1e9 + 9;Hash operator + (Hash a, Hash b) { int c1 = a.fi + b.fi, c2 = a.se + b.se; if (c1 &gt;= mod1) c1 -= mod1; if (c2 &gt;= mod2) c2 -= mod2; return mp(c1, c2);}Hash operator - (Hash a, Hash b) { int c1 = a.fi - b.fi, c2 = a.se - b.se; if (c1 &lt; 0) c1 += mod1; if (c2 &lt; 0) c2 += mod2; return mp(c1, c2);}Hash operator * (Hash a, Hash b) { int c1 = 1ll * a.fi * b.fi % mod1, c2 = 1ll * a.se * b.se % mod2; return mp(c1, c2);}Hash pw[N], pre[N], suf[N];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; t; n *= 2; Hash base = mp(13331, 23333); pw[0] = mp(1, 1); for (int i = 1; i &lt;= n; i++) { pw[i] = pw[i - 1] * base; pre[i] = pre[i - 1] * base + mp(t[i - 1], t[i - 1]); } for (int i = n; i &gt;= 1; i--) suf[i] = suf[i + 1] * base + mp(t[i - 1], t[i - 1]); for (int i = 0; i &lt;= n / 2; i++) { Hash res1 = (pre[i] * pw[n / 2 - i]) + (pre[n] - pre[i + n / 2] * pw[n / 2 - i]); Hash res2 = suf[i + 1] - suf[i + 1 + n / 2] * pw[n / 2]; if (res1 == res2) { cout &lt;&lt; t.substr(0, i) + t.substr(i + n / 2, n - i) &lt;&lt; endl; cout &lt;&lt; i &lt;&lt; endl; return 0; } } cout &lt;&lt; \"-1\" &lt;&lt; endl; return 0;}","link":"/2023/01/08/Atcoder%20Beginner%20Contest%20284/"},{"title":"Codeforces Round 842(Div.2)","text":"A.Greatest ConvexLinkhttps://codeforces.com/contest/1768/problem/A Description求出最大的 ，使得 是 的倍数。 Solution x! + (x - 1)! = (x + 1) \\cdot (x - 1)!当 时，，该值始终为 的倍数。故输出 即可。 Codehttps://codeforces.com/contest/1768/submission/188069238 B.Quick SortLinkhttps://codeforces.com/contest/1768/problem/B Description定义一种操作：对一个长度为 的排列，每次可以从排列中任意选出 个数（将这些数从原排列中删除），将他们按升序排列后加到原排列末尾。最小化使得这个长度为 的排列整体升序的操作次数。 Solution需要发现，以 为开头的、连续的上升序列，这些数字是不用选中的，其余的都需要选。直接计算 即可。 Code12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;const int N = 2e5 + 5;using namespace std;int T, n, m, a[N];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { int cnt = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int now = 1; for (int i = 1; i &lt;= n; i++) { if (a[i] == now) now++; } cout &lt;&lt; (n - now + 1 + m - 1) / m &lt;&lt; endl; } return 0;} C. Elemental DecompressLinkhttps://codeforces.com/contest/1768/problem/C Description给定一个序列 ，询问是否存在两个长度为 的排列 ，使得 。若存在，需输出方案。 Solution出现以下任意一种情况都是无解的：中未出现过、中的出现次数大于、中任意一个数字的出现次数大于。 确定有解后，先把那些一定要填的数字填好，剩余数字结合贪心思路，每次能往大里填（结合_即可）。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;const int N = 2e5 + 5;using namespace std;int T, n, cnt[N], a[N], ans1[N], ans2[N];bool vis1[N], vis2[N];vector&lt;int&gt; fi, se;int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { bool flag = false; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cnt[i] = 0; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; cnt[a[i]]++; if (cnt[a[i]] &gt; 2) flag = true; } flag |= (cnt[1] == 2); flag |= (!cnt[n]); if (flag) cout &lt;&lt; \"NO\" &lt;&lt; endl; else { fi.clear(); se.clear(); for (int i = 1; i &lt;= n; i++) { vis1[i] = vis2[i] = false; ans1[i] = ans2[i] = 0; } for (int i = 1; i &lt;= n; i++) { if (!vis1[a[i]]) { vis1[a[i]] = true; ans1[i] = a[i]; } else { ans2[i] = a[i]; vis2[a[i]] = true; } if (a[i] == 1) { vis1[1] = vis2[1] = true; ans1[i] = ans2[i] = 1; } } for (int i = n; i &gt;= 1; i--) { if (!vis1[i]) se.push_back(i); if (!vis2[i]) fi.push_back(i); } for (int i = 1; i &lt;= n; i++) { if (!ans1[i]) { auto it = lower_bound(se.begin(), se.end(), ans2[i], greater&lt;int&gt;()); if (it == se.end()) { flag = true; break; } ans1[i] = se[it - se.begin()]; se.erase(it); } } for (int i = 1; i &lt;= n; i++) { if (!ans2[i]) { auto it = lower_bound(fi.begin(), fi.end(), ans1[i], greater&lt;int&gt;()); if (it == fi.end()) { flag = true; break; } ans2[i] = fi[it - fi.begin()]; fi.erase(it); } } if (flag) cout &lt;&lt; \"NO\" &lt;&lt; endl; else { cout &lt;&lt; \"YES\" &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; ans1[i]; i == n ? cout &lt;&lt; endl : cout &lt;&lt; \" \"; } for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; ans2[i]; i == n ? cout &lt;&lt; endl : cout &lt;&lt; \" \"; } } } } return 0;} D.Lucky PermutationLinkhttps://codeforces.com/contest/1768/problem/D Description定义一种操作：对一个长度为 的排列 ，每次可以从排列中选出 和 ，交换 与 。最小化使得最终的 有且仅有一个逆序对的操作次数。 Solution对于每个 ，若考虑从 到 连一条有向边，根据排列的性质（每个点的入度和出度都为 ），则会生成 个环 。 不难发现，最终状态一定是「一个升序排列，且选择一对相邻的数交换后」的形式。若按之前的图的形式表示，则可以表示为 个自环 + 个长度为 的环（且这个长度为 的环，是由两个相邻的数字构成的）。 对于原排列表示出的 个环，自环可以不管，大环则需要被拆解成小环和自环。当交换两个数有效时，可以等效为「大环变小，且新增自环」。若存在一个大环其中包含两个相邻的数，那么意味着在拆解的过程中，可以把他们俩留下，其他变为自环。否则在所有大环拆成自环后，还需要选择两个相邻的自环，将他们变成长度为 的环。 利用并查集可以找出环的个数后，再在每个环中判断，是否存在相邻元素。若存在则答案 ，不存在则答案 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;const int N = 2e5 + 5;using namespace std;int T, n, x, fa[N];set&lt;int&gt; s, son[N];int get_fa(int x) { return x == fa[x] ? x : fa[x] = get_fa(fa[x]); }int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; T; while (T--) { bool flag = false; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) fa[i] = i; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x; int fx = get_fa(i), fy = get_fa(x); fa[fy] = fx; } for (int i = 1; i &lt;= n; i++) { int x = fa[i]; while (x != fa[x]) x = fa[x]; s.insert(x); son[x].insert(i); } for (int i = 1; i &lt;= n; i++) { int last = -1; for (auto x : son[i]) { if (last != -1 &amp;&amp; x - last == 1) { flag = true; break; } last = x; } if (flag) break; } cout &lt;&lt; n - (int)s.size() + (!flag ? 1 : -1) &lt;&lt; endl; s.clear(); for (int i = 1; i &lt;= n; i++) son[i].clear(); } return 0;}","link":"/2023/01/07/Codeforces%20Round%20842(Div.2)/"},{"title":"Codeforces Round 833 (div.2)","text":"B.Diverse SubstringsstatementFind the number of substrings of consists of only that satisfies max{alpha occurrences} s.size( ). solutionThe most significant point is the length of s will not exceed 10*10 = 100. So it’s available to let be the start position and check answer in next numbers and break when the condition fails to satisfy. code linkhttps://codeforces.com/contest/1748/submission/180703499 C.Zero-Sum PrefixesstatementGiven an array consists of integers in range of , in every operation you can choose a position that , and change to an arbitrary integer. Maxizize the number of that satisfies: (\\sum_{j = 1}^{x}a_j) = 0solutionNotice that every two is independent, which means every time you’re going to change the value of , you only need to consider how the new value will influence the number who’s index is between . So in every operation you only need to maximize present answer, thus we take strategy like finding out the most occurances prefix sum between , and add it to the final result. code linkhttps://codeforces.com/contest/1748/submission/180705816 D.ConstructORstatementGiven integer , find any possible that satisfies: d \\mod a | x = 0 \\\\ d \\mod b | x = 0solutionGiven the features of bitwise OR operation, we can simplify the description of the question as find a x which not only is a multiple of d but also x mod a|b = 0.In other words, is constructed by in binary and the binary form of is a subset of .So we can try to construct the in binary form from low position to high position. When the - value is in , we can add a multiple using ‘&lt;&lt;’ operation that can guarantee the value in current position is same as .","link":"/2022/11/18/Codeforces%20Round%20833(div.2)/"},{"title":"无论怎样，2021，再见了","text":"去年也大抵是这个时候，我说：“几个月没更新博客了，好久没一个人坐下来写点东西了。” 不知不觉，一年过去了，我好像还是没有养成经常写点东西的习惯。若问我原因，我可能还是会以“太忙了”、“变化总比计划快”来搪塞过去。 若我未来每年都会继续写年终总结的话，我可能每次都会和上一年一样，说“这一年是不平凡的一年”。随着时间的推移，老旧的记忆带给人的各方面的影响程度会慢慢褪色，每一年经历的事、遇见的人都不一样，然后人就会将一些有一定触动程度的事情定义为“不平凡”。 说2021的话，首先不得不提的事是高考。我不是很想去回忆备考的那几个月，不想试图从里面找到些什么值得感慨的。回忆那几个月，会让我不可避免的把这件事的结果与过程中的期望做对比，会不可避免的让我去想“如果怎么怎么样就怎么怎么样”之类的无意义的东西。“走好眼前的路，欣赏沿途的风景，不在意结果”是我从高考里面学到的。结果出来的那天，我承认我是悲伤的，不甘的，心想“去你*的功不唐捐”。但“时间会冲淡一切”这句话总是适用的。我现在在这座我填志愿之前完全不知道的学校充实地生活着，感觉没什么不好的。当时那些遗憾什么的，我早已抛到脑后了。 这一年里充满了告别。其中让我意难平的是，我告别了会让我“shed 10,000 tears”的晚霞，告别了好哥们，告别了曾经喜欢的人。 这一年里也充满了遇见。我遇见了井越，一个在短短一年里在各许多方面都影响了我的人，一个过着我想要的生活的人。我被他vlog中亮度与色调都舒适自然的画面，精心设计渐入的小众音乐以及他兼具哲理与幽默感的谈吐所触动。我还遇见了更随和、心态更好、思想更成熟的我。当然不是所有遇见都是那么高兴的。我也遇见过心动选手，但在经历了一些事情后，经过冷静的思考和漫长的自我劝说，我已经说了拜。 新的一年。既往不恋，当事不杂，未来不迎。 继续健身，继续读书，继续热爱生活，继续珍惜身边人，继续心态良好待人随和。 无论怎样，2021，再见了。","link":"/2021/12/20/%E6%97%A0%E8%AE%BA%E6%80%8E%E6%A0%B7%EF%BC%8C2021%EF%BC%8C%E5%86%8D%E8%A7%81%E4%BA%86/"},{"title":"Codeforces Round 739 (Div. 3)","text":"链接：https://codeforces.com/contest/1560 总体评价：区分度不错，比之前的div3要难一些。 A预处理出前个，直接输出即可。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;const int N = 100050;const int INF = 1 &lt;&lt; 30;typedef long long ll;using namespace std;int n, x, num, ans[N];int main() { cin &gt;&gt; n; for(int i = 1; num &lt;= 1000; i++) { if(i % 10 == 3 || i % 3 == 0) continue; ans[++num] = i; } for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; x; cout &lt;&lt; ans[x] &lt;&lt; endl; } return 0;} B简简单单画出前几个的情况可以找到规律，加入一些特判的点即可。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;const int N = 100050;const int INF = 1 &lt;&lt; 30;typedef long long ll;using namespace std;int t, a, b, c, d;int main() { cin &gt;&gt; t; while(t--) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; d = abs(a - b); if(abs(a - b) == 1 || min(a, b) &gt; abs(a - b) || c &gt; 2 * d) { cout &lt;&lt; \"-1\" &lt;&lt; endl; continue; } c &lt;= d ? cout &lt;&lt; c + d &lt;&lt; endl : cout &lt;&lt; c - d &lt;&lt; endl; } return 0;} C也是找规律题。以左上角的为中心，向外画圈，看成{1}，{2，3，4}，{5，6，7，8，9}……这样分组。 看第列，。看第一行，。看左上到右下的那条对角线，。 首先初步判定是在第几组（环），，时间复杂度是可以接受的。 然后再判断得到时是行不变还是列不变，输出即可。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;const int N = 100050;const int INF = 1 &lt;&lt; 30;typedef long long ll;using namespace std;int t, x, n;int main() { cin &gt;&gt; t; while(t--) { cin &gt;&gt; x; for(int i = 1; i &lt;= 32000; i++) { if(i * i &gt;= x) { n = i; break; } } if(x &lt;= n * n - n + 1) cout &lt;&lt; x - (n - 1) * (n - 1) &lt;&lt; \" \" &lt;&lt; n &lt;&lt; endl; else cout &lt;&lt; n &lt;&lt; \" \" &lt;&lt; n - (x - (n * n - n + 1)) &lt;&lt; endl; } return 0;} D题意根据题中的规则进行操作，求将给定数变为一个的任意次幂的最少操作数。 思路看数据范围，可以知道我们最多只需预处理到，在这个上限以内符合条件的数在个左右，我们是可以接受的。 所以可以进行枚举，找到最小的答案。 答案怎么算？其实就是一个双指针的操作。遇到相同的统计一下，一起移动指针，否则只移动题中所给的字符串的指针，直到遍历完其中一个字符串。操作次数也就很好算了，等效为把原字符串中与答案不同的先删掉答案有但原字符串没有的。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;const int N = 100;const int INF = 1 &lt;&lt; 30;typedef long long ll;using namespace std;int k, ans;ll bin[N];string s;int calc(ll x) { string t = \"\"; while(x) { t += (x % 10) + '0'; x /= 10; } reverse(t.begin(), t.end()); int cnt = 0, j = 0, l = 0; while(j &lt; s.length() &amp;&amp; l &lt; t.length()){ if(s[j] == t[l]) { ++cnt; j++; l++; } else j++; } return s.length() + t.length() - cnt * 2;}int main() { ios::sync_with_stdio(false); cin &gt;&gt; k; bin[0] = 1; for(int i = 1; i &lt;= 62; i++) bin[i] = bin[i - 1] * 2; while(k--) { ans = INF; cin &gt;&gt; s; for(int i = 0; i &lt;= 62; i++) ans = min(ans, calc(bin[i])); cout &lt;&lt; ans &lt;&lt; endl; } return 0;} F1题意给定数，找到最小的，使得并且保证的十进制表示中最多出现种数字。 思路这题要想分类讨论还是太难了…… 若，则可以通过枚举找到答案。 若，我们可以枚举确定答案是由哪两个数字组成，同时按贪心思路构造出较小的答案，进行统计。很难想。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;int t, k;set&lt;char&gt; o;string s;string calc(char x) { string y = \"\"; for(int i = 0; i &lt; s.length(); i++) y += x; return y;}void solve1() { for(char i = '0'; i &lt;= '9'; i++) { string t = calc(i); if(t &gt; s) { cout &lt;&lt; t &lt;&lt; endl; return ; } }}void solve2() { string t = calc('9'); for(char i = '0'; i &lt;= '9'; i++) { for(char j = i + 1; j &lt;= '9'; j++) { for(int l = 0; l &lt; s.length(); l++) { if(s[l] &lt; j) { string g = s; g[l] &lt; i ? g[l] = i : g[l] = j; for(int p = l + 1; p &lt; g.length(); p++) g[p] = i; if(t &gt; g) t = g; } if(s[l] != i &amp;&amp; s[l] != j) break; } } } cout &lt;&lt; t &lt;&lt; endl;}int main() { ios::sync_with_stdio(false); cin &gt;&gt; t; while(t--) { o.clear(); cin &gt;&gt; s &gt;&gt; k; for(int i = 0; i &lt; s.length(); i++) o.insert(s[i]); if(o.size() &lt;= k) { cout &lt;&lt; s &lt;&lt; endl; continue; } k == 1 ? solve1() : solve2(); } return 0;} 还有个超时的做法，就是时用来做，也贴在这里吧…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;int t, k;set&lt;char&gt; o;string s;string calc(char x) { string y = \"\"; for(int i = 0; i &lt; s.length(); i++) y += x; return y;}void solve1() { for(char i = '0'; i &lt;= '9'; i++) { string t = calc(i); if(t &gt; s) { cout &lt;&lt; t &lt;&lt; endl; return ; } }}void dfs(int step, char t1, char t2, string &amp;t, string p) { //cout &lt;&lt; t &lt;&lt; \" \" &lt;&lt; p &lt;&lt; endl; if(step == 2 &amp;&amp; p == \"0\") return ; if(step != 1 &amp;&amp; p[0] &lt; s[0]) return ; if(step == s.length() + 1) { if(p &lt; t &amp;&amp; p &gt; s) { t = p; return ; } return ; } string last = p; dfs(step + 1, t1, t2, t, p + t1); p = last; dfs(step + 1, t1, t2, t, p + t2); p = last;}void solve2() { string t = \"\", p = \"\"; t = calc('9'); for(char i = '0'; i &lt;= '9'; i++) { for(char j = '0'; j &lt;= '9'; j++) { if(i == j) continue; // cout &lt;&lt; *it1 &lt;&lt; \" \" &lt;&lt; *it2 &lt;&lt; endl; dfs(1, i, j, t, p); } } cout &lt;&lt; t &lt;&lt; endl;}int main() { ios::sync_with_stdio(false); cin &gt;&gt; t; while(t--) { o.clear(); cin &gt;&gt; s &gt;&gt; k; for(int i = 0; i &lt; s.length(); i++) o.insert(s[i]); if(o.size() &lt;= k) { cout &lt;&lt; s &lt;&lt; endl; continue; } k == 1 ? solve1() : solve2(); } return 0;}","link":"/2021/08/21/Codeforces%20Round%20739%20(Div.%203)/"},{"title":"Codeforces Round 738 (Div.2)","text":"比赛链接：https://codeforces.com/contest/1559 总体评价：Chinese Round，前四道题目较为简单，后两道貌似难度剧增…… 题意基本上是自己写的，也算练练英语吧……如果有语法错误还请海涵。 A题意Select an arbitrary interval and for all values , replace with &amp; at the same time.This operation can be performed any number of times. Minimize the maximum value in the sequence. 思路将一个数用二进制表示后，每一位非即。 根据与运算的性质，两个数相与，对于二进制下都为的某一位没有影响。然而如果存在第位，一个数为，另一个为，那么结果必然会变小。 由于题目未限制与运算的次数，那么只需要让赋上的值，让依次与之后的每一个数相与即可得到答案。 1234567891011121314151617#include &lt;cstdio&gt;#include &lt;iostream&gt;const int N = 150;using namespace std;int t, n, ans, a[N];int main() { ios::sync_with_stdio(false); cin &gt;&gt; t; while(t--) { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; ans = a[1]; for(int i = 2; i &lt;= n; i++) ans = ans &amp; a[i]; cout &lt;&lt; ans &lt;&lt; endl; } return 0;} B题意Given a string containing ‘B’, ‘R’, or ‘?’，you need to replace the ‘?’ with ‘B’ or ‘R’ to get a new string. At the same time, you should minimize the number of the ”BB“ and “RR”. 思路找到每个有字母的位置，利用贪心思想向前依次填字母。 需要特殊处理只有一个字母的情况，否则该字母后的”?”无法填上字母。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;const int INF = 1 &lt;&lt; 30;const int N = 150;typedef long long ll;using namespace std;struct node { int x, y;}b[N];int t, n, cnt, num, a[N];char c;int main() { cin &gt;&gt; t; while(t--) { num = cnt = 0; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; c; if(c == '?') { a[i] = -1; ++cnt; } else { a[i] = (c == 'B') ? 1 : 2; b[++num] = (node){i, cnt}; cnt = 0; } } for(int i = 1; i &lt;= num; i++) { for(int j = b[i].x - 1; j &gt;= b[i].x - b[i].y; j--) { a[j] = (a[j + 1] == 1) ? 2 : 1; } } for(int i = 1; i &lt;= n; i++) { if(a[i] == 1 || a[i] == 2) a[i] == 1 ? cout &lt;&lt; \"B\" : cout &lt;&lt; \"R\" ; else a[i - 1] == 1 ? (a[i] = 2, cout &lt;&lt; \"R\") : (a[i] = 1, cout &lt;&lt; \"B\"); } cout &lt;&lt; endl; } return 0;} C题意Follow the rules to add edges, then find a way which goes through every point exactly once. 思路简简单单的建图、。 或者也可以找规律来完成此题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;const int N = 10050;using namespace std;int t, n, num, a[N], ans[N];bool flag, vis[N];vector&lt;int&gt; g[N];void dfs(int x, int step) { if(step == n &amp;&amp; num - 1 == step) { flag = 1; for(int i = 1; i &lt;= num; i++) cout &lt;&lt; ans[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return ; } for(int i = 0; i &lt; g[x].size() &amp;&amp; !flag; i++) { int to = g[x][i]; if(vis[to]) continue; vis[to] = 1; ans[++num] = to; dfs(to, step + 1); num--; vis[to] = 0; }}int main() { cin &gt;&gt; t; while(t--) { cin &gt;&gt; n; for(int i = 1; i &lt;= n - 1; i++) g[i].push_back(i + 1); for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; a[i] ? g[n + 1].push_back(i) : g[i].push_back(n + 1); } for(int i = 1; i &lt;= n + 1; i++) { if(flag) break; memset(vis, 0, sizeof(vis)); vis[i] = 1; num = 1; ans[num] = i; dfs(i, 0); } if(!flag) cout &lt;&lt; \"-1\" &lt;&lt; endl; for(int i = 1; i &lt;= n + 1; i++) g[i].clear(); memset(vis, 0, sizeof(vis)); flag = 0; } return 0;} D1题意Given two forests(A forest is an undirected graph without cycles (not necessarily connected).), you can add an edge between and in two forests at the same time.Maximum the number of edges they can add, and which edges to add. 思路考虑到数据范围，一种很暴力的思路就是邻接矩阵存图，枚举边，每次判环，然后愉快的Time limit exceeded on pretest 6。 正确做法是不用建图，只需要使用并查集即可，加上路径压缩的并查集可以节省很多时间。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;const int N = 1050;using namespace std;int n, m1, m2, u, v, fa[2][N];struct node { int x, y;};vector&lt;node&gt; ans;int get_fa(bool tp, int x) { return x == fa[tp][x] ? x : fa[tp][x] = get_fa(tp, fa[tp][x]); }int main() { ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2; for(int i = 1; i &lt;= n; i++) fa[0][i] = fa[1][i] = i; for(int i = 1; i &lt;= m1; i++) { cin &gt;&gt; u &gt;&gt; v; fa[0][get_fa(0, v)] = get_fa(0, u); } for(int i = 1; i &lt;= m2; i++) { cin &gt;&gt; u &gt;&gt; v; fa[1][get_fa(1, v)] = get_fa(1, u); } for(int i = 1; i &lt;= n; i++) { for(int j = i + 1; j &lt;= n; j++) { if((get_fa(0, i) != get_fa(0, j)) &amp;&amp; (get_fa(1, i) != get_fa(1, j))) { fa[0][get_fa(0, j)] = get_fa(0, i); fa[1][get_fa(1, j)] = get_fa(1, i); ans.push_back((node){i, j}); } } } cout &lt;&lt; ans.size() &lt;&lt; endl; for(int i = 0; i &lt; ans.size(); i++) cout &lt;&lt; ans[i].x &lt;&lt; \" \" &lt;&lt; ans[i].y &lt;&lt; endl; return 0;}","link":"/2021/08/17/Codeforces%20Round%20738%20(Div.2)/"},{"title":"Goodbye 2020 Hello 2021","text":"几个月没更新博客了，好久没一个人坐下来写点东西了。 适逢年末，写点东西，来纪念一下2020吧。 似乎每个人都认为2020是个不平凡的一年。澳洲山火，新冠疫情，东京奥运会推迟，科比、黑豹、马拉多纳的永别，安倍辞职，拜登胜选……太多太多有着很大冲击力的事情接踵而至，让人心情起伏不定。 对我个人而言，也是对大多数人而言，影响最大的应该就是突如其来的疫情吧。第一次有了被强制不让出门的经历，第一次体验网课生活，第一次连着1个月看到大街上空无一人…… 老沈说：“疫情让我们学会与孤独共处。” 确实，疫情初期的生活可谓煎熬。每天自己局促一室以内，做着千篇一律的事情，未免会感到非常孤独。那段时间真的想找人聊聊天，来缓解心中之无聊。之后，才渐渐熟悉了这样的生活。每天早上在家里上上课，写写作业；下午看看书，写写作业，刷刷知乎，锻会炼；晚上看看权游，了解了解今天新闻，和朋友聊聊天……一天就这么过去了。到后面解封的那天，当脚迈出单元门，踩到大地的那一刻，我竟有一种既熟悉又陌生的感觉。 高二下学期，下决心彻底不想竞赛，全心全意投入到文化课上，便选择了住宿。第一次体验住宿生活，从最初3天的失眠、不熟悉到之后的渐渐习惯，我渐渐感受到了住宿生活的好处：时间的节省、人际关系的拓展、有节奏的生活……高二下学期3次考试的排名相比与高一的时候好了很多，自己终于离梦想更近了一步。 暑假到来，自己定了一个跑步锻炼计划，但不久又被疫情打破。之后不知道为什么，心情一直都很浮躁。在家一轮复习的网课的状态一直都不是很好。开学，高三来了。班里的气氛真的和高二的时候大相径庭，每个人都在抓紧每一分每一秒学习。墙上的倒计时数字悄无声息的一天天减少，快的让人觉得不可思议。感觉开学后自己的状态，时好时坏吧。几次考试的成绩和高二下学期相比，又有所退步。总感觉是自己心态的问题。经常因为自己考试总是失误而失望，失望后又“及时奋发精神”……最近一直都在调整心态，希望自己真的能做到“胜不妄喜，败不惶馁，胸有激雷而面如平湖”。感觉自己还是如初中班主任老白言：“少点静气。” 感觉最近几周过的真的太快太快了。拼命想抓住流年，但无果。那就活在当下，不辜负每分每秒吧。 值得高兴的是，在我每逢跌入低谷，总会遇到温暖的人在旁倾听，为我排忧解难。我不胜感激。 新年将至，愿家人和朋友们平安喜乐，万事胜意，诸事顺遂。 愿我们，都能成为心中所向吧。","link":"/2020/12/19/Goodbye-2020-Hello-2021/"},{"title":"浅谈高中生物”碱基对确定，求DNA最多种数”问题","text":"前言这个问题在高中生物中，并不会研究的那么深刻。 所以正式做题时还是应该按照老师的教导，避开这个“雷区”。 1.问题发现在高中生物-遗传与进化-基因的本质学习中，有一个十分经典的问题。 即：给定碱基对数n，不限定每种碱基(A,C,G,T)的个数，求出最多的DNA种数。 在所有的教材，辅导书，以及老师的授课过程中，对于这个问题的答案，一般都是或者。 对于的思路，即每个位置有种碱基对可能，一共有组，根据乘法原理，故为。 对于的思路，即在上一种思路的基础上，考虑到有重复的情况，便除了个2​。 但是，@thorn,@opethrax以及本人的对于这些答案深感怀疑，于是我们便手算了当碱基对数为时的所有情况。 利用计算机程序进行打表，以及查询有关的资料后，最终我们确定当n=2时，结果理应为10​。 这个答案都不能用上面的公式解答，于是我们继续思考探索。 2.深入探究通过@opethrax同学辛苦的打表，观察，他发现存在一些情况被忽略。 原先我们认为，一个分子拥有与段，代表三号碳，代表五号碳。 如下图，从两条链的端分别扫描，一种序列最多被统计到次。 一个是AGCTA​，另一种是TAGCT。 但是，存在一种分子，从其两条链的端分别扫描，结果相同。 如下图： 都为TCGATCGA。 所以这种情况下，具有这种性质的会被少统计一次。 且我们不难发现，满足这种性质当且仅当链的长度为偶数（如图一，若为奇数，会出现不对称的情况，即不满足这种性质）。 那么我们分类讨论，之前那个的公式，可以在n​为奇数时使用。 对于n​为偶数的情况，我们要在原公式的基础上，加上少统计的个数。 现在的问题，即是寻找拥有这种特殊性质的链的个数。 不难发现，一条链的端的号碱基到该链的第号碱基，如果和另一条链的端的号碱基到该链的第号碱基相同，剩下的部分通过碱基互补配对原则，可以保证相同。 下图黑的部分是我们自己确定的一条排列，红色部分是根据碱基互补配对原则形成的。 我们可以把这个理解为一种中心对称。 所以我们只需要构造出一条链中一半的排列，然后按照中心对称放到另一条链的端，剩下那条按照碱基互补配对原则填充即可满足这种性质。 所以我们不难得出，这种情况下，会有条链会被少统计一次。 至此，我们可以得出公式： a_n=\\begin{cases}\\frac{4^n}{2}\\ \\ \\ \\ \\ \\ \\ \\ n=2k+1\\\\\\frac{4^n+4^{\\frac{n}{2}}}{2}\\ n=2k\\ \\ (k\\in N^*)\\end{cases}这个式子经过打表以及oeis.org的确认，结果正确。 3.声明与感谢其实的结构远比人类脑海中想象的要复杂的多，这里我们只是讨论了理论下的情况。 感谢您的阅读。若您存在任何疑问，或觉得我们有些地方存在纰漏，欢迎您联系我们，我们十分乐意与您探讨。 再次感谢两位同学@thorn,@opethrax深夜的探讨与陪伴，若没有他们的帮助，我们很难单独进行下去。 thorn有关这篇文章的链接：https://www.cnblogs.com/thornblog/p/12381381.html opethrax有关这篇文章的链接：https://home.cnblogs.com/u/opethrax/ 他们两位有关这个内容的博客写的都非常优秀，建议您去访问他们的博客以进行更多的了解。 除非另有说明，本网站上的内容均采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，请您在转载时注明来源及博客链接。 4.深夜随想造物主强大的力量是人们无法想象到的。人类很难走到没有任何疑惑的那一天。 每一个个体脑中冒出的新奇想法，或提出的一个问题，都有可能成为筑起人类从无知到有知的桥梁下的一粒石子。 对科学的探索，不是浅尝辄止，而是无穷无尽。 献上一首不错的音乐： “生于此处却不知此处 日光倾城，万物生长，又是为何 若没有大地的拥抱，我们早已消失于茫茫宇宙之中 若没有原子之稳定，我们亦不复存在 无人问天地变换，斗转星移，是为何故 宇宙又是源于何处 它是否无始无终 时间若愿意倒流，我们的认知是否还会有局限 世间最渺小之物又是什么 滚滚长江，却只留有过去，不知未来 浩淼宇宙，为何我们在此相遇” ——《Moonlight》","link":"/2020/02/29/%E6%B5%85%E8%B0%88%E9%AB%98%E4%B8%AD%E7%94%9F%E7%89%A9%E2%80%9D%E7%A2%B1%E5%9F%BA%E5%AF%B9%E7%A1%AE%E5%AE%9A%EF%BC%8C%E6%B1%82DNA%E6%9C%80%E5%A4%9A%E7%A7%8D%E6%95%B0%E2%80%9D%E9%97%AE%E9%A2%98/"},{"title":"浅谈Cauchy不等式","text":"形式 \\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2 \\geq \\sum_{i=1}^{n}a_i^{2}b_i^2等号成立的条件： iff:b_i=0 || \\exists k \\in \\mathbb {R},a_i=k \\cdot b_i(i \\in \\mathbb{N^+})证明法一：参数配方思路：巧妙的把常数与方程结合起来，利用性质即可。 证明：构造函数: f(t)=\\sum_{i=1}^{n}b_i^2\\cdot t^2-2\\sum_{i=1}^{n}a_ib_it+\\sum_{i=1}^{n}a_i^2化简函数： f(t)=\\sum_{i=1}^{n}b_i^2\\cdot t^2-2\\sum_{i=1}^{n}a_ib_it+\\sum_{i=1}^{n}a_i^2 =\\sum_{i=1}^{n}(b_i^2t^2-2a_ib_it+a_i^2) =\\sum_{i=1}^{n}(b_i^2t^2+a_i^2-2a_ib_it) =\\sum_{i=1}^{n}(b_it-a_i)^2所以： f(t) \\geq 0 \\Delta t=b^2-4ac =4\\sum_{i=1}^{n}a_i^2b_i^2-4\\times \\sum_{i=1}^{n}b_i^2 \\times \\sum_{i=1}^{n}a_i^2 \\leq 0所以： 4\\sum_{i=1}^{n}a_i^2b_i^2 \\leq 4\\times \\sum_{i=1}^{n}b_i^2 \\times \\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}a_i^2 \\times \\sum_{i=1}^{n}b_i^2 \\geq \\sum_{i=1}^{n}a_i^2b_i^2证毕。 因为： f(t)=\\sum_{i=1}^{n}(b_it-a_i)^2令，即 a_i=b_it此时： f(t)_{min}=0​即： \\Delta t \\leq 0故等号可取的一个充分条件即为： \\exists k \\in \\mathbb {R},a_i=k \\cdot b_i(i \\in \\mathbb{N^+}）法二：均值不等式证明思路：运用分析法将原式子化简，使用绝对值三角不等式与均值不等式进行证明。 引用到的均值不等式（证明略）： ab \\leq \\frac{a^2+b^2}{2}适用条件： a,b \\in \\mathbb {R^+}等号成立条件： iff:a=b证明：要证： \\sum_{i=1}^{n}a_i^2\\sum_{i=1}^{n}b_i^2 \\geq \\sum_{i=1}^{n}a_i^{2}b_i^2只需证： \\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2} \\geq |\\sum_{i=1}^{n}a_ib_i|即： |\\sum_{i=1}^{n}a_ib_i| \\leq \\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2} \\frac{|\\sum_{i=1}^{n}a_ib_i|}{\\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2}}\\leq 1由绝对值三角不等式： |a_1+a_2+a_3+\\cdots+a_n| \\leq |a_1|+|a_2|+|a_3|+ \\cdots + |a_n|可得： |\\sum_{i=1}^{n}a_ib_i| \\leq \\sum_{i=1}^{n}|a_ib_i|所以： \\frac{|\\sum_{i=1}^{n}a_ib_i|}{\\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2}} \\leq \\frac{\\sum_{i=1}^{n}|a_ib_i|}{\\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2}}又因为： \\frac{\\sum_{i=1}^{n}|a_ib_i|}{\\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2}} =\\sum_{i=1}^{n}\\frac{|a_i|}{\\sqrt{\\sum_{i=1}^{n}a_i^2}}\\cdot \\frac{|b_i|}{\\sqrt{\\sum_{i=1}^{n}b_i^2}}由均值不等式： ab \\leq \\frac{a^2+b^2}{2}可得： \\sum_{i=1}^{n}\\frac{|a_i|}{\\sqrt{\\sum_{i=1}^{n}a_i^2}}\\cdot \\frac{|b_i|}{\\sqrt{\\sum_{i=1}^{n}b_i^2}} \\leq \\frac{1}{2}\\cdot \\sum_{i=1}^{n}(\\frac{a_i^2}{\\sum_{i=1}^{n}a_i^2}+ \\frac{b_i^2}{\\sum_{i=1}^{n}b_i^2}) \\leq \\frac{1}{2}\\cdot (\\frac{\\sum_{i=1}^{n}a_i^2}{\\sum_{i=1}^{n}a_i^2}+ \\frac{\\sum_{i=1}^{n}b_i^2}{\\sum_{i=1}^{n}b_i^2}) \\leq \\frac{1}{2} \\times 2 = 1即： \\frac{|\\sum_{i=1}^{n}a_ib_i|}{\\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2}}\\leq 1上述结论成立，证毕。 法三：n维向量证法因为： |\\vec a \\cdot \\vec b| = |\\vec a|\\cdot |\\vec b| \\cdot cos \\theta所以： |\\vec a \\cdot \\vec b| \\leq |\\vec a|\\cdot |\\vec b| |\\vec a \\cdot \\vec b|^2 \\leq |\\vec a|^2\\cdot |\\vec b|^2为维向量时，用坐标的形式展开即可证明。 当，即，共线时，等号成立。 申明与感谢 内容采用“知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议”进行许可。请您在转载时注明来源及链接。 感谢@thorn的审稿。","link":"/2020/01/17/%E6%B5%85%E8%B0%88Cauchy%E4%B8%8D%E7%AD%89%E5%BC%8F/"},{"title":"终于结束的起点——CSP-S 2019 第二轮游记","text":"Day -3在教练和自己的劝说下，终于还是选择最后几天停课，专心复习，全力以赴。 Day -2上午一直在复习数论知识，中午睡了个午觉，起来后身体就很难受了。 晚上就直接请假回家睡觉。感觉发烧了，一测，39度左右。感觉药丸。 Day -1早上去医院检查，细菌性感染，开了一些奇奇怪怪的药，整个一天都处于头疼炸裂的状态。 一天都没有复习任何知识。周五中午的活动也参加不了了。 病来如山倒。 自认倒霉。在这个紧要关头，居然生了大病。 Day 0起床后感觉身体状态海星。希望今天别太难受了。 中午去了趟机房，拿了点东西，获得了许多人的关心QAQ 互相祝福后，便直接回家了 中午睡完觉后又开始发烧了，抗生素所带来的不良反应也越来越重，怎么办啊版子还没看完QAQ 算了不管了，放平心态，不管结果了。 Day 1昨天晚上在奇怪的梦中醒来两次，又是因为腹泻。 6：50，早上一出门，发现雪下了好厚一层。 深夜的一中，没有灯光，雪地上只有一些人走过的脚印痕迹。 到了校车上，想休息一会，根本睡不着。 感觉自己已经释怀了，没有什么追求了，心中很平静，但还是睡不着。 到了考场，开考5分钟左右才发题。 看到T1，先找了找规律，把可能有联系的东西都写在了纸上，但是越看越乱，最终交了个50分的暴力。 然后感觉T3的题意较T2好理解，于是想去写T3的部分分。 写了好久，发现有一些小细节，最终没调出来，先去写T2吧。 看到T2链的情况挺好写的，快快的写了个35分就去调T3。 最终没调出来。 出考场，基本上许多人都写出来了T1，发现我的想法已经很接近了，但是考场上还是放弃了。 应该没有什么奇迹了吧。 文化课，你好。 Day 2状态还不错。 考试过程还是不说了。 至于结果，还是不尽人意。 自己一个人打了出租车，心中很平静。 “四年OI一场空”，确实，没有什么奖杯奖牌，没有什么纪念品。 但有时候，过程，难道不就是最可贵的吗。 在OI中，我经历了许多，也学习了许多。 知晓了许多学习方法，明白了许多其他人不知道的知识。 在OI中，我失去了许多，也收获了许多。 失去了大量的文化课时光，失去了高一的寒暑假，以及各种节假日。 但收获了许多朋友，一起一同为了某个目标奋斗的知音者。 终于结束的起点终于写下句点终于我们告别终于我们又回到原点一个个 OIer 的竞赛生涯总是从一场 NOIp 开始，大多也在一场 NOIp 中结束，好似一次次轮回在不断上演。如果这次 NOIp 是你的起点，那么祝你的 OI 生涯如同夏花般绚烂。如果这次 NOIp 是你的终点，那么祝你的 OI 回忆宛若繁星般璀璨。 —-Luogu P4994 终于结束的起点 结束了，一切都结束了。 开始了，新的征程要开始了。 取得好成绩的各位，在收获了硕果后也不应该沾沾自喜，争取拼搏出更美好的未来。 没有得到理想成绩的后辈，应该总结经验教训，不要气馁，积水至成渊之时，静待蛟龙诞生之日。 祝进省队的同学，在接下来的WC,CTS,APIO,NOI取得优异的成绩。 朋友，无论你从哪条路走来，希望你能忆起自己挥洒过汗水的日子。OI 也好，其他也罢，至少你曾有过热爱的事情。你曾付出的所有心血，都值得被自己永久记得。 无论你现在的处境如何，顺利继续前进或是刚刚历经一次转折，希望你微笑着拥抱现实。请向前看，前方路还长，还有很多很多值得你热爱的事情。也许是延续旧的热爱，也许是如旧般热爱。爱在心里，爱过，也将爱着。 无论你将走在哪条路上，无论你的下一站在何方，请一如既往地全力以赴。路可能分支，拼搏却永远不变。前路也许不同，但一定精彩纷呈。愿你将过往路上的拼搏精神，继续用于前路。如此看来，过往将以这样的方式，伴你左右至永远。岔路口请你带着梦前进，走向值得期待的未来。 过去如是，现在如是，未来——亦如是。 —-Capella AFO.文化课你好！","link":"/2019/11/15/%E7%BB%88%E4%BA%8E%E7%BB%93%E6%9D%9F%E7%9A%84%E8%B5%B7%E7%82%B9%E2%80%94%E2%80%94CSP-S-2019-%E7%AC%AC%E4%BA%8C%E8%BD%AE%E6%B8%B8%E8%AE%B0-BeyondLimits/"},{"title":"CSP-S 2019 第一轮 游记","text":"Day -1早上学校有两节英语两节语文，就翘掉了。 在家里把的开放试卷做完了，，成绩不算很好。 听说这次参赛的水军都没了，复赛可能会很难进，感觉自己心态还可以。 下午围观了有趣的四川选手名单，被四川的操作震惊，看来我们还是太了… 还做了的试题，题挺难的，写完后心态大崩 Day 0又请了前三节课的假，把初赛篇的基本知识全过了一遍，感觉还不错。 还把的题的题解全看了一遍（upd：事实证明这是正确的做法，因为在真正考试中见到了不少原题） 晚上在机房和一起又把初赛的基础知识全过了一遍，膜拜的数学能力 还和研究了许久的主定理（upd：第二天居然没有考…） 很早就睡了，也没有考前欢乐。 Day 1好冷啊。 早上8：50就到了，科协的人居然还没有布置考场（太咕了，昨天晚上科协的人忙着印卷子居然让我们自己去准备考场相关事宜，贴条子）。 遇见了许久不见的，还有其他原来认识的人。 9：20进考场，惊奇的发现居然就做我左边，座位还是挨着的，但今年是卷，所以不担心答案。 但最后我们还是被分开了。。。 再一次吐槽科协的奇妙操作： 1.监考老师说：你们要是没有草稿纸，可以向周围人借。 （啥？去年不是还考过选择题说不能带草稿纸吗？） 2.监考老师说：分赛区填新疆。 （啥？那省份填全国吗？） 3.监考老师说：不能提前交卷。 （啥？这又是什么规定？提前阿克的人不能离场吗？（这里指的不是我）） 最后全部打脸。 看到卷子，感觉题量挺大。 看选择题，做起来都不是很难，居然还有原题。 遇见了一些有趣的数学题，便先放下然后去想后面的题去了。 阅读程序，前两道题都是属于看一眼就知道在干嘛的题，但是判断题当时做起来有点懵。 第三题没怎么看懂，自己造了两组数据模拟了一下，成功解决了判断题，最后两道选择题就蒙了起来。 完善程序，第一题比较简单。 第二题耗了我将近的时间，一直没看懂，到最后也是。 交完卷子后便去上物理课去了。 中午回到机房，答案出来了，便开始对。 选择错一道，是那道车牌数学题。 阅读程序第一题判断有个错了。 第二题错了一道选择一道判断，是真的坑题。 当我看到算法复杂度时，我就直接选择了，但是完全没有注意到，这并查集居然没有路径压缩（这什么辣鸡啊 还有第四道判断题，当点与所在连通块相同时，那么他们相乘后的结果显然会。 第三题据说不能读空子串，就很生草。 完善程序最后一道就对了个。。。 最后估分77分，在机房人里面排中等吧。 晚上和yyy还有jmh点了三个小菜，在水房边吃边聊，聊一些往昔与来者。 总结： 自己的功底还是不行，对于状压这种东西，还是得多钻研啊。不能知难而退。 平时心态方面也要放好一点啊。 复赛应该能进，剩下的时光，就留给月考和复赛的训练了吧。 乾坤未定，谁都是匹黑马。 各位加油鸭！ （ps：%yyy %jmh","link":"/2019/10/19/CSP-S-2019-%E7%AC%AC%E4%B8%80%E8%BD%AE-%E6%B8%B8%E8%AE%B0/"},{"title":"初等数论整理","text":"1.gcd与exgcd欧几里得算法： 1int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); } 扩展欧几里得算法： 若, 可把符号转移到中，令。 令，对于一组不定方程，有解当且仅当。 对于这组不定方程，我们可以先求出，得到一组解，同时乘上，即得到一组原方程的解。函数返回的值，是。 123456789101112int exgcd(int a, int b, int &amp;x, int &amp;y) { if(b == 0) { x = 1; y = 0; return a; } int gcd = exgcd(b, a % b, x, y), t; t = x; x = y; y = t - a / b * y; return gcd;} 对于这组不定方程的通解，可以表示为： 其中的取值在整数集合里。 2.欧拉函数及欧拉定理欧拉函数欧拉函数：表示中与互质的整数的个数。 一些定理 若为质数，则. 证明：显然。若为一个质数的幂次方，表示为，则. 证明：小于等于的正整数一共有个，对于那些可以被整除的数可以表示为，其中,共有个数。所以不能被整除的数的个数，即 若互质，则. 证明：根据的通项公式易证。 若，则. 证明：根据的通项公式易证。 欧拉函数的通项公式设为的质数幂乘积，则 证明：各质数幂之间显然互质，根据上面的定理，即可表示出： ​ ​ ​ 欧拉定理若与互质，则 一些定理若互质，则 证明：由欧拉定理，则：","link":"/2019/08/12/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E6%95%B4%E7%90%86/"},{"title":"tarjan 学习笔记","text":"求强连通分量思想：在的过程中，把强连通分量中的点入栈，当找到一个强连通分量的最起始的点，就将其所在强连通分量中的点出栈。 缩点把强连通分量中的点缩成一个点，进行重新建图，从而解决一些问题。 割点若将这个点在图中所连的边删去，图变得不连通，则称这个点为一个割点。 考虑两种情况： 若节点为根节点，则它若联结着两颗及以上数量的子树，则为割点。 ，设的其中一个儿子为，若出现，则为割点。 习题luogu 3388 【模板】割点（割顶）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;const int MAXN = 20050;const int MAXM = 100050;using namespace std;struct node { int to, nextt;}edge[MAXM &lt;&lt; 1];int n, m, u, v, num, cnt, low[MAXN], dfn[MAXN], head[MAXN];set&lt;int&gt; s;void addedge(int u, int v) { edge[++num].to = v; edge[num].nextt = head[u]; head[u] = num;}void tarjan(int x, int fa) { dfn[x] = low[x] = ++cnt; int child = 0; for(int i = head[x]; i; i = edge[i].nextt) { int to = edge[i].to; if(!dfn[to]) { if(x == fa) child++; tarjan(to, x); low[x] = min(low[x], low[to]); if(x != fa &amp;&amp; low[to] &gt;= dfn[x]) s.insert(x); } low[x] = min(low[x], dfn[to]); } if(x == fa &amp;&amp; child &gt;= 2) s.insert(x);}int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) { cin &gt;&gt; u &gt;&gt; v; addedge(u, v); addedge(v, u); } for(int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i, i); } cout &lt;&lt; (int)s.size() &lt;&lt; endl; for(set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \"; cout &lt;&lt; endl; return 0;} Luogu 2921 Trick or Treat on the Farm第一种做法是进行，对于所在强连通分量里个数大于的点，答案即为当前强连通分量的大小；由于数据的特殊性，另一种情况即为到强连通分量的距离加上那个强连通分量的大小。 第二种做法是三遍递归。第一遍把所有不在环内的点打上标记，第二遍求出未被标记的点所在环的大小，第三遍累加到环的距离。总体想法与第一种是一样的。 代码(#2)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;const int MAXN = 100050;using namespace std;int n, x, nextt[MAXN], ans[MAXN], in[MAXN];bool vis[MAXN];void dfs1(int x) { vis[x] = true; if(!--in[nextt[x]]) dfs1(nextt[x]);}int dfs2(int x, int num) { vis[x] = true; ans[x] = num; if(ans[nextt[x]]) return num; return ans[x] = dfs2(nextt[x], num + 1);}int dfs3(int x) { if(ans[x]) return ans[x]; return ans[x] = dfs3(nextt[x]) + 1;}int main() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; nextt[i]; ++in[nextt[i]]; } for(int i = 1; i &lt;= n; i++) { if(!vis[i] &amp;&amp; !in[i]) dfs1(i); } for(int i = 1; i &lt;= n; i++) { if(!ans[i] &amp;&amp; in[i]) x = dfs2(i, 1); } for(int i = 1; i &lt;= n; i++) { if(!ans[i] &amp;&amp; !in[i]) x = dfs3(i); } for(int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; endl; return 0;} Luogu 1726 上白泽慧音显然答案即为最大的强连通分量的个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;const int MAXN = 5050;const int MAXM = 50050;const int INF = 1 &lt;&lt; 30;using namespace std;stack&lt;int&gt; s;struct Edge { int to , nextt;}edge[MAXM &lt;&lt; 1];int n, m, u, v, ty, num, cnt, cnt1, Max, pos, ss[MAXN], head[MAXN], low[MAXN], dfn[MAXN], sccno[MAXN];void addedge(int u, int v) { edge[++num].to = v; edge[num].nextt = head[u]; head[u] = num;}void tarjan(int x) { dfn[x] = low[x] = ++cnt; s.push(x); for(int i = head[x]; i; i = edge[i].nextt) { int to = edge[i].to; if(!dfn[to]) { tarjan(to); low[x] = min(low[x], low[to]); } else if(!sccno[to]) low[x] = min(low[x], dfn[to]); } if(dfn[x] == low[x]) { int now, cnt2 = 0; ++cnt1; while(true) { now = s.top(); s.pop(); ++cnt2; sccno[now] = cnt1; ss[now] = cnt1; if(now == x) break; } if(cnt2 &gt; Max) { Max = cnt2; pos = cnt1; } }}int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; ty; addedge(u, v); if(ty == 2) addedge(v, u); } for(int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i); } cout &lt;&lt; Max &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) { if(ss[i] == pos) { for(int j = i; j &lt;= n; j++) { if(ss[j] == pos) cout &lt;&lt; j &lt;&lt; \" \"; } return 0; } } return 0;} Luogu 3387 【模板】缩点先进行缩点，后作类似拓扑的操作，即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;const int MAXN = 10050;const int MAXM = 100050;using namespace std;stack&lt;int&gt; ss;queue&lt;int&gt; q;struct Edge1 { int u, to, nextt;}edge1[MAXM];struct Edge2 { int u, to, nextt;}edge2[MAXN];int n, m, u, v, ans, num1, num2, cnt, cnt1, head1[MAXN], head2[MAXN], dfn[MAXN], low[MAXN], sccno[MAXN], sd[MAXN], in[MAXN], val[MAXN], dis[MAXN];void addedge1(int u, int v) { edge1[++num1].u = u; edge1[num1].to = v; edge1[num1].nextt = head1[u]; head1[u] = num1;}void addedge2(int u, int v) { edge2[++num2].u = u; edge2[num2].to = v; edge2[num2].nextt = head2[u]; head2[u] = num2;}void tarjan(int x) { dfn[x] = low[x] = ++cnt; ss.push(x); for(int i = head1[x]; i; i = edge1[i].nextt) { int to = edge1[i].to; if(!dfn[to]) { tarjan(to); low[x] = min(low[x], low[to]); } else if(!sccno[to]) low[x] = min(low[x], dfn[to]); } if(dfn[x] == low[x]) { ++cnt1; while(true) { int now = ss.top(); ss.pop(); sccno[now] = cnt1; sd[now] = x; if(now == x) break; val[x] += val[now]; } }}void topo() { for(int i = 1; i &lt;= n; i++) { if(!in[i] &amp;&amp; sd[i] == i) { q.push(i); dis[i] = val[i]; } } while(!q.empty()) { int now = q.front(); q.pop(); for(int i = head2[now]; i; i = edge2[i].nextt) { int to = edge2[i].to; dis[to] = max(dis[to], dis[now] + val[to]); if(!--in[to]) q.push(to); } } for(int i = 1; i &lt;= n; i++) ans = max(ans, dis[i]);}int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; val[i]; for(int i = 1; i &lt;= m; i++) { cin &gt;&gt; u &gt;&gt; v; addedge1(u, v); } for(int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i); } for(int i = 1; i &lt;= m; i++) { int u = sd[edge1[i].u], v = sd[edge1[i].to]; if(u == v) continue; addedge2(u, v); in[v] ++; } topo(); cout &lt;&lt; ans &lt;&lt; endl; return 0;} Luogu 3627 抢掠计划先缩点，后跑一遍（最长路）即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;const int MAXN = 500050;const int INF = 1 &lt;&lt; 30;using namespace std;struct Edge1 { int u, to, nextt;}edge1[MAXN];struct Edge2 { int u, to, val, nextt;}edge2[MAXN];stack&lt;int&gt; d;queue&lt;int&gt; q;int n, m, u, v, w, x, num1, num2, cnt, cnt1, s, p, ans, sd[MAXN], head1[MAXN], head2[MAXN], low[MAXN], dfn[MAXN], vall[MAXN], dis[MAXN], sccno[MAXN];bool vis[MAXN];int read() { int x = 0; bool sign = false; char alpha = 0; while(!isdigit(alpha)) { sign |= alpha == '-'; alpha = getchar(); } while(isdigit(alpha)) { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (alpha ^ 48); alpha = getchar(); } return sign ? -x : x;}void addedge1(int u, int v) { edge1[++num1].u = u; edge1[num1].to = v; edge1[num1].nextt = head1[u]; head1[u] = num1;}void addedge2(int u, int v, int w) { edge2[++num2].u = u; edge2[num2].to = v; edge2[num2].val = w; edge2[num2].nextt = head2[u]; head2[u] = num2;}void tarjan(int x) { dfn[x] = low[x] = ++cnt; d.push(x); for(int i = head1[x]; i; i = edge1[i].nextt) { int to = edge1[i].to; if(!dfn[to]) { tarjan(to); low[x] = min(low[x], low[to]); } else if(!sccno[to]) low[x] = min(low[x], dfn[to]); } if(dfn[x] == low[x]) { ++cnt1; while(true) { int now = d.top(); d.pop(); sccno[now] = cnt1; sd[now] = x; if(x == now) break; vall[x] += vall[now]; } }}void spfa() { dis[sd[s]] = vall[sd[s]]; q.push(sd[s]); while(!q.empty()) { int now = q.front(); q.pop(); vis[now] = false; for(int i = head2[now]; i; i = edge2[i].nextt) { int to = edge2[i].to, val = edge2[i].val; if(dis[to] &lt; dis[now] + val) { dis[to] = dis[now] + val; if(!vis[to]) { vis[to] = true; q.push(to); } } } } }int main() { n = read(); m = read(); for(int i = 1; i &lt;= m; i++) { u = read(); v = read(); addedge1(u, v); } for(int i = 1; i &lt;= n; i++) vall[i] = read(); for(int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i); } for(int i = 1; i &lt;= m; i++) { u = sd[edge1[i].u]; v = sd[edge1[i].to]; w = vall[v]; if(u == v) continue; addedge2(u, v, w); } s = read(); p = read(); spfa(); for(int i = 1; i &lt;= p; i++) { x = read(); ans = max(ans, dis[sd[x]]); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} Luogu 2002 消息扩散答案显然是缩点后入度为的点的个数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;const int MAXN = 100050;const int MAXM = 500500;using namespace std;stack&lt;int&gt; ss;int n, m, u, v, pos, num, num1, num2, cnt, cnt1, in[MAXN], head1[MAXN], head2[MAXN], low[MAXN], dfn[MAXN], sd[MAXN], sccno[MAXN];bool vis[5050][5050];struct Edge1 { int u, to, nextt;}edge1[MAXM];struct Edge2 { int u, to, nextt;}edge2[MAXM];int read() { int x = 0; bool sign = false; char alpha = 0; while(!isdigit(alpha)) { sign |= alpha == '-'; alpha = getchar(); } while(isdigit(alpha)) { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (alpha ^ 48); alpha = getchar(); } return sign ? -x : x;}void addedge1(int u, int v) { edge1[++num1].u = u; edge1[num1].to = v; edge1[num1].nextt = head1[u]; head1[u] = num1;}void addedge2(int u, int v) { edge2[++num2].u = u; edge2[num2].to = v; edge2[num2].nextt = head2[u]; head2[u] = num2;}void tarjan(int x) { dfn[x] = low[x] = ++cnt; ss.push(x); for(int i = head1[x]; i; i = edge1[i].nextt) { int to = edge1[i].to; if(!dfn[to]) { tarjan(to); low[x] = min(low[x], low[to]); } else if(!sccno[to]) low[x] = min(low[x], dfn[to]); } if(dfn[x] == low[x]) { ++cnt1; while(true) { int now = ss.top(); ss.pop(); sccno[now] = cnt1; sd[now] = cnt1; if(now == x) break; } }}int main() { n = read(); m = read(); for(int i = 1; i &lt;= m; i++) { u = read(); v = read(); if(u == v) continue; addedge1(u, v); } for(int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i); } for(int i = 1; i &lt;= num1; i++) { u = sd[edge1[i].u]; v = sd[edge1[i].to]; if(u == v) continue; in[v]++; addedge2(u, v); } for(int i = 1; i &lt;= cnt1; i++) { if(!in[i]) num++; } cout &lt;&lt; num &lt;&lt; endl; return 0;} Luogu 2746 Network of Schools第一问的答案显然是缩点后入度为的点的个数。 对于第二问，若存在出度为的点或者入度为的点则不满足条件。若把一个出度为的点与一个入度为的点连一条边，问题便迎刃而解。 考虑到两种点的个数不一定相同，选取其中的最大值即可。 记得判断是一个大环的情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;const int MAXN = 250000;using namespace std;struct Edge1 { int u, to, nextt;}edge1[MAXN &lt;&lt; 1];struct Edge2 { int u, to, nextt;}edge2[MAXN &lt;&lt; 1];stack&lt;int&gt; s;int n, u ,v, cnt, cnt1, ans1, num, num1, num2, head1[MAXN], head2[MAXN], dfn[MAXN], low[MAXN], sccno[MAXN], sd[MAXN], in[MAXN], out[MAXN];void addedge1(int u, int v) { edge1[++num1].u = u; edge1[num1].to = v; edge1[num1].nextt = head1[u]; head1[u] = num1;}void addedge2(int u, int v) { edge2[++num2].u = u; edge2[num2].to = v; edge2[num2].nextt = head2[u]; head2[u] = num2;}void tarjan(int x) { dfn[x] = low[x] = ++cnt; s.push(x); for(int i = head1[x]; i; i = edge1[i].nextt) { int to = edge1[i].to; if(!dfn[to]) { tarjan(to); low[x] = min(low[x], low[to]); } else if(!sccno[to]) low[x] = min(low[x], dfn[to]); } if(low[x] == dfn[x]) { ++cnt1; while(true) { int now = s.top(); s.pop(); sd[now] = cnt1; sccno[now] = cnt1; if(now == x) break; } }}int main() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { while(scanf(\"%d\", &amp;v) == 1) { if(v == 0) break; addedge1(i, v); } } for(int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i); } for(int i = 1; i &lt;= num1; i++) { u = sd[edge1[i].u]; v = sd[edge1[i].to]; if(u == v) continue; addedge2(u, v); in[v]++; out[u]++; } for(int i = 1; i &lt;= cnt1; i++) { if(in[i] == 0) ans1++; if(out[i] == 0) num++; } cout &lt;&lt; ans1 &lt;&lt; endl; if(cnt1 == 1) { cout &lt;&lt; \"0\" &lt;&lt; endl; return 0; } cout &lt;&lt; max(num, ans1) &lt;&lt; endl; return 0;} Luogu 2341 受欢迎的牛若出现个数 的出度为的强连通分量，则无解。 答案即为出度为的强连通分量的大小。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;const int MAXN = 10050;const int MAXM = 50050;using namespace std;stack&lt;int&gt; ss;int n, m, u, v, pos, num, num1, num2, cnt, cnt1, head1[MAXN], head2[MAXN], low[MAXN], dfn[MAXN], sd[MAXN], f[MAXN], sccno[MAXN];struct Edge1 { int u, to, nextt;}edge1[MAXM];struct Edge2 { int u, to, nextt;}edge2[MAXM];int read() { int x = 0; bool sign = false; char alpha = 0; while(!isdigit(alpha)) { sign |= alpha == '-'; alpha = getchar(); } while(isdigit(alpha)) { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (alpha ^ 48); alpha = getchar(); } return sign ? -x : x;}void addedge1(int u, int v) { edge1[++num1].u = u; edge1[num1].to = v; edge1[num1].nextt = head1[u]; head1[u] = num1;}void addedge2(int u, int v) { edge2[++num2].u = u; edge2[num2].to = v; edge2[num2].nextt = head2[u]; head2[u] = num2;}void tarjan(int x) { dfn[x] = low[x] = ++cnt; ss.push(x); for(int i = head1[x]; i; i = edge1[i].nextt) { int to = edge1[i].to; if(!dfn[to]) { tarjan(to); low[x] = min(low[x], low[to]); } else if(!sccno[to]) low[x] = min(low[x], dfn[to]); } if(dfn[x] == low[x]) { ++cnt1; while(true) { int now = ss.top(); ss.pop(); sccno[now] = cnt1; sd[now] = cnt1; f[cnt1] ++; if(now == x) break; } }}int main() { n = read(); m = read(); for(int i = 1; i &lt;= m; i++) { u = read(); v = read(); addedge1(u, v); } for(int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i); } for(int i = 1; i &lt;= m; i++) { u = sd[edge1[i].u]; v = sd[edge1[i].to]; if(u == v) continue; addedge2(u, v); } for(int i = 1; i &lt;= cnt1; i++) { if(!head2[i]) { pos = i; num++; } if(num == 2) { cout &lt;&lt; \"0\" &lt;&lt; endl; return 0; } } cout &lt;&lt; f[pos] &lt;&lt; endl; return 0;} Luogu 1262 间谍网络考虑无解的情况。若存在一个点既不能被贿赂，也没有入度，则不存在答案。 先缩点。对于现在没有入度且原先在强连通分量中的点，代价即为这些点中花费最小的值，累加即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;const int MAXN = 100050;const int INF = 1 &lt;&lt; 30;int n, m, u, v, p, num1, num2, cnt, cnt1, ans, in[MAXN], dfn[MAXN], low[MAXN], head1[MAXN], head2[MAXN], sccno[MAXN], val[MAXN], vall[MAXN], sd[MAXN];using namespace std;stack&lt;int&gt; s;struct Edge1 { int u, to, nextt;}edge1[MAXN];int read() { int x = 0; bool sign = false; char alpha = 0; while(!isdigit(alpha)) { sign |= alpha == '-'; alpha = getchar(); } while(isdigit(alpha)) { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (alpha ^ 48); alpha = getchar(); } return sign ? -x : x;}void addedge1(int u, int v) { edge1[++num1].u = u; edge1[num1].to = v; edge1[num1].nextt = head1[u]; head1[u] = num1;}void tarjan(int x) { dfn[x] = low[x] = ++cnt; s.push(x); for(int i = head1[x]; i; i = edge1[i].nextt) { int to = edge1[i].to; if(!dfn[to]) { tarjan(to); low[x] = min(low[x], low[to]); } else if(!sccno[to]) low[x] = min(low[x], dfn[to]); } if(dfn[x] == low[x]) { ++cnt1; while(true) { int now = s.top(); s.pop(); sd[now] = cnt1; sccno[now] = cnt1; vall[cnt1] = min(vall[cnt1], val[now]); if(now == x) break; } }}int main() { n = read(); p = read(); for(int i = 1; i &lt;= n; i++) val[i] = vall[i] = INF; for(int i = 1; i &lt;= p; i++) { u = read(); val[u] = read(); } m = read(); for(int i = 1; i &lt;= m; i++) { u = read(); v = read(); in[v]++; addedge1(u, v); } for(int i = 1; i &lt;= n; i++) { if(val[i] == INF &amp;&amp; in[i] == 0) { cout &lt;&lt; \"NO\" &lt;&lt; endl &lt;&lt; i &lt;&lt; endl; return 0; } } for(int i = 1; i &lt;= n; i++) { if(!dfn[i] &amp;&amp; val[i] != INF) tarjan(i); } for(int i = 1; i &lt;= n; i++) in[i] = 0; for(int i = 1; i &lt;= num1; i++) { u = sd[edge1[i].u]; v = sd[edge1[i].to]; if(u == v) continue; in[v]++; } for(int i = 1; i &lt;= cnt1; i++) { if(in[i] == 0) ans += vall[i]; } cout &lt;&lt; \"YES\" &lt;&lt; endl &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/07/26/tarjan%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-BeyondLimits/"},{"title":"2019THU创客营游记","text":"Day 0昨天刚刚经历了第一次月考，上午经历了惨痛的试卷讲评，内心压抑QAQ… 通知的中午在一中后门集合，于是上午上了4节课后就跑回家拿行李箱去了…还好没迟到… 做着一辆超载的别克商务车，前往地窝堡国际机场。 在车上认识了一些高二的学长，聊的还挺开心。 到机场后终于看到了许多熟悉的小伙伴，总算不是那么的孤独尴尬了… 候机中： 因为去的时候没有坐在靠窗户的位置，因此没有拍照。 许久没有做过飞机了，这种久违的感觉很奇妙。 飞机餐是牛肉米饭，挺烫的，味道不错。 4个小时，看了一部不错的电影，写了一会代码，读了一会书，就这样度过了。 飞机下降时，感到自己的眉骨附近疼的要命，难受万分。下飞机后查了一下说是什么航空性鼻窦炎…因为自己之前也一直在感冒，后面不疼了也就没管了。 Arrived. 到了北京，感觉温度和这边其实差距不大，晚上吹着微风，还挺舒服。 做了1个小时的大巴，写了一个小时的代码，度过了这无聊的时间。 夜宵+早餐： 双人间，和我住一起的刚好是我在去机场路上认识的一个高二的，至少没那么尴尬啦。 当时没什么食欲，没吃什么东西就准备睡了，结果室友和他的朋友点了麦当劳的外卖，顿时饿了… Day 1清晨的北京： 很早就起床，前往清华大学。 昨晚没睡好，在车上一直睡… 街景： 到达李兆基科技大楼 然后就是抽签分组，签名墙留名。 会场： 之前看到好多妹子，想着我们这一组应该…男女比例正常… 结果…四个男的… 还有一些奇葩的：szy他们组只有他一个男的等等 果然抽签的方式…哎… 开营仪式：","link":"/2019/04/27/2019THU%E5%88%9B%E5%AE%A2%E8%90%A5%E6%B8%B8%E8%AE%B0-updating-BeyondLimits/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSP 认证","slug":"CSP-认证","link":"/tags/CSP-%E8%AE%A4%E8%AF%81/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"微机原理","slug":"微机原理","link":"/tags/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"},{"name":"汇编语言","slug":"汇编语言","link":"/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"关系数据库","slug":"关系数据库","link":"/tags/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"抽象代数","slug":"抽象代数","link":"/tags/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/"},{"name":"群论","slug":"群论","link":"/tags/%E7%BE%A4%E8%AE%BA/"},{"name":"加缪手记","slug":"加缪手记","link":"/tags/%E5%8A%A0%E7%BC%AA%E6%89%8B%E8%AE%B0/"},{"name":"摘抄","slug":"摘抄","link":"/tags/%E6%91%98%E6%8A%84/"},{"name":"构造","slug":"构造","link":"/tags/%E6%9E%84%E9%80%A0/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二进制枚举","slug":"二进制枚举","link":"/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"状态压缩","slug":"状态压缩","link":"/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"思维","slug":"思维","link":"/tags/%E6%80%9D%E7%BB%B4/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"差分","slug":"差分","link":"/tags/%E5%B7%AE%E5%88%86/"},{"name":"哈希","slug":"哈希","link":"/tags/%E5%93%88%E5%B8%8C/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"生物学","slug":"生物学","link":"/tags/%E7%94%9F%E7%89%A9%E5%AD%A6/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"专业知识","slug":"专业知识","link":"/categories/%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"算法竞赛","slug":"算法竞赛","link":"/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"编程学习","slug":"编程学习","link":"/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}