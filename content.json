{"posts":[{"title":"About me","text":"今年大三，西安电子科技大学-计算机科学与技术专业在读。这个博客主要是用于记录自己学习生涯中的笔记、平时阅读到好书好句时的一些摘抄、以及一些随笔。后期可能会上传一些自己的摄影作品。希望自己能做一个万物学徒，一个一直在思考的人。","link":"/2023/09/01/About%20me/"},{"title":"微机原理笔记 - chap3 - Intel处理器指令系统及汇编语言","text":"汇编语言基础数据定义： 数据传送、算术运算、跳转指令MOV 指令“先目的操作数，再源操作数。” MOV 指令需要遵循的规则： 两个操作数的尺寸必须一致。 两个操作数不能同时为内存操作数。 1234567mov reg, regmov mem, regmov reg, memmov mem, immmov reg, immmov var2, var1 ;不合法，需要用寄存器来实现 目的操作数不能是 CS，EIP 和 IP。 立即数不能直接送至段寄存器。 XCHG 指令用来交换两个操作数的内容。 123xchg reg, regxchg reg, memxchg mem, reg 若要交换两个内存操作数，还是需要利用寄存器，即 MOV 与 XCHG 结合使用。 INC 和 DEC 指令分别实现加 1 与减 1 操作。 12inc reg/memdec reg/mem ADD 和 SUB 指令ADD 将同尺寸的源操作数和目的操作数相加，结果在目的操作数中（不改变源操作数）。 SUB 将源操作数从目的操作数中减掉，结果在目的操作数中（不改变源操作数） 两者都同 MOV 指令一样，先目的操作数，再源操作数。 1234567.datavar1 DWORD 20000hvar2 DWORD 10000h.codemov eax, var1add eax, var2 ;30000hsub eax, var2 ;20000h NEG 指令认为操作数是有符号数，形式是补码。该指令将操作数按位取反、末位加 1。 算术运算影响的标志 零标志位 ZF 12345mov cx, 1sub cx, 1 ; ZF = 1mov ax, 0FFFFh ; 全1理解成补码，真值就是-1inc ax ; ZF = 1inc ax ; ZF = 0 符号标志位 SF 123mov cx,0sub cx,1 ; SF = 1add cx,2 ; SF = 0 进位标志位 CF 1234567891011mov al,0FFhadd al,1 ; CF = 1mov ax,00FFhadd ax,1 ; CF = 0mov ax,0FFFFhadd ax,1 ; CF = 1mov al,1sub al,2 ; CF = 1。最高位向更高位有进位或借位时置1 溢出标识位 OF 其中 是符号位产生的进位，即标志位 CF； 是最高有效位向符号位产生的进位。 1234567891011mov al,+127add al,1 ; OF = 1mov al,-128sub al,1 ; OF = 1mov al,-128 ; AL = 10000000bneg al ; AL = 10000000b, OF = 1mov al,+127 ; AL = 01111111bneg al ; AL = 10000001b, OF = 1 JMP 和 LOOP 指令JMP ：无条件转移 12345top: jmp top ;repeat the endless loop LOOP ：条件转移 1234567mov ax,0mov ecx,5L1: inc axloop L1;循环体的第一条指令必须要给标号。循环体的最后一条指令要用loop，后面跟这个标号 ;循环结束时，AX=5 ECX=0 过程 条件处理AND 指令 与 OR 指令1AND / OR 目的操作数 源操作数 两个操作数可以是8、16 或 32位的，但它们的尺寸必须相同。影响的标志位：总是清除 OF 和 CF，根据结果修改 SF、ZF、PF。 AND 指令应用： OR 指令应用： NOT 指令将操作数所有数据位取反，结果为反码。 12mov al,11110000bnot al ; AL = 00001111b 条件跳转指令 整数算数指令移位指令 乘法和除法指令 字符串和数组基址变址 (base-index) 操作数：将两个寄存器的值相加(称为基址寄存器、变址寄存器)来产生偏移地址。保护模式程序中，可使用任意32位通用寄存器。 宏 使用I/O端口控制硬件x86属于独立编址，要访问接口地址空间只能用 IN 指令 和 OUT 指令。不管是8086还是32位、64位的CPU，接口地址都是16位的，端口地址范围为0~FFFFh。 32/64位处理器扩展指令 —— 多媒体/流媒体SIMD扩展指令集Pentium II：引入 MMX 指令集，实现64位并行处理。Pentium III：引入 SSE 指令集，实现128位并行浮点运算。Pentium 4：引入 SSE2 指令集，实现128位并行定点运算。","link":"/2023/10/19/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0-chap3-Intel%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E5%8F%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"title":"微机原理笔记 - chap2 - Intel单核&#x2F;多核处理器","text":"单核处理器（8086/8088）8086/8088 功能特性第一次将流水线思想引进微处理器：指令级流水。存储器分段管理机制引入处理器，扩大寻址能力。 内存地址分段：寄存器最多存 16 位，故有些寄存器用来当段寄存器，代表着地址的高 16 位（低 4 位默认为 0 ）。再加上段内偏移寄存器的值（低 16 位），就可以实现 1MB 的内存寻址。 接口数量不会很多，所以地址不用分段。 8086/8088 体系结构 地址加法器的意义：避免结构冒险，保证计算地址和计算数据可以并行。 总线接口单元 BIU ：取指令，取数据，送数据。执行单元 EU ：执行指令。BIU 与 EU 相互独立，相互配合。 寄存器 在 14 个寄存器中，只有 A～DX 既可以当作 16 位寄存器，也可以当作 8 位寄存器。 除了当通用寄存器，BX 可以当作指针，用来寄存器间接寻址，即 [BX]。（ [AX], [CX], [DX] 都是不合法的写法） 访问堆栈的时候可以用 BP（基址指针寄存器）来间接寻址，读/写堆栈里面任何位置的数据，同时不会破坏栈的结构（不会影响栈顶当前的位置）。 标志寄存器AF：辅助进位标志位，加法时若 向 有进位， AF 置 1 。CF：进位/借位标志位，若加法时最高位向更高位有进位 或 减法时最高位向更高位有借位， CF 置 1 。PF：奇偶标志位，若运算结果低八位中 1 的个数是偶数，PF 置 1 。SF：符号标志位，反映运算结果的最高位，最高位是什么 SF 就是什么。ZF：零标志位，若运算结果为 0 ， ZF 置 1 。OF：溢出标志位，若运算结果溢出， OF 置 1 。","link":"/2023/10/19/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0-chap2-Intel%E5%8D%95%E6%A0%B8:%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/"},{"title":"微机原理笔记 - chap1 - 绪论","text":"Intel微处理器的发展 1978年：8086/8088微处理器出现，首枚16位微处理器。 微型计算机概述计算机加电以后，首先运行 BIOS(Basic Input Output System) 系统，进行硬件的检查、初始化（加电时寄存器的内容是随机的）、给操作系统提供编程接口等。 通过硬件驱动程序、BIOS / UEFI 提供的编程接口，操作系统可以访问硬件。从而实现两台硬件层面不同的计算机可以安装相同的操作系统.","link":"/2023/10/19/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0-chap1-%E7%BB%AA%E8%AE%BA/"},{"title":"数据库系统笔记 - chap3 - SQL","text":"Introduction to SQLSQL（Structured Query Language），是关系数据库的标准查询语言。 SQL 的特点： 综合统一SQL 集数据定义语言（DDL），数据操纵语言（DML），数据控制语言 （DCL）功能于一体。 高度非过程化 SQL 只要提出“做什么”，而无须指明“怎么做”，因此无须了解存取路径。存取路径的选择以及 SQL 的操作过程由系统自动完成。 面向集合的操作方式SQL 采用集合操作方式，不仅操作对象、查找结果可以是元组的集合，而且一次插入、删除、更新操作的对象也可以是元组的集合。 以同一种语法结构提供多种使用方式 SQL 是独立的语言，能够独立地用于联机交互的使用方式。同时 SQL 也是嵌入式语言，能够嵌入到高级语言（例如 C，C++，Java）程序中，供程序员设计程序时使用。 在两种不同的方式下， SQL 的语法结构基本上是一致的。 支持 SQL 的关系数据库管理系统同样支持关系数据库三级模式结构，如下图所示。其中外模式包含若干视图（view）和部分基本表（base table），模式包括若干基本表，内模式包括若干存储文件（stored file）。 基本表是本身独立存在的表，在关系数据库管理系统中一个关系就对应一个基本表。一个或多个基本表对应一个存储文件，一个表可以带若干索引，索引也存放在存储文件中。 存储文件的逻辑结构组成了关系数据库的内模式。存储文件的物理结构对最终用户是隐蔽的。 视图是从一个或几个基本表导出的表。它本身不独立存储在数据库中，即数据库中只存放视图的定义而不存放视图对应的数据。这些数据仍存放在导出视图的基本表中，因此视图是一个虚表。视图在概念上与基本表等同，用户可以在视图上再定义视图。 数据定义CREATE 创建，DROP 删除，ALTER 修改（只有表和索引有这项）。 模式（SCHEMA）定义模式（CREATE SCHEMA）12CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;;/* 如果没有指定模式名，则模式名隐含为用户名 */ 为用户 CHEN 定义一个学生-课程模式 S-T。 1CREATE SCHEMA \"S-T\" AUTHORIZATION CHEN; 删除模式（DROP SCHEMA）1DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;; /* CASCADE 和 RESTRICT 两者必选其一 */ CASCADE（级联）：删除模式的同时把该模式中所有的数据库对象全部删除。RESTRICT（限制）：如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。仅当该模式中没有任何下属的对象时才能执行。 基本表（TABLE）定义基本表（CREATE TABLE） 建立一个学生信息表 Student。 1234567CREATE TABLE Student ( Sno CHAR(9) PRIMARY KEY, Sname CHAR(20) UNIQUE, Ssex CHAR(2), Sage SMALLINT， Sdept CHAR(20)); 建立一个学生选课表 SC 。 12345678CREATE TABLE SC ( Sno CHAR(9), Cno CHAR(4), Grade SMALLINT, PRIMARY KEY (Sno,Cno), /* 主码由两个属性构成，必须作为表级完整性进行定义 */ FOREIGN KEY (Sno) REFERENCES Student(Sno), /* 表级完整性约束条件 */ FOREIGN KEY (Cno) REFERENCES Course(Cno) /* 表级完整性约束条件 */); 如果完整性约束条件涉及该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级。 删除基本表（DROP TABLE）1DROP TABLE &lt;表名&gt; [RESTRICT | CASCADE]; CASCADE（级联）：删除该表没有限制条件。在删除基本表的同时，相关的依赖对象都将被一起删除。RESTRICT（限制）：删除该表是有限制条件的。欲删除的基本表不能被其他表的约束所引用（如 CHECK ， FOREIGN KEY 等约束），不能有视图、触发器、存储过程或函数等。如果存在依赖该表的对象，则此表不能被删除。 若表上建有视图，选择 RESTRICT 时表不能删除；选择 CASCADE 时可以删除表，视图也自动被删除。 12345678CREATE VIEW IS_StudentASSELECT Sno,Sname,SageFROM StudentWHERE Sdept='IS';DROP TABLE Student CASCADE;/* DROP TABLE Student RESTRICT; 会返回 Error */ 修改基本表（ALTER TABLE）12345678ALTER TABLE &lt;表名&gt;[ADD [COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [完整性约束]] [ADD &lt;表级完整性约束&gt;][DROP [COLUMN] &lt;列名&gt; [CASCADE| RESTRICT]][DROP CONSTRAINT &lt;完整性约束名&gt; [RESTRICT | CASCADE]][ALTER COLUMN &lt;列名&gt; &lt;数据类型&gt;]; ADD 子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件。 DROP COLUMN 子句用于删除表中的列，如果指定了 CASCADE 短语，则自动删除引用了该列的其他对象；如果指定了 RESTRICT 短语，则如果该列被其他对象引用，关系数据库管理系统将拒绝删除该列。 DROP CONSTRAINT 子句用于删除指定的完整性约束条件。 ALTER COLUMN 子句用于修改原有的列定义，包括修改列名和数据类型。 向 Student 表增加“入学时间”列，其数据类型为日期型。 1ALTER TABLE Student ADD S_entrance DATE; 将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数。 1ALTER TABLE Student ALTER COLUMN Sage INT; 增加课程名称必须取唯一值的约束条件。 1ALTER TABLE Course ADD UNIQUE(Cname); 模式与表每一个基本表都属于某一个模式，一个模式包含多个基本表。 定义基本表所属模式的三种方法： 在表名中明显地给出模式名。 1CREATE TABLE \"S-T\".Student(...); /* Student 所属的模式是 S-T */ 在创建模式语句中同时创建表。 12345678910/* 为用户 ZHANG 创建一个模式 TEST，并且在其中定义一个表 TAB1。 */CREATE SCHEMA TEST AUTHORIZATION ZHANGCREATE TABLE TAB1 ( COL1 SMALLINT, COL2 INT, COL3 CHAR(20), COL4 NUMERIC(10,3), COL5 DECIMAL(5,2)); 设置所属的模式，这样在创建表时表名中不必给出模式名。 索引（INDEX） WAITING TO BE UPDATED. 建立索引（CREATE INDEX）删除索引（DROP INDEX）修改索引（ALTER INDEX）数据查询单表查询只涉及一个表的查询叫做单表查询。 选择表中的若干列查询某个表的全部列： 1SELECT * FROM STUDENT; 查询某个表的部分列，列显示的具体顺序可以自定义： 1SELECT Sname, Sno FROM Student; 目标列表达式 不仅可以是算术表达式，还可以是字符串常量、函数等： 1SELECT Sname, 2021 - Sage FROM Student; 选择表中的若干元组消除取值重复的行：DISTINCT： 1SELECT DISTINCT Sno FROM SC; 查询满足条件的元组：WHERE 子句： 查询所有年龄在 20 岁以下的学生姓名及其年龄。 1SELECT Sname, Sage FROM Student WHERE Sage &lt; 20; 查询年龄不在 20~23 岁之间的学生姓名、系别和年龄。 1SELECT Sname, Sdept, Sage FROM Student WHERE Sage NOT BETWEEN 20 AND 23; 查询不是计算机科学系、数学系和信息系学生的姓名和性别。 1SELECT Sname, Ssex FROM Student WHERE Sdept NOT IN ('CS', 'MA', 'IS'); 查询所有有成绩的学生学号和课程号。 1SELECT Sno, Cno FROM SC WHERE Grade IS NOT NULL; /* `is NULL` 不能用 `= NULL` 代替 */ 查询计算机科学系年龄在 20 岁以下的学生姓名。 1SELECT Sname FROM Student WHERE Sdept = 'CS' AND Sage &lt; 20; /* AND 优先级比 OR 高，可用括号来改变优先级 */ 字符匹配 1[NOT] LIKE '&lt;匹配串&gt;' [ESCAPE '&lt;换码字符&gt;'] 其含义是查找指定的属性列值与 &lt;匹配串&gt; 相匹配的元组。&lt;匹配串&gt; 可以是一个完整的字符串，也可以含有通配符 % 和 _。 % 代表任意长度（长度可以为 0 ）的字符串。 e.g. a%b 表示以 a 开头，以 b 结尾的任意长度的字符串。 _ 代表任意单个字符。 e.g. a_b 表示以 a 开头，以 b 结尾的长度为 3 的任意字符串。 查询所有姓刘的学生的姓名、学号和性别。 1SELECT Sname, Sno, Ssex FROM Student WHERE Sname LIKE '刘%'; 查询姓 欧阳 且全名为三个汉字的学生的姓名。 1SELECT Sname FROM Student WHERE Sname LIKE '欧阳_'; 如果用户要查询的字符串本身就含有通配符 % 或 _ ，这时就要使用 ESCAPE &lt;换码字符&gt; 短语对通配符进行转义。 查询 DB_Design 课程的课程号和学分。 1SELECT Cno, Ccredit FROM Course WHERE Cname LIKE 'DB\\_Design' ESCAPE '\\'; ORDER BY 子句ORDER BY 子句可以对查询结果按照一个或多个属性列的升序(ASC)或降序(DESC)排列，默认值为升序。空值按最大值来参与排序。 查询选修了 3 号课程的学生的学号及其成绩，查询结果按分数的降序排列： 1SELECT Sno, Grade FROM SC WHERE Cno = '3' ORDER BY Grade DESC; 聚集函数为了进一步方便用户，增强检索功能，SQL 提供了许多聚集函数。 统计元组个数： COUNT(*) 统计一列中值的个数： COUNT([DISTINCT | ALL] &lt;列名&gt;) 计算一列值的总和（此列必须为数值型）： SUM([DISTINCT | ALL] &lt;列名&gt;) 计算一列值的平均值（此列必须为数值型）： AVG([DISTINCT | ALL] &lt;列名&gt;) 求一列中的最大值和最小值： MAX([DISTINCT | ALL] &lt;列名&gt;), MIN([DISTINCT | ALL] &lt;列名&gt;) 聚集函数只能用于 SELECT 子句和 GROUP BY 中的 HAVING 子句。 查询学生总人数。 1SELECT COUNT(*) FROM Student; 查询选修了课程的学生人数。 1SELECT COUNT(DISTINCT Sno) FROM SC; 计算选修 1 号课程的学生平均成绩。 1SELECT AVG(Grade) FROM SC WHERE Cno = '1'; 查询选修 1 号课程的学生最高分数。 1SELECT MAX(Grade) FROM SC WHERE Cno='1'; 查询学生 201215012 选修课程的总学分数。 1SELECT SUM(Ccredit) FROM SC, Course WHERE Sno = '201215012' AND SC.Cno = Course.Cno; GROUP BY 子句GROUP BY 子句将查询结果按某一列或多列的值分组，值相等的为一组。 将查询结果分组的目的是细化聚集函数的作用对象。如果未对查询结果分组，聚集函数将作用于整个查询结果。对查询结果分组后，聚集函数将分别作用于每个组，即每一组都有一个函数值。 查询平均成绩大于等于 90 分的学生学号和平均成绩。 1SELECT Sno, AVG(Grade) FROM SC GROUP BY Sno HAVING AVG(Grade) &gt;= 90; 连接查询若一个查询同时涉及两个以上的表，称为连接查询。连接查询是关系数据库中最主要的查询。 等值与非等值连接查询1[&lt;表名1&gt;.]&lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;.]&lt;列名2&gt; 查询每个学生及其选修课程的情况。 123SELECT Student.*, SC.*FROM Student, SCWHERE Student.Sno = SC.Sno; /* 将 Student 与 SC 中同一学生的元组连接起来 */ 自身连接一个表与其自己进行连接，称为表的自身连接。需要给表起别名以示区别。且由于所有属性名都是同名属性，因此必须使用别名前缀。 查询每一门课的间接先修课（即先修课的先修课）。 123SELECT FIRST.Cno, SECOND.CpnoFROM Course FIRST, Course SECONDWHERE FIRST.Cpno = SECOND.Cno; 外连接普通连接操作只输出满足连接条件的元组，而外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出。左外连接列出左边关系中所有的元组，右外连接列出右边关系中所有的元组。 使用外连接查询每个学生及其选修课程的情况。 12SELECT Student.Sno, Sname, Ssex, Sage, Sdept, Cno, GradeFROM Student LEFT OUTER JOIN SC ON (Student.Sno = SC.Sno); 多表连接两个以上的表进行连接称为多表连接。 查询每个学生的学号、姓名、选修的课程名及成绩。 123SELECT Student.Sno,Sname,Cname,Grade FROM Student,SC,CourseWHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno 关系数据库管理系统在执行多表连接时，通常是先进行两个表的连接操作，再将其连接结果与第三个表进行连接。 嵌套查询一个 SELECT-FROM-WHERE 语句称为一个查询块。嵌套查询是指将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中的查询。 123456SELECT Sname /* 外层查询或父查询 */FROM StudentWHERE Sno IN ( SELECT Sno /* 内层查询或子查询 */ FROM SC WHERE Cno='2') 子查询的 SELECT 语句不能使用 ORDER BY 子句，ORDER BY 子句只能对最终查询结果排序。 不相关子查询：子查询的查询条件不依赖于父查询，即由里向外逐层处理。相关子查询：子查询的查询条件依赖于父查询。 带有 IN 谓词的子查询在嵌套查询中，子查询的结果往往是一个集合，所以谓词 IN 是嵌套查询中最经常使用的谓词。 查询与 刘晨 在同一个系学习的学生。 1234567SELECT Sno, Sname, SdeptFROM StudentWHERE Sdept IN ( SELECT Sdept FROM Student WHERE Sname='刘晨') 也可以用自身连接来完成： 123SELECT S1.Sno, S1.Sname, S1.SdeptFROM Student S1, Student S2WHERE S1.Sdept = S2.Sdept AND S2.Sname = '刘晨'; 带有比较运算符的子查询 找出每个学生超过他自己选修课程平均成绩的课程号。 1234567SELECT Sno, CnoFROM SC x /* x 是表SC的别名，又称为元组变量，可以用来表示SC的一个元组 */WHERE Grade &gt;= ( SELECT AVG(Grade) FROM SC y WHERE y.Sno = x.Sno); 带有 ANY（SOME）或 ALL 谓词的子查询","link":"/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-chap3-SQL/"},{"title":"数据库系统笔记 - chap2 - 关系模型","text":"关系数据结构 关系代数A set of fundamental operations to retrieve and manipulate tuples in a relation. These operations take one or some relations as inputs, and outputs a new relation. 并、交、差、笛卡尔积与集合运算相似。 选择（Select）行视角，选择出符合条件的若干元祖集合。 符号: 举例: SQL写法: SELECT * FROM R WHERE Name = 'qaq' 投影（Projection）列视角，选择出若干属性列组成新的关系。 符号: 举例: SQL写法: SELECT Name, id FROM R WHERE Name = 'qaq' 投影运算会把新关系中的重复行删去（集合的不可重原则）。 连接（Join） 符号: 其中 是 与 上的度数相等且可比较的属性组， 是比较运算符。SQL: SELECT * FROM R JOIN S USING (ATTRIBUTE1, ATTRIBUTE2, ...) 若 为 ，则叫做等值连接。自然连接是一种特殊的等值连接，只不过是在等值连接的基础上去掉结果中重复的属性列。 关系的完整性关系的完整性约束是对关系正确性的限定。关系的完整性分为实体完整性、参照完整性和用户定义完整性。 实体完整性由于主码 Primary Key 是区分实体的唯一性标识，所以关系 的主码不能取空值 NULL （若主码由多个属性构成，则所有这些属性都不能取空值）。 12345678910111213141516171819CREATE TABLE Student ( Sno CHAR(9) PRIMARY KEY, // 列级 Sname CHAR(8), Ssex CHAR(2) CHECK(Ssex IN ('男', '女')),);CREATE TABLE Student ( Sno CHAR(9), Sname CHAR(8), Ssex CHAR(2) CHECK(Ssex IN ('男', '女')), PRIMARY KEY (Sno) // 表级);CREATE TABLE SC ( Sno CHAR(5), Cno CHAR(3), Grade int, PRIMARY KEY (Sno, Cno) // 表级，且只能是表级); 参照完整性参照完整性定义了外码 Foreign Key 与主码之间的引用规则，即外码的取值要么是 NULL （若外码包含多个属性，则这些属性的值均取 NULL ；但假如外码中的属性是主属性，则不能取 NULL ），要么是被参照关系中某元组在该属性的取值。（“你从别人那里引用到的任何值，别人得有才能给你引用”） 12345678CREATE TABLE SC ( Sno CHAR(5), Cno CHAR(3), Grade int, PRIMARY KEY (Sno, Cno), // 表级定义实体完整性 FOREIGN KEY (Sno) REFERENCES S(Sno), //表级定义参照完整性 FOREIGN KEY (Cno) REFERENCES C(Cno) //表级定义参照完整性); 用户定义完整性用户规定数据必须满足的一系列要求，包括属性上的约束与元组上的约束。 属性上的约束123456CREATE TABLE SC ( Sno CHAR(5) NOT NULL // 约束 Sno 非空 Cno CHAR(9) UNIQUE NOT NULL, // 约束 Cno 唯一且非空 Age SMALLINT CHECK (Age &gt;= 18 AND Age &lt;= 23), // 约束 Age 的范围在 [18, 23] 之间 PRIMARY KEY (Sno, Cno),); 元组上的约束可以在元组层面上限制不同属性之间的取值以及相互约束关系。 123456789CREATE TABLE Student( Sno CHAR(9), Sname CHAR(8) NOT NULL, Ssex CHAR(2), Sage SMALLINT, Sdept CHAR(20), PRIMARY KEY (Sno), CHECK (Ssex='女' OR Sname NOT LIKE 'Ms.%') // 约束了学生性别为男时，其名字不能以 Ms. 开头); 完整性约束命名子句1CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt; &lt;完整性约束条件&gt; 包括 NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK 短语等。 123456789101112CREATE TABLE Student( Sno NUMERIC(6) CONSTRAINT C1 CHECK (Sno BETWEEN 90000 AND 99999), Sname CHAR(20) CONSTRAINT C2 NOT NULL, Sage NUMERIC(3) CONSTRAINT C3 CHECK (Sage &lt; 30), Ssex CHAR(2) CONSTRAINT C4 CHECK (Ssex IN ('男','女')), CONSTRAINT StudentKey PRIMARY KEY(Sno), CONSTRAINT SnameKey FOREIGN KEY(Sname) REFERENCES C(Sname));","link":"/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-chap2-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/"},{"title":"数据库系统笔记 - chap1 - 绪论","text":"数据库发展史人工管理阶段（1950） 文件系统阶段（1950-1960） 数据库系统阶段（1960-） 数据库管理系统（DBMS）的出现，使得数据存储、数据管理和数据应用分离。数据库管理系统采用外模式-模式-内模式的三级模式，外模式/模式和模式/内模式的两级映象结构。 数据模型定义：是数据及其联系在计算机中的表示和组织形式的描述。组成三要素：数据结构，数据操纵，数据完整性约束。经典模型：层次模型（有根树），网状模型（有向图），关系模型。","link":"/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-chap1-%E7%BB%AA%E8%AE%BA/"},{"title":"JavaScript学习笔记","text":"Brief Syntax Introduction JS 是解释型语言。 解释型语言 与 编译型语言： 解释型：一行一行看，容易出错但方便，可以及时方便地找到出错位置以及出错原因，容易跨平台（可以嵌入到其他软件）。编译型：把高级语言预先翻译成机器语言，并把结果保存下来，速度快（编译器优化），不易出错，但不能跨平台（e.g. .exe can’t be run in MacOS)。 行末分号非必需： JS 中的每一行都可以选择使用分号终止，即编译器会自动补全没有用分号的地方。 JS 中的变量是弱类型的，即变量的类型只有在被赋值的时候才得到确认。 数据类型与变量 const 用来申明常量（一旦声明后续值不可更改），let 用来申明变量（一个变量只能申明一次，值以及值的类型可以被多次更改）。 JS 中允许一个变量未被提前申明就使用。此时该变量会被自动被申明为全局变量。若在程序的最开始加上 use strict 语句，则可以避免这支双刃剑带来的弊端。（在 strict 模式下，变量必须要先经过申明，才能被使用，否则会报错） JS 中的基本类型有数字、字符串、布尔值、符号、null 和 undefined。数字中不区分整数和浮点数。 JS 中遇到计算除法时除数为 0 的情况时，不会报错，会根据被除数的值来返回对应的结果。若被除数是正数，则返回 Infinity ；若被除数是负数，则返回 -Infinity；若被除数是 0 ，则返回 NaN (Not a Number)。除以 0 的余数（1 % 0）为 NaN 。 与 python 类似， JS 中一个 * 代表相乘， ** 则代表幂运算。 JS 中 === 表示检查是否相等，!== 表示检查是否不等。 字符串 JS 中的字符串用 '' 或 &quot;&quot; 括起来表示。若想表达的字符串中本身含有 ' 或 &quot;，则需要用到转义字符。e.g. I'm &quot;OK&quot;! 的表示是： 1'I\\'m \\&quot;OK\\&quot;!'; 在 JS 中输出多行字符串的方式是用反引号。e.g. 1234`No \\nanymore`; 与 python 类似，要把多个字符串连接起来，可以用 + 号连接。也可以通过模版字符串的方式来方便输出过程。（反引号与 ${} 的结合） 12345let name = '小明';let age = 20;let message1 = '你好, ' + name + ', 你今年' + age + '岁了!';let message2 = `你好, ${name}, 你今年${age}岁了!`//message1 = message2 JS 中的字符串是不可变的，即不能通过 s[id] = 'A' 的方式来将 s 中 id 位置的字母改成 A 。 JS 中有很多类似 python 和 C++ STL 中的字符串函数，如 toUpperCase，indexOf（搜索元素在数据结构中出现的位置，未找到则返回 -1），substring 等。 数组 JS 中的数组可以包含任意数据类型，并通过索引来访问/修改每个元素。 123a = [1, 'hello, world', ['a', b, 100]];a[0] = 'qaq';a; // a = ['qaq', 'hello, world', ['a', b, 100]] 在 JS 中允许给数组的 length 赋一个新值。除此之外，假如进行了数组的越界访问，也不会报错。 12345678var arr = [1, 2, 3];arr.length = 6;arr; // arr 变为 [1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2]arr[4] = 'qaq';arr; // arr 变为 [1, 2, undefined, undefined, 'qaq'] 同 python 的切片类似，slice() 可以将一个数组的局部“拿出来”，变成一个新的数组。 12345var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']var aCopy = arr.slice();aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G'] 如果要在数组的头部添加若干元素，可以使用 unshift() ; shift() 则可以用来把数组的第一个元素删除。splice() 则可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素。 12345678var arr = [1, 2, 3, 4];arr.unshift('A', 'B'); // 返回Array新的长度: 6arr; // ['A', 'B', 1, 2, 3, 4]arr.shift(); // 'A'arr; // ['B', 1, 2, 3, 4]// 从索引 1 开始删除 3 个元素,然后再添加 2 个元素:arr.splice(1, 3, 'qaq', 222); // 返回删除的元素 [1, 2, 3]arr; // ['B', 4, 'qaq', 222] 如果要在数组的尾部添加/删除若干元素，可以使用 push() 和 pop()。 123456789var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] 对象在 JS 中，对象是一种无序的集合数据类型，由若干键值对组成。用法与 python 中的 dictionary 很像。但 JS 对象的键必须是字符串，值可以是任意数据类型。这一点和 dictionary 对键和值类型的无限制不同（ JS 中 Map 的引入解决了这个问题）。 12345678var xiaoming = { name: 'Yiling Zhang', birth: 2003, school: 'Xidian University', height: 1.77, weight: 65, score: 100}; 函数函数的定义与调用123456789101112function get_pow(x, y) { var res = 1, i; for (i = 1; i &lt;= y; i++) res = res * x; return res;}var get_pow = function (x, y) { var res = 1, i; for (i = 1; i &lt;= y; i++) res = res * x; return res;};//匿名函数，在 JS 中函数也可以作为变量，通过这个变量就可以调用该函数。 传入函数的多个变量以逗号分隔开。如果传入某个函数的变量的个数，比该函数预先设定的要多，程序仍然会返回正确的结果，且不会报错。如果要少，则不会报错，但是结果可能不正确。 在函数的内部，系统提供了关键字 arguments。该关键字只在函数内部起作用，通过该参数可以访问到传入该函数的所有参数。可以通过访问 arguments.length() 来获取到传入某个函数的参数的个数。 12345678910function abs() { if (arguments.length() == 0) return 0; else { var x = arguments[0]; return x &gt;= 0 ? x : -x; }}abs(); // 0abs(-2, 1); // 2 变量作用域与解构赋值局部作用域、块级作用域若在函数内部用 var 申明变量，则该变量的作用域是该函数内部，即这是一个局部变量。 在 JS 中允许函数的嵌套，即某个函数内可以定义另一个函数。同时允许内函数和外函数中定义重名的变量。 函数在查找变量时从自身函数定义开始，从内向外查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。 123456789use strict;function f() { var x = 1; function g() { var x = 2; x; // x = 2 } x; // x = 1} 在函数内部中用 var 申明一个变量，该变量会在整个函数中都起作用，不具有块级作用域。用 let 来申明则不会有这种问题，新申明的变量会具有块级作用域。 1234567891011function f() { var sum = 0; for (var i = 0; i &lt; 100; i++) sum += i; i++; // 仍然可以使用在上一个循环内定义的i}function f() { var sum = 0; for (let i = 0; i &lt; 100; i++) sum += i; i++; // SyntaxError （与在c++中的逻辑一样）} 请严格遵守在函数内部首先申明所有变量这一规则！否则会出一些奇奇怪怪的错误。 全局作用域不在任何函数内定义的变量就具有全局作用域。 JS 默认有一个全局对象window ，全局作用域的变量（变量、函数等）实际上被绑定到 window 的一个属性。 123var x = 1;alert(x); // 1alert(windows.x); // 1 解构赋值在 JS 中可以使用解构赋值，直接对多个变量同时赋值： 1234let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']];x; // 'hello'y; // 'JavaScript'z; // 'ES6' 12345678910111213var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school'};let {name, passport : id} = person; // 把passport属性赋值给变量id:name; // '小明'id; // 'G-12345678'// 注意: passport不是变量，而是为了让变量id获得passport属性:passport; // Uncaught ReferenceError: passport is not defined 解构赋值在很多时候可以大大简化代码。例如，交换两个变量 $x$ 和 $y$ 的值，可以这么写，不再需要临时变量： 12var x = 1, y = 2;[x, y] = [y, x] 快速获取当前页面的域名和路径： 1var {hostname : domain, pathname : path} = location; 如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个 Date 对象： 123456function buildDate({year, month, day, hour = 0, minute = 0, second = 0}) { return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);}buildDate({ year: 2017, month: 1, day: 1 }); // Sun Jan 01 2017 00:00:00 GMT+0800 (CST)// 传入的对象只需要year、month和day这三个属性 方法可以给对象绑定函数。绑定到对象上的函数叫 方法 ，其在内部使用了 this 关键字。 在方法内部， this 始终指向当前对象。 1234567891011var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; }};xiaoming.age; // function xiaoming.age()xiaoming.age(); // 今年调用是25,明年调用就变成26了 若不通过某个对象直接在函数里调用 this ，this 默认指向 windows 。在 strict 模式下，函数的 this 指向的是 undefined ，从而系统会报错提醒你这里的不规范写法。故要保证 this 指向正确，必须用 obj.xxx() 的形式调用，或者可以用一个变量首先捕获 this 。 12345678910111213'use strict';var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; }};var fn = xiaoming.age;fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined 12345678910111213141516'use strict';var xiaoming = { name: '小明', birth: 1990, age: function () { var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() { var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this } return getAgeFromBirth(); }};xiaoming.age(); // 25","link":"/2023/10/19/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"抽象代数笔记","text":"6.1 代数结构代数系统（代数）：非空集合 和 上的 个一元或二元运算 组成的系统。记作 。 6.1.1 代数运算设 是非空集合， 是从 到 的一个映射，则称 为集合 到 的一个 元代数运算。（其中 称作该运算的阶）。 等这些符号加上 普通 的前缀，才代表的是其原来的运算。 运算的封闭性设 为集合 到 的一个 元运算。若 ,则称 在集合 上是封闭的。e.g. 普通减运算在 上不封闭。 若称一个运算是某个集合上的运算，则该运算必须满足在这个集合上具有封闭性。 1. 运算性质 - 交换律设 为 上的二元运算，若 都有： x \\ast y = y \\ast x则称运算 在 上可交换。若已知该运算的运算表，则可通过判断该表是否满足沿主对角线对称，来判断是否满足交换律。 2. 运算性质 - 结合律设 为 上的二元运算，若 都有: (x \\ast y) \\ast z = x \\ast (y \\ast z)则称运算 在 上可结合。判断该运算是否满足结合律，不能通过运算表直观的看出来。 3. 运算性质 - 分配律设 为 上的二元运算，若 都有： x \\ast (y \\circ z) = (x \\ast y) \\circ (x \\ast z), \\quad 称 \\ast 对 \\circ 左可分配 \\\\ (y \\circ z) \\ast x = (y \\ast x) \\circ (z \\ast x), \\quad 称 \\circ 对 \\ast 右可分配则称 对 可分配。 4. 运算性质 - 吸收律设 为 上的二元运算，若 都有： x \\ast (x \\circ y) = x, \\quad 称 \\ast 对 \\circ 左可吸收 \\\\ (x \\circ y) \\ast x = x, \\quad 称 \\circ 对 \\ast 右可吸收则称 对 可吸收。若 满足交换律，则只需证明一边满足吸收律即可。e.g. 集合中的 运算对 运算可吸收。因为 （右可吸收同理）。 5. 运算性质 - 等幂律设 为 上的二元运算，若 都有: x \\ast x = x则称运算 在 上满足等幂律。 6. 运算性质 - 消去律设 为 上的二元运算，某个元素 ，若 都有： a \\ast x = a \\ast y \\ \\Rightarrow x = y, \\quad 称a是左可消去的 \\\\ x \\ast a = y \\ast a \\ \\Rightarrow x = y, \\quad 称a是右可消去的则称 关于 运算 是可消去的。若 中所有的元素都满足消去律，则可说明 满足消去律。 叫做永真蕴含式。箭头左边的式子叫做前件，右边的叫做后件。永真蕴含式表明，若前件成立，则后件一定成立。永真蕴含式的逆否形式也成立。 可消去性可以从运算表中观察到。若 满足消去律，则运算表中每一行每一列中都没有相同的元素。 6.1.2 代数常元该代数系统中与运算相关的特殊元素称作代数常元。 1. 幺元设 是定义在 上的二元运算，若存在元素 (或 ) 使得 都有： e_l \\ast x = x \\quad （或 \\ x \\ast e_r = x）则称 (或 ) 是 中关于 运算的左（右）幺元。若 既是左幺元又是右幺元，则称 是 中关于 运算的幺元。且 是 上关于 的唯一的幺元。 2. 零元设 是定义在 上的二元运算，若存在元素 (或 ) 使得 都有： \\theta_l \\ast x = \\theta_l \\quad （或 \\ x \\ast \\theta_r = \\theta_r）则称 (或 ) 是 中关于 运算的左（右）零元。若 既是左零元又是右零元，则称 是 中关于 运算的零元。且 是 上关于 的唯一的零元。 3. 逆元设 是定义在 上的二元运算， 是 中关于 运算的幺元。对于 , 如果存在 （或 ）使得： y_l \\ast x = e \\quad （或 \\ x \\ast y_r = e）则称 (或 ) 是 的左（右）逆元。若 既是左逆元又是右逆元，则称 是 的逆元。 若 运算是可结合的，且对于 存在 ，则 是 的唯一的逆元, 。 6.2 子代数6.2.1 子代数的定义设 是一个代数系统， 分别是载体 上的二元运算和一元运算， 是代数常元。若： A' \\subseteq A \\\\ A' 对 \\ast 和 \\varDelta 均封闭 \\\\ k \\subseteq A'则称 是 的子代数系统。若 ， 被称为 的最大的子代数。若 ， 被称为 的最小的子代数。最大和最小子代数被称为 的平凡子代数。其余的子代数（）被称为 的真子代数。 6.3 同态6.3.1 同态的定义设 两个具有相同构成的代数系统， 是从 到 的一个映射， 且对 满足（先运算再映射 = 先映射再运算）： f(a\\astb) = f(a) \\ast'f(b) \\\\ f(\\varDelta a) = \\varDelta'f(a) \\\\ f(k) = k'则称 为由 到 的一个同态映射， 简称同态， 记作 。 6.3.2 同态象设 是从 到 的同态映射，称 为 在映射 下的同态象。 6.3.3 同态的分类设 是从 到 的一个映射。 满射：若 中每个值都能在 中找到其原象，则称 是一个满射。 单射：若 ，都有 。则称 是一个单射。 双射：既是满射又是双射的映射。 设 是从 到 的一个同态映射。 若 是满射的，则称 是一个满同态。 若 是单射的，则称 是一个单一同态。 若 是双射的，则称 是一个同构映射，简称同构，记作 。 若 ，则称 为 上的自同态。 若 且 是双射的，则称 为 上的自同构。 6.3.4 同态的性质设 是从 到 的一个同态映射。那么 的同态象 。 是 的子代数。 若 在 中可交换（可结合），则 在 中也可交换（可结合）。 若在 中 对 可分配，则在 中 对 也可分配。 若 是 中关于运算 的幺元，则 也是 中关于运算 的幺元。 若 是 中关于运算 的零元，则 也是 中关于运算 的零元。 , 对运算 存在逆元 ；则在 中， 也有关于运算 的逆元 。 6.4 同余6.4.1 同余的定义设代数系统 ， 是载体 上的等价关系。 ： 当 时，若 ，则说明等价关系在一元运算 下是可保持的，称 是关于运算 的同余关系。 当 时，若 ，则说明等价关系在二元运算 下是可保持的，称 是关于运算 的同余关系。 若 在 上的所有运算下都是可保持的，则称 是代数系统 上的同余关系。 等价关系具有对称性、自反性、传递性。 6.4.2 与同态有关的定理设 是从 到 的一个同态映射。若在 上定义等价关系 ： \\langle a, b \\rangle \\in R, \\quad iff: g(a) = g(b)则 是 上的一个同余关系。 6.5 商代数6.5.1 商代数的定义与性质设代数系统 ， 是 上的同余关系。则称 关于 的商代数 。其中 。 是集合的集合，即等价类的集合。该集合是 的一个划分，即该集合中任意两元素（集合）的交集是空集（因为等价具有传递性）。 是集合间的运算， 是代数常元的集合。 小结：由等价关系 可以得到代数系统 的载体的一个划分，以这个划分为新的载体，按照原运算的规则建立等价类之间新的运算，这样得到的代数系统是原代数系统的商代数。 6.6 半群与独异点6.6.1 半群与子半群半群：对于一个代数系统 ， 是 上的二元运算，若运算 是可结合的，则称 为半群。子半群：设 是一个半群， 且 在 上是封闭的，那么 是 的子代数。 也是一个半群，称为 的子半群（因为结合律在子代数上可继承）。 6.6.2 独异点与子独异点独异点：含有幺元的半群（含幺半群）。子独异点：满足是原代数系统的子代数，本身是独异点，且在相同运算下与原代数系统有相同幺元，那么称为是原独异点的子独异点。 6.6.3 半群与独异点的等幂元性质设 是一个半群，若 是一个有限集，则必存在 ，使得 。证明：结合鸽巢原理。 6.6.4 交换半群与循环独异点交换半群（独异点）：在半群（独异点）中，若运算是可交换的，则称此半群（独异点）为交换半群（独异点）。 循环独异点：设 是一个独异点，若 ，则 使得 （ 是 个 做运算的意思），则称此独异点为循环独异点。 （存在一个数能把其他所有数都表示出来） 称为该循环独异点的生成元，一个循环独异点的生成元个数可以不唯一。 6.7 群6.7.1 群的定义群：设 是一个代数系统。若 运算是可结合的（是半群），并且存在幺元（是独异点），并且 ，都存在其唯一的逆元 ，则称 是一个群。 群的阶数：群的元素个数，记作 。根据 可以将群分为有限群和无限群。 6.7.2 群的性质 群中无零元。 （因为零元不可逆，故群中一定不含零元。） 群中每个元素的逆元唯一。 设 是一个群，对于 ，必存在唯一的 ，使得 。 （即群中任何两个元素都能通过运算相互表示。） 设 是一个群， ，若有 或者 ，则必有 （消去律）。 （因为没有零元，所以可以直接消去。） 设 是一个群，除幺元 外，不可能有任何别的等幂元。 群 的运算表的每一行/每一列都是 中所有元素的一个置换。 （ 中每一个元素都会在运算表中的每一行/每一列出现，并且只出现一次。）","link":"/2023/10/18/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/"},{"title":"CSP认证复建记录（于2023.09停更）","text":"2021042.邻域均值通过题目限制得出 的范围，二维前缀和统计即可。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int n, L, r, cnt, a[700][700], sum[700][700];double ans, t;int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; L &gt;&gt; r &gt;&gt; t; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { cin &gt;&gt; a[i][j]; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i][j]; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { int ex = min(n, i + r), ey = min(n, j + r), sx = max(1, i - r), sy = max(1, j - r); ans = 1.0 * (sum[ex][ey] - sum[ex][sy - 1] - sum[sx - 1][ey] + sum[sx - 1][sy - 1]) / ((ex - sx + 1) * (ey - sy + 1)); if (ans &lt;= t) cnt++; } } cout &lt;&lt; cnt &lt;&lt; \"\\n\"; return 0;} 2021092.非零段划分提前记录下来每个值出现过的位置。依次增加 的值，每次找到 个数中等于 的值的位置能产生的贡献（和左右两边 的出现情况有关）。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;const int N = 5e5 + 5;const int M = 1e4 + 5;using namespace std;int n, ans, maxx, a[N];vector&lt;int&gt; f[M];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int cnt = 0; for (int i = 1; i &lt;= n; i++) { f[a[i]].push_back(i); if (a[i] == 0) { if (cnt &gt; 0) { ans++; cnt = 0; } } else cnt++; } if (cnt &gt; 0) ans++; maxx = max(maxx, ans); for (int i = 1; i &lt;= M - 5; i++) { for (auto pos : f[i]) { a[pos] = 0; if (pos == 1 &amp;&amp; a[pos + 1] == 0) ans--; else if (pos == n &amp;&amp; a[pos - 1] == 0) ans--; else { if (a[pos - 1] == 0 &amp;&amp; a[pos + 1] == 0) ans--; else if (a[pos - 1] != 0 &amp;&amp; a[pos + 1] != 0) ans++; } } maxx = max(maxx, ans); } cout &lt;&lt; maxx &lt;&lt; endl; return 0;} 2021122.序列查询新解不难发现 每 个增加 ，故可以按段来统计，注意边界情况的讨论。 2022032.出行计划由题意不难得到有效条件的区间，差分即可。注意双边不等式的左边可能会小于 ，可以通过整体平移的方式（或者和 取 max 的方法）。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;const int lim = 2e5 + 5;using namespace std;int n, m, k, t, c, x, d[lim &lt;&lt; 1];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; t &gt;&gt; c; d[(lim - 5) + t - c - k + 1]++; d[(lim - 5) + t - k + 1]--; } for (int i = 0; i &lt;= (lim - 5) &lt;&lt; 1; i++) d[i] += d[i - 1]; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; x; cout &lt;&lt; d[(lim - 5) + x] &lt;&lt; endl; } return 0;} 2022062.寻宝！大冒险！把大地图中每个为 的点记录下来，用相对坐标依次进行比对，统计即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#define mp make_pair#define fi first#define se secondconst int N = 100;using namespace std;int n, L, S, x, y, ans, b[N][N];vector&lt;pair&lt;int, int&gt; &gt; a, dir;map&lt;pair&lt;int, int&gt;, int&gt; mapp;bool check(pair&lt;int, int&gt; u, pair&lt;int, int&gt; v) { int dx = u.fi + S + 1, dy = u.se + S + 1; if (dx &gt; L + 1 || dy &gt; L + 1) return true; int x = u.fi + v.fi, y = u.se + v.se; return b[v.fi][v.se] ^ mapp[mp(x, y)];}int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; L &gt;&gt; S; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x &gt;&gt; y; mapp[mp(x, y)]++; a.push_back(mp(x, y)); } for (int i = 0; i &lt;= S; i++) { for (int j = 0; j &lt;= S; j++) { cin &gt;&gt; b[i][j]; } } for (int j = 0; j &lt;= S; j++) { for (int i = 0; i &lt; S / 2 + 1; i++) swap(b[i][j], b[S - i][j]); } for (int i = 0; i &lt;= S; i++) { for (int j = 0; j &lt;= S; j++) { if (i == 0 &amp;&amp; j == 0) continue; dir.push_back(mp(i, j)); } } for (auto now : a) { bool flag = true; for (auto dxy : dir) { if (check(now, dxy)) { flag = false; break; } } if (flag) ans++; } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 3.角色授权STL 无脑叠 log， 喜提 70pts. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;const int N = 1e5;using namespace std;int n, m, q, x, id, id1, id2, ido, idc, idr;string ch_name, opt, cls, rnm, name, uname, gname, opname, rcls, rname, ss;map&lt;string, int&gt; mapp, oplist, clslist, rnmlist, ulist, glist;map&lt;int, int&gt; spe1, spe2, ch_opt[N], ch_cls[N], ch_rnm[N], uright[N], gright[N];vector&lt;string&gt; ucon[N], gcon[N], ori[N]; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; while (n--) { cin &gt;&gt; ch_name; mapp[ch_name] = ++id; cin &gt;&gt; x; while (x--) { cin &gt;&gt; opt; if (!oplist[opt]) oplist[opt] = ++ido; ch_opt[id][oplist[opt]] = 1; if (opt == \"*\") spe1[id] = 1; } cin &gt;&gt; x; while (x--) { cin &gt;&gt; cls; if (!clslist[cls]) clslist[cls] = ++idc; ch_cls[id][clslist[cls]] = 1; if (cls == \"*\") spe2[id] = 1; } cin &gt;&gt; x; while (x--) { cin &gt;&gt; rnm; if (!rnmlist[rnm]) rnmlist[rnm] = ++idr; ch_rnm[id][rnmlist[rnm]] = 1; } } while (m--) { cin &gt;&gt; ch_name &gt;&gt; x; while (x--) { cin &gt;&gt; ss &gt;&gt; name; if (ss == \"u\") { if (!ulist[name]) ulist[name] = ++id1; uright[mapp[ch_name]][ulist[name]] = 1; ucon[ulist[name]].push_back(ch_name); } else { if (!glist[name]) glist[name] = ++id2; gright[mapp[ch_name]][glist[name]] = 1; gcon[glist[name]].push_back(ch_name); } } } while (q--) { cin &gt;&gt; uname &gt;&gt; x; if (!ulist[uname]) ulist[uname] = ++id1; while (x--) { cin &gt;&gt; gname; if (!glist[gname]) glist[gname] = ++id2; ori[ulist[uname]].push_back(gname); } bool flag = 0; cin &gt;&gt; opname &gt;&gt; rcls &gt;&gt; rname; for (auto ch_name : ucon[ulist[uname]]) { if (uright[mapp[ch_name]][ulist[uname]]) { if (ch_opt[mapp[ch_name]][oplist[opname]] || spe1[mapp[ch_name]]) { if (ch_cls[mapp[ch_name]][clslist[rcls]] || spe2[mapp[ch_name]]) { if (ch_rnm[mapp[ch_name]].empty() || ch_rnm[mapp[ch_name]][rnmlist[rname]]) { flag = 1; } } } } } if (flag == 0) { for (auto gname : ori[ulist[uname]]) { for (auto ch_name : gcon[glist[gname]]) { if (gright[mapp[ch_name]][glist[gname]]) { if (ch_opt[mapp[ch_name]][oplist[opname]] || spe1[mapp[ch_name]]) { if (ch_cls[mapp[ch_name]][clslist[rcls]] || spe2[mapp[ch_name]]) { if (ch_rnm[mapp[ch_name]].empty() || ch_rnm[mapp[ch_name]][rnmlist[rname]]) { flag = 1; } } } } } } } cout &lt;&lt; flag &lt;&lt; endl; ori[ulist[uname]].clear(); } return 0;} 2022092.何以包邮70pts 二进制枚举，100pts 完全背包。 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;const int lim = 3e5 + 5;using namespace std;int n, m, sum, a[50], f[lim];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; f[0] = 1; for (int i = 1; i &lt;= n; i++) { sum += a[i]; for (int j = lim - 5; j &gt;= a[i]; j--) f[j] |= f[j - a[i]]; } for (int i = m; i &lt;= sum; i++) { if (f[i]) { cout &lt;&lt; i &lt;&lt; endl; return 0; } } return 0;} 202212训练计划建正图反图分别跑一遍。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define mp make_pair#define fi first#define se secondconst int N = 5050;using namespace std;bool flag;int n, m, x, maxx, in[N], nin[N], ans[N], a[N];vector&lt;int&gt; g[N], ng[N];queue&lt;pair&lt;int, int&gt; &gt; q;void dfs(int x) { for (auto to : ng[x]) { ans[to] = min(ans[to], ans[x] - a[to]); dfs(to); }}int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; x; if (x) { g[x].push_back(i); in[i]++; ng[i].push_back(x); nin[x]++; } } for (int i = 1; i &lt;= m; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= m; i++) { if (in[i] == 0) q.push(mp(i, 1)); } while (!q.empty()) { auto now = q.front(); q.pop(); int u = now.fi, w = now.se; ans[u] = w; maxx = max(maxx, ans[u]); if (ans[u] + a[u] - 1 &gt; n) flag = 1; for (auto v : g[u]) { if (--in[v] == 0) q.push(mp(v, ans[u] + a[u])); } } for (int i = 1; i &lt;= m; i++) cout &lt;&lt; ans[i] &lt;&lt; (i == m ? \"\\n\" : \" \"); memset(ans, 0x3f, sizeof(ans)); if (!flag) { for (int i = 1; i &lt;= m; i++) { if (nin[i] == 0) q.push(mp(i, n - a[i] + 1)); } while (!q.empty()) { auto now = q.front(); q.pop(); ans[now.fi] = now.se; dfs(now.fi); } for (int i = 1; i &lt;= m; i++) cout &lt;&lt; ans[i] &lt;&lt; (i == m ? \"\\n\" : \" \"); } return 0;} 2023052.矩阵运算通过交换相乘的次序，化简时间复杂度。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;const int N = 10500;const int D = 25;using namespace std;int n, d, w[N], q[N][D], k[N][D], v[N][D], tk[D][N];long long kv[N][N], ans[N][D];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(\"in\",\"r\", stdin); cin &gt;&gt; n &gt;&gt; d; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= d; j++) cin &gt;&gt; q[i][j]; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= d; j++) { cin &gt;&gt; k[i][j]; tk[j][i] = k[i][j]; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= d; j++) cin &gt;&gt; v[i][j]; } for (int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i]; //d * n * n * d for (int k = 1; k &lt;= n; k++) { for (int i = 1; i &lt;= d; i++) { for (int j = 1; j &lt;= d; j++) kv[i][j] += 1ll * tk[i][k] * v[k][j]; } } //n * d * d * d for (int k = 1; k &lt;= d; k++) { for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= d; j++) ans[i][j] += 1ll * q[i][k] * kv[k][j]; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= d; j++) ans[i][j] = 1ll * ans[i][j] * w[i]; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= d; j++) cout &lt;&lt; ans[i][j] &lt;&lt; (j == d ? \"\\n\" : \" \"); } return 0;} 2023092.坐标变换(其二)由于每次操作中的 伸缩倍数一样，即若单独考虑经过所有的伸缩操作后， 变成了 ， 不难得出 。同时发现逆时针旋转的操作的角度可以叠加，故用一个前缀积数组存伸缩操作，一个前缀和数组存旋转操作，最终依次直接计算即可。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define mp make_pair#define fi first#define se secondconst int N = 1e5 + 5;const int INF = 1 &lt;&lt; 30;using namespace std;int n, m, opt, i, j;double x, y, mul[N], sum[N];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; m; mul[0] = 1.0; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; opt &gt;&gt; x; if (opt == 1) { mul[i] = mul[i - 1] * x; sum[i] = sum[i - 1]; } else { mul[i] = mul[i - 1]; sum[i] = sum[i - 1] + x; } } while (m--) { cin &gt;&gt; i &gt;&gt; j &gt;&gt; x &gt;&gt; y; double nowk = mul[j] / mul[i - 1], nowth = sum[j] - sum[i - 1], ncos = cos(nowth), nsin = sin(nowth); printf(\"%lf %lf\\n\", nowk * (x * ncos - y * nsin), nowk * (x * nsin + y * ncos)); } return 0;}","link":"/2023/09/01/CSP%E8%AE%A4%E8%AF%81%E5%A4%8D%E5%BB%BA%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8E2023-09%E5%81%9C%E6%9B%B4%EF%BC%89/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/08/19/hello-world/"}],"tags":[],"categories":[],"pages":[]}